{"version":3,"names":["getScrollableParentToAttachInfiniteScroll","node","nodeToCheck","window","document","documentElement","overflowY","getComputedStyle","tagName","parentElement","infiniteScrollCss","ChInfiniteScrollStyle0","PRECISION_OFFSET","ChInfiniteScroll","exports","_a","_lastClientHeight","set","this","_lastScrollHeight","_lastScrollTop","_ioWatcher","_resizeWatcher","_abortController","_smartGridRef","_scrollableParent","_typeOfParentElementAttached","_canFetch","_this","loadingState","_checkIfCanFetchMoreData","__classPrivateFieldGet","_disconnectInfiniteScroll","call","requestAnimationFrame","_setInfiniteScroll","_emitInfiniteEvent","infiniteThresholdReachedCallback","dataProvider","disabled","options","root","rootMargin","threshold","__classPrivateFieldSet","IntersectionObserver","entries","isIntersecting","observe","el","_attachScroll","_c","AbortController","addEventListener","_trackLastScrollTop","capture","passive","signal","scrollTop","scrollHeight","_setInverseLoading","position","overflowingContent","querySelector","ResizeObserver","_adjustInverseScrollPositionWhenContentSizeChanges","currentClientHeight","clientHeight","currentScrollHeight","firstTimeThatContentOverflows","newScrollTop","scrollWasAtTheBottom","scrollOffset","clientHeightOffset","_disconnectInverseLoading","disconnect","undefined","abort","class_1","prototype","dataProviderChanged","hasDataProvider","disabledChanged","isDisabled","loadingStateChanged","newValue","thresholdChanged","complete","componentDidLoad","getRootNode","host","result","disconnectedCallback","render","h","Host","key","class","smartGridCss","ChSmartGridStyle0","HIDE_CONTENT_AFTER_LOADING_CLASS","ChSmartGrid","_b","_contentIsHidden","_infiniteThresholdReachedCallback","infiniteThresholdReached","emit","_avoidCLSOnInitialLoad","inverseLoading","classList","add","_removeAvoidCLS","removeEventListener","remove","class_2","handleVirtualItemsChanged","event","detail","startIndex","endIndex","totalItems","infiniteScrollEnabled","connectedCallback","adoptCommonThemes","shadowRoot","adoptedStyleSheets","autoGrow","componentDidRender","initialLoad","hasRecords","itemsCount","accessibleName","SCROLLABLE_CLASS","name","smartGridCellCss","ChSmartGridCellStyle0","ChSmartGridCell","class_3","setAttribute","smartCellDidLoad","cellId"],"sources":["src/components/smart-grid/internal/infinite-scroll/utils.ts","src/components/smart-grid/internal/infinite-scroll/infinite-scroll.scss?tag=ch-infinite-scroll&encapsulation=shadow","src/components/smart-grid/internal/infinite-scroll/infinite-scroll.tsx","src/components/smart-grid/smart-grid.scss?tag=ch-smart-grid&encapsulation=shadow","src/components/smart-grid/smart-grid.tsx","src/components/smart-grid/internal/smart-grid-cell/smart-grid-cell.scss?tag=ch-smart-grid-cell","src/components/smart-grid/internal/smart-grid-cell/smart-grid-cell.tsx"],"sourcesContent":["/**\r\n * @todo TODO: Test this function when the element has an iframe as its parent element.\r\n *\r\n * Recursively look for a parent element in the `node`'s tree to calculate the\r\n * infinite scroll visibility and attach the scroll event listener.\r\n *\r\n * Considerations:\r\n *  - This algorithm starts with `node` === `this.el`.\r\n *  - If the parent grid has auto-grow = False, the return value should be\r\n *    the virtual scroller that is used in the parent grid.\r\n * @param node An element that will serve to recursively look up the parent element of `this.el` to attach the scroll event listener.\r\n * @returns A parent element of `node` in which the scroll event listener must be attached.\r\n */\r\nexport const getScrollableParentToAttachInfiniteScroll = (\r\n  node: Element | HTMLElement\r\n): [\"ch-smart-grid\" | \"other\" | \"window\", Element | HTMLElement] => {\r\n  let nodeToCheck = node;\r\n\r\n  // TODO: Add support for using getRootNode() to ensure node === null does\r\n  // not mean we hit a shadow boundary\r\n  while (\r\n    nodeToCheck !== null &&\r\n    nodeToCheck !== window.document.documentElement\r\n  ) {\r\n    // We try to search for first scrollable parent element.\r\n    const overflowY = window.getComputedStyle(node).overflowY;\r\n\r\n    // The last condition must be used, as the parent container could clip\r\n    // (overflow: hidden) its overflow. In that scenario, the scroll is \"hidden\"\r\n    // or \"locked\" but set\r\n    if (overflowY === \"auto\" || overflowY === \"scroll\") {\r\n      return [\r\n        nodeToCheck.tagName === \"ch-smart-grid\" ? \"ch-smart-grid\" : \"other\",\r\n        nodeToCheck\r\n      ];\r\n    }\r\n\r\n    nodeToCheck = nodeToCheck.parentElement as Element;\r\n  }\r\n\r\n  return [\"window\", window.document.documentElement];\r\n};\r\n",":host {\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  text-align: center;\r\n  block-size: 0; // Not loading by default\r\n  inline-size: 100%;\r\n  pointer-events: none;\r\n}\r\n\r\n// \"Hide\" the infinite scroll, but with the possibility to check its position\r\n// in the parent's scroll\r\n:host(.loading) {\r\n  block-size: auto;\r\n}\r\n","import {\r\n  Component,\r\n  ComponentInterface,\r\n  Element,\r\n  Host,\r\n  Method,\r\n  Prop,\r\n  Watch,\r\n  h\r\n} from \"@stencil/core\";\r\nimport { SmartGridDataState } from \"./types\";\r\nimport { getScrollableParentToAttachInfiniteScroll } from \"./utils\";\r\n\r\n/**\r\n * Due to floating point precision errors, we have to ensure a safe threshold\r\n * to update the scroll position to the bottom.\r\n */\r\nconst PRECISION_OFFSET = 2;\r\n\r\n@Component({\r\n  shadow: true,\r\n  styleUrl: \"infinite-scroll.scss\",\r\n  tag: \"ch-infinite-scroll\"\r\n})\r\nexport class ChInfiniteScroll implements ComponentInterface {\r\n  // Stored values\r\n  #lastClientHeight = 0;\r\n  #lastScrollHeight = 0;\r\n  #lastScrollTop = 0;\r\n\r\n  // Observers\r\n  #ioWatcher: IntersectionObserver | undefined;\r\n  #resizeWatcher: ResizeObserver | undefined;\r\n  #abortController: AbortController | undefined; // Allocated at runtime to save resources\r\n\r\n  // Refs\r\n  #smartGridRef!: HTMLChSmartGridElement;\r\n  #scrollableParent!: Element | HTMLElement;\r\n\r\n  #typeOfParentElementAttached: \"ch-smart-grid\" | \"window\" | \"other\" = \"other\";\r\n\r\n  @Element() el!: HTMLChInfiniteScrollElement;\r\n\r\n  /**\r\n   * `true` if the infinite scroll is used in a grid that has data provider.\r\n   * This attribute determine the utility of the infinite scroll, because in\r\n   * certain configurations the infinite scroll can be used only to implement\r\n   * the inverse loading utility.\r\n   */\r\n  @Prop() readonly dataProvider: boolean = false;\r\n  @Watch(\"dataProvider\")\r\n  dataProviderChanged(hasDataProvider: boolean) {\r\n    if (hasDataProvider) {\r\n      // Wait until the main thread has rendered the UI\r\n      requestAnimationFrame(this.#setInfiniteScroll);\r\n    } else {\r\n      this.#disconnectInfiniteScroll();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Specifies if the infinite scroll is disabled. When disabled, the infinite\r\n   * scroll won't fire any event when reaching the threshold.\r\n   * The `dataProvider` property can be `true` and this property can be `false`\r\n   * at the same time, meaning that the infinite scroll is disabled, but if the\r\n   * control has `inverseLoading`, the `dataProvider` property will re-position\r\n   * the scrollbar when new content is added to the grid.\r\n   */\r\n  @Prop() readonly disabled: boolean = false;\r\n  @Watch(\"disabled\")\r\n  disabledChanged(isDisabled: boolean) {\r\n    if (isDisabled) {\r\n      this.#disconnectInfiniteScroll();\r\n    } else {\r\n      // Wait until the main thread has rendered the UI\r\n      requestAnimationFrame(this.#setInfiniteScroll);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This Handler will be called every time grid threshold is reached. Needed\r\n   * for infinite scrolling grids.\r\n   */\r\n  @Prop() readonly infiniteThresholdReachedCallback!: () => void;\r\n\r\n  /**\r\n   * If `true`, the infinite scroll will be hidden and scroll event listeners\r\n   * will be removed.\r\n   *\r\n   * Set this to `false` to disable the infinite scroll from actively trying to\r\n   * receive new data while reaching the threshold. This is useful when it is\r\n   * known that there is no more data that can be added, and the infinite\r\n   * scroll is no longer needed.\r\n   */\r\n  @Prop({ mutable: true }) loadingState!: SmartGridDataState;\r\n  @Watch(\"loadingState\")\r\n  loadingStateChanged(newValue: SmartGridDataState) {\r\n    this.#checkIfCanFetchMoreData();\r\n\r\n    if (newValue === \"initial\") {\r\n      this.#lastClientHeight = 0;\r\n      this.#lastScrollHeight = 0;\r\n      this.#lastScrollTop = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The position of the infinite scroll element.\r\n   * The value can be either `top` or `bottom`. When `position === \"top\"`, the\r\n   * control also implements inverse loading.\r\n   */\r\n  @Prop() readonly position: \"top\" | \"bottom\" = \"bottom\";\r\n\r\n  /**\r\n   * The threshold distance from the bottom of the content to call the\r\n   * `infinite` output event when scrolled.\r\n   * The threshold value can be either a percent, or in pixels. For example,\r\n   * use the value of `10%` for the `infinite` output event to get called when\r\n   * the user has scrolled 10% from the bottom of the page. Use the value\r\n   * `100px` when the scroll is within 100 pixels from the bottom of the page.\r\n   */\r\n  @Prop() readonly threshold: string = \"150px\";\r\n  @Watch(\"threshold\")\r\n  thresholdChanged() {\r\n    this.#checkIfCanFetchMoreData();\r\n  }\r\n\r\n  /**\r\n   * Call `complete()` within the `gxInfinite` output event handler when\r\n   * your async operation has completed. For example, the `loading`\r\n   * state is while the app is performing an asynchronous operation,\r\n   * such as receiving more data from an AJAX request to add more items\r\n   * to a data list. Once the data has been received and UI updated, you\r\n   * then call this method to signify that the loading has completed.\r\n   * This method will change the infinite scroll's state from `loading`\r\n   * to `enabled`.\r\n   */\r\n  @Method()\r\n  async complete() {\r\n    // this.waitingForData = false;\r\n  }\r\n\r\n  #canFetch = () => this.loadingState === \"more-data-to-fetch\";\r\n\r\n  /**\r\n   * This function unobserves and re-observes the infinite scroll element when\r\n   * new items are added in the grid. Without this configuration, if the grid\r\n   * has no scroll even after new items are added, the intersection observer\r\n   * won't fire a new interruption because it is still visible in the viewport.\r\n   */\r\n  // eslint-disable-next-line @stencil-community/own-props-must-be-private\r\n  #checkIfCanFetchMoreData = () => {\r\n    this.#disconnectInfiniteScroll();\r\n\r\n    // Wait until the main thread has rendered the UI\r\n    requestAnimationFrame(this.#setInfiniteScroll);\r\n  };\r\n\r\n  #emitInfiniteEvent = () => {\r\n    if (this.loadingState !== \"loading\") {\r\n      // Ensure the infinite scroll is not triggered twice\r\n      this.loadingState = \"loading\";\r\n      this.infiniteThresholdReachedCallback();\r\n    }\r\n  };\r\n\r\n  #setInfiniteScroll = () => {\r\n    // The observer was already set\r\n    if (!this.dataProvider || this.disabled) {\r\n      return;\r\n    }\r\n\r\n    // Track the threshold changes after the DOM is updated\r\n    requestAnimationFrame(() => {\r\n      // The ioWatcher must be checked inside the RAF, to avoid memory issues,\r\n      // due to dispatching multiple #setInfiniteScroll, without the watcher defined\r\n      if (!this.#canFetch() || this.#ioWatcher) {\r\n        return;\r\n      }\r\n\r\n      const options: IntersectionObserverInit = {\r\n        root: this.#scrollableParent,\r\n        rootMargin: this.threshold\r\n      };\r\n\r\n      this.#ioWatcher = new IntersectionObserver(entries => {\r\n        if (entries[0].isIntersecting) {\r\n          this.#emitInfiniteEvent();\r\n        }\r\n      }, options);\r\n\r\n      this.#ioWatcher.observe(this.el);\r\n    });\r\n  };\r\n\r\n  #attachScroll = () => {\r\n    this.#abortController ??= new AbortController();\r\n\r\n    this.#scrollableParent.addEventListener(\r\n      \"scroll\",\r\n      this.#trackLastScrollTop,\r\n      { capture: true, passive: true, signal: this.#abortController.signal }\r\n    );\r\n  };\r\n\r\n  #trackLastScrollTop = () => {\r\n    this.#lastScrollTop = this.#scrollableParent.scrollTop;\r\n    this.#lastScrollHeight = this.#scrollableParent.scrollHeight;\r\n  };\r\n\r\n  #setInverseLoading = () => {\r\n    // Inverse loading is not supported when the scroll is attached to the window.\r\n    // The current implementation \"supports\" this scenario, but since this use\r\n    // case changes the position of the scroll every time the grid retrieves\r\n    // data, unexpected behaviors will occur.\r\n    // Also, Android does not support Inverse Loading in this scenario either.\r\n    if (\r\n      this.#typeOfParentElementAttached === \"window\" ||\r\n      this.position !== \"top\"\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    // Attach scroll after the DOM is rendered\r\n    requestAnimationFrame(this.#attachScroll);\r\n\r\n    /**\r\n     * This element represents the cell container (`[slot=\"grid-content\"]`).\r\n     * ```tsx\r\n     *   <ch-smart-grid>\r\n     *     #shadow-root (open)\r\n     *     |  <ch-infinite-scroll></ch-infinite-scroll>\r\n     *     |  <slot name=\"grid-content\"></slot>\r\n     *     <div slot=\"grid-content\">\r\n     *       <ch-smart-grid-cell>...</ch-smart-grid-cell>\r\n     *       <ch-smart-grid-cell>...</ch-smart-grid-cell>\r\n     *       ...\r\n     *     </div>\r\n     *   </ch-smart-grid>\r\n     * ```\r\n     */\r\n    const overflowingContent = this.#smartGridRef.querySelector(\r\n      \"[slot='grid-content']\"\r\n    ) as HTMLElement;\r\n\r\n    overflowingContent.scrollTop =\r\n      overflowingContent.scrollHeight + PRECISION_OFFSET;\r\n\r\n    this.#resizeWatcher = new ResizeObserver(\r\n      this.#adjustInverseScrollPositionWhenContentSizeChanges\r\n    );\r\n\r\n    this.#resizeWatcher.observe(overflowingContent);\r\n    this.#resizeWatcher.observe(this.#scrollableParent);\r\n  };\r\n\r\n  #adjustInverseScrollPositionWhenContentSizeChanges = () => {\r\n    // console.log(\"adjustInverseScrollPositionWhenContentSizeChanges...\");\r\n\r\n    // Current values\r\n    const currentClientHeight = this.#scrollableParent.clientHeight;\r\n    const currentScrollHeight = this.#scrollableParent.scrollHeight;\r\n\r\n    const firstTimeThatContentOverflows =\r\n      this.#lastClientHeight === this.#lastScrollHeight &&\r\n      currentClientHeight < currentScrollHeight;\r\n\r\n    // Must set the scroll at the bottom position\r\n    if (firstTimeThatContentOverflows) {\r\n      const newScrollTop =\r\n        currentScrollHeight - currentClientHeight + PRECISION_OFFSET;\r\n\r\n      this.#lastClientHeight = currentClientHeight;\r\n      this.#lastScrollHeight = currentScrollHeight;\r\n\r\n      // Scroll to bottom\r\n      this.#scrollableParent.scrollTop = newScrollTop;\r\n      this.#lastScrollTop = newScrollTop;\r\n      return;\r\n    }\r\n\r\n    const scrollWasAtTheBottom =\r\n      this.#lastScrollHeight <=\r\n      this.#lastClientHeight + this.#lastScrollTop + PRECISION_OFFSET;\r\n\r\n    // The scroll is only adjusted if the grid has a data provider or the\r\n    // scroll was at the bottom position. When the grid has a data provider\r\n    // items can be loaded via infinite scroll, so the scroll position needs\r\n    // adjusted when new items are added\r\n    if (this.dataProvider || scrollWasAtTheBottom) {\r\n      const scrollOffset = currentScrollHeight - this.#lastScrollHeight;\r\n      const clientHeightOffset =\r\n        currentClientHeight < this.#lastClientHeight\r\n          ? this.#lastClientHeight - currentClientHeight\r\n          : 0;\r\n\r\n      const newScrollTop =\r\n        this.#lastScrollTop +\r\n        scrollOffset +\r\n        clientHeightOffset +\r\n        (scrollWasAtTheBottom ? PRECISION_OFFSET : 0); // Scroll to bottom\r\n\r\n      this.#scrollableParent.scrollTop = newScrollTop;\r\n      this.#lastScrollTop = newScrollTop;\r\n    }\r\n\r\n    this.#lastClientHeight = currentClientHeight;\r\n    this.#lastScrollHeight = currentScrollHeight;\r\n  };\r\n\r\n  #disconnectInverseLoading = () => {\r\n    this.#resizeWatcher?.disconnect();\r\n    this.#resizeWatcher = undefined;\r\n\r\n    // Remove scroll events in the smart grid\r\n    this.#abortController.abort();\r\n  };\r\n\r\n  #disconnectInfiniteScroll = () => {\r\n    this.#ioWatcher?.disconnect();\r\n    this.#ioWatcher = undefined;\r\n  };\r\n\r\n  componentDidLoad() {\r\n    this.#smartGridRef = (this.el.getRootNode() as ShadowRoot)\r\n      .host as HTMLChSmartGridElement;\r\n\r\n    const result = getScrollableParentToAttachInfiniteScroll(\r\n      this.#smartGridRef\r\n    );\r\n    this.#typeOfParentElementAttached = result[0];\r\n    this.#scrollableParent = result[1];\r\n\r\n    this.#setInverseLoading();\r\n\r\n    // Wait until the main thread has rendered the UI\r\n    requestAnimationFrame(this.#setInfiniteScroll);\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    this.#disconnectInfiniteScroll();\r\n    this.#disconnectInverseLoading();\r\n  }\r\n\r\n  // TODO: Ensure the ch-infinite-scroll doesn't crash when is only used by\r\n  // itself (without a ch-smart-grid as a parent)\r\n  render() {\r\n    return (\r\n      <Host\r\n        class={this.loadingState === \"loading\" ? \"loading\" : undefined}\r\n        aria-hidden=\"true\"\r\n      >\r\n        {this.loadingState === \"loading\" && <slot />}\r\n      </Host>\r\n    );\r\n  }\r\n}\r\n",":host {\r\n  display: grid;\r\n  grid-template-rows: 1fr;\r\n  grid-template-columns: 1fr;\r\n}\r\n\r\n:host(.ch-smart-grid--loaded-render-delay) {\r\n  opacity: 0;\r\n\r\n  // Disable scroll actions on intial load\r\n  pointer-events: none;\r\n}\r\n\r\n:host(.ch-smart-grid--inverse-loading) {\r\n  grid-template-rows: max-content 1fr;\r\n}\r\n\r\n:host(.ch-smart-grid--data-provider) {\r\n  grid-template-rows: 1fr max-content;\r\n}\r\n\r\n// This class is set when the smart-grid defines its own scroll\r\n:host(.ch-scrollable) {\r\n  contain: strict;\r\n  overflow: auto;\r\n  overflow-anchor: none;\r\n}\r\n\r\n::slotted([slot=\"grid-content\"]) {\r\n  display: grid;\r\n  grid-auto-rows: max-content;\r\n}\r\n","import {\r\n  Component,\r\n  ComponentInterface,\r\n  Element,\r\n  Event,\r\n  EventEmitter,\r\n  Host,\r\n  Listen,\r\n  Prop,\r\n  State,\r\n  // Watch,\r\n  h\r\n} from \"@stencil/core\";\r\nimport { AccessibleNameComponent } from \"../../common/interfaces\";\r\nimport { SmartGridDataState } from \"./internal/infinite-scroll/types\";\r\nimport { VirtualScrollVirtualItems } from \"../../virtual-scroller/types\";\r\nimport { ChVirtualScrollerCustomEvent } from \"../../components\";\r\nimport { SCROLLABLE_CLASS } from \"../../common/reserved-names\";\r\nimport { adoptCommonThemes } from \"../../common/theme\";\r\n\r\nconst HIDE_CONTENT_AFTER_LOADING_CLASS = \"ch-smart-grid--loaded-render-delay\";\r\n\r\n@Component({\r\n  shadow: true,\r\n  styleUrl: \"smart-grid.scss\",\r\n  tag: \"ch-smart-grid\"\r\n})\r\nexport class ChSmartGrid\r\n  implements AccessibleNameComponent, ComponentInterface\r\n{\r\n  /**\r\n   * Used in virtual scroll scenarios. Enables infinite scrolling if the\r\n   * virtual items are closer to the real threshold.\r\n   */\r\n  @State() infiniteScrollEnabled = true;\r\n\r\n  /**\r\n   * This variable is used to avoid layout shifts (CLS) at the initial load,\r\n   * due to the async render of the content.\r\n   */\r\n  // eslint-disable-next-line @stencil-community/own-props-must-be-private\r\n  #contentIsHidden = false;\r\n\r\n  @Element() el: HTMLChSmartGridElement;\r\n\r\n  /**\r\n   * Specifies a short string, typically 1 to 3 words, that authors associate\r\n   * with an element to provide users of assistive technologies with a label\r\n   * for the element.\r\n   */\r\n  @Prop() readonly accessibleName: string;\r\n\r\n  /**\r\n   * This attribute defines if the control size will grow automatically,\r\n   * to adjust to its content size.\r\n   * If set to `false`, it won't grow automatically and it will show scrollbars\r\n   * if the content overflows.\r\n   */\r\n  @Prop() readonly autoGrow: boolean = false;\r\n\r\n  /**\r\n   * `true` if the control has a data provider and therefore must implement a\r\n   * infinite scroll to load data.\r\n   */\r\n  @Prop() readonly dataProvider: boolean = false;\r\n\r\n  /**\r\n   * When set to `true`, the grid items will be loaded in inverse order, with\r\n   * the first element at the bottom and the \"Loading\" message (infinite-scroll)\r\n   * at the top.\r\n   */\r\n  @Prop() readonly inverseLoading: boolean = false;\r\n\r\n  /**\r\n   * Grid current row count. This property is used in order to be able to\r\n   * re-render the Grid every time the Grid data changes.\r\n   * If not specified, then grid empty and loading placeholders may not work\r\n   * correctly.\r\n   */\r\n  @Prop() readonly itemsCount!: number;\r\n\r\n  /**\r\n   * Specifies the loading state of the grid.\r\n   */\r\n  @Prop({ mutable: true }) loadingState: SmartGridDataState = \"initial\";\r\n  // @Watch(\"loadingState\")\r\n  // loadingStateChange(_, oldLoadingState: SmartGridDataState) {\r\n  //   if (oldLoadingState === \"initial\") {\r\n  //     this.#avoidCLSOnInitialLoad();\r\n  //   }\r\n  // }\r\n\r\n  /**\r\n   * The threshold distance from the bottom of the content to call the\r\n   * `infinite` output event when scrolled. The threshold value can be either a\r\n   * percent, or in pixels. For example, use the value of `10%` for the\r\n   * `infinite` output event to get called when the user has scrolled 10% from\r\n   * the bottom of the page. Use the value `100px` when the scroll is within\r\n   * 100 pixels from the bottom of the page.\r\n   */\r\n  @Prop() readonly threshold: string = \"10px\";\r\n\r\n  /**\r\n   * This Handler will be called every time grid threshold is reached. Needed\r\n   * for infinite scrolling grids.\r\n   */\r\n  @Event({ bubbles: false }) infiniteThresholdReached: EventEmitter<void>;\r\n\r\n  @Listen(\"virtualItemsChanged\")\r\n  handleVirtualItemsChanged(\r\n    event: ChVirtualScrollerCustomEvent<VirtualScrollVirtualItems>\r\n  ) {\r\n    const { startIndex, endIndex, totalItems } = event.detail;\r\n\r\n    this.infiniteScrollEnabled =\r\n      (this.inverseLoading && startIndex === 0) ||\r\n      (!this.inverseLoading && endIndex === totalItems - 1);\r\n  }\r\n\r\n  #infiniteThresholdReachedCallback = () => {\r\n    this.loadingState = \"loading\";\r\n    this.infiniteThresholdReached.emit();\r\n  };\r\n\r\n  #avoidCLSOnInitialLoad = () => {\r\n    if (this.inverseLoading) {\r\n      this.#contentIsHidden = true;\r\n      this.el.classList.add(HIDE_CONTENT_AFTER_LOADING_CLASS);\r\n    }\r\n  };\r\n\r\n  #removeAvoidCLS = () => {\r\n    this.#contentIsHidden = false;\r\n    this.el.removeEventListener(\"virtualScrollerDidLoad\", this.#removeAvoidCLS);\r\n\r\n    requestAnimationFrame(() => {\r\n      this.el.classList.remove(HIDE_CONTENT_AFTER_LOADING_CLASS);\r\n    });\r\n  };\r\n\r\n  connectedCallback(): void {\r\n    // TODO: Investigate this. If we don't add this function call, but we add\r\n    // the class in the Host, the scrollbar is styled, but it shouldn't\r\n    adoptCommonThemes(this.el.shadowRoot.adoptedStyleSheets);\r\n    this.#avoidCLSOnInitialLoad();\r\n\r\n    if (this.inverseLoading && !this.autoGrow) {\r\n      this.el.addEventListener(\"virtualScrollerDidLoad\", this.#removeAvoidCLS);\r\n    }\r\n  }\r\n\r\n  componentDidRender(): void {\r\n    if (!this.#contentIsHidden) {\r\n      return;\r\n    }\r\n\r\n    if (this.inverseLoading && this.autoGrow) {\r\n      this.#removeAvoidCLS();\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const initialLoad = this.loadingState === \"initial\";\r\n    const hasRecords = this.itemsCount > 0;\r\n\r\n    return (\r\n      <Host\r\n        aria-label={this.accessibleName || undefined}\r\n        // Improve accessibility by announcing live changes\r\n        aria-live=\"polite\"\r\n        // Wait until all changes are made to prevents assistive\r\n        // technologies from announcing changes before updates are done\r\n        aria-busy={\r\n          initialLoad || this.loadingState === \"loading\" ? \"true\" : \"false\"\r\n        }\r\n        class={{\r\n          \"ch-smart-grid--inverse-loading\": hasRecords && this.inverseLoading,\r\n          \"ch-smart-grid--data-provider\":\r\n            hasRecords && this.dataProvider && !this.inverseLoading,\r\n          [SCROLLABLE_CLASS]: !this.autoGrow\r\n        }}\r\n      >\r\n        {initialLoad ? (\r\n          <slot name=\"grid-initial-loading-placeholder\" />\r\n        ) : (\r\n          [\r\n            // TODO: Don't attach the ch-infinite-scroll component if the\r\n            // smart-grid doesn't have an slot \"grid-content\" in its Light DOM\r\n            // Otherwise, the ch-infinite-scroll will break in runtime\r\n            hasRecords && this.inverseLoading && (\r\n              <ch-infinite-scroll\r\n                dataProvider={this.dataProvider}\r\n                disabled={!this.infiniteScrollEnabled}\r\n                infiniteThresholdReachedCallback={\r\n                  this.#infiniteThresholdReachedCallback\r\n                }\r\n                loadingState={this.loadingState}\r\n                position=\"top\"\r\n                threshold={this.threshold}\r\n              ></ch-infinite-scroll>\r\n            ),\r\n\r\n            <slot name={hasRecords ? \"grid-content\" : \"grid-content-empty\"} />,\r\n\r\n            hasRecords && this.dataProvider && !this.inverseLoading && (\r\n              <ch-infinite-scroll\r\n                dataProvider\r\n                disabled={!this.infiniteScrollEnabled}\r\n                infiniteThresholdReachedCallback={\r\n                  this.#infiniteThresholdReachedCallback\r\n                }\r\n                loadingState={this.loadingState}\r\n                threshold={this.threshold}\r\n              ></ch-infinite-scroll>\r\n            )\r\n          ]\r\n        )}\r\n      </Host>\r\n    );\r\n  }\r\n}\r\n","smart-grid-cell {\r\n  display: flex;\r\n}\r\n","import {\r\n  Component,\r\n  ComponentInterface,\r\n  Element,\r\n  Event,\r\n  EventEmitter,\r\n  Prop\r\n} from \"@stencil/core\";\r\n\r\n@Component({\r\n  styleUrl: \"smart-grid-cell.scss\",\r\n  tag: \"ch-smart-grid-cell\"\r\n})\r\nexport class ChSmartGridCell implements ComponentInterface {\r\n  @Element() el: HTMLChSmartGridCellElement;\r\n\r\n  /**\r\n   * Specifies the ID of the cell.\r\n   */\r\n  @Prop() readonly cellId!: string;\r\n\r\n  /**\r\n   * Fired when the component and all its child did render for the first time.\r\n   */\r\n  @Event() smartCellDidLoad: EventEmitter<string>;\r\n\r\n  connectedCallback() {\r\n    this.el.setAttribute(\"role\", \"gridcell\");\r\n  }\r\n\r\n  componentDidLoad() {\r\n    this.smartCellDidLoad.emit(this.cellId);\r\n\r\n    // DOM write operation\r\n    this.el.setAttribute(\"data-did-load\", \"true\");\r\n  }\r\n}\r\n"],"mappings":"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"}