{"version":3,"names":["linkDefinitions","Map","linkDefinitionPromises","getLinkDefinition","id","linkDefinition","get","undefined","definitionRequest","promise","resolver","definitionPromise","Promise","resolve","set","setLinkDefinition","url","pendingPromise","clearLinkDefinitions","clear","HEADING_ID_REGEX","LAST_NESTED_CHILD_CLASS","codeToJSX","HTMLToJSX","lastNestedChild","checkAndGetLastNestedChildClass","element","depthToHeading","content","classes","h","class","tableAlignmentDictionary","left","center","right","tableRender","async","table","metadata","tableHeadRow","children","tableBodyRows","slice","columnCount","length","headCellPromises","map","tableCell","mdASTtoJSX","bodyCellPromises","forEach","tableHead","push","tableHeadContent","allSettled","tableBodyContent","headCells","jsx","value","bodyCells","alignments","align","alignment","index","rowIndex","cellIndex","renderDictionary","blockquote","break","code","then","codeHighlight","parseCodeToJSX","lang","renderCode","definition","identifier","delete","emphasis","footnoteDefinition","footnoteReference","heading","lastChild","at","headingId","type","match","replace","depth","html","rawHTML","import","rawHTMLToJSX","allowDangerousHtml","image","src","alt","title","loading","imageReference","inlineCode","link","includes","href","linkReference","referenceType","label","list","ordered","start","listItem","paragraph","strong","text","thematicBreak","yaml","findLastNestedChild","elementWithChildren","root","childrenLength","asyncJSX","Array","child","renderedContent","markdownToJSX","markdown","mdAST","markdownToMdAST","JSX","codeToJSXDictionary","className","properties","lastNestedChildClass","highlightJSClasses","join","renderCodeChildren","language","isLastNestedChild","actualLanguage","getActualLanguageWithoutAlias","registerLanguage","tree","parseCodeToHAST","nestedChildIsCodeTag","plainText","defaultCodeRender","options","markdownCss","ChMarkdownStyle0","ChMarkdown","JSXTree","componentWillRender","this","rawHtml","render","Host"],"sources":["src/deprecated-components/markdown/parsers/link-resolver.ts","src/deprecated-components/markdown/parsers/markdown-to-jsx.tsx","src/deprecated-components/markdown/parsers/code-highlight.tsx","src/deprecated-components/markdown/markdown.scss?tag=ch-markdown","src/deprecated-components/markdown/markdown.tsx"],"sourcesContent":["const linkDefinitions = new Map<string, string>();\r\n\r\nconst linkDefinitionPromises = new Map<\r\n  string,\r\n  { promise: Promise<string>; resolver: (url: string) => void }\r\n>();\r\n\r\nexport const getLinkDefinition = (id: string): Promise<string> | string => {\r\n  // See if we already have the definition\r\n  const linkDefinition = linkDefinitions.get(id);\r\n\r\n  if (linkDefinition !== undefined) {\r\n    return linkDefinition;\r\n  }\r\n\r\n  // See if we already have a Promise for this definition\r\n  const definitionRequest = linkDefinitionPromises.get(id);\r\n\r\n  if (definitionRequest !== undefined) {\r\n    return definitionRequest.promise;\r\n  }\r\n\r\n  let resolver: (value: string | PromiseLike<string>) => void;\r\n\r\n  // Create the promise and store the resolver to resolve the promise when the\r\n  // definition is encounter in the parser\r\n  const definitionPromise = new Promise<string>(resolve => {\r\n    resolver = resolve;\r\n\r\n    // TODO: Should resolve after 10s or so to avoid dead lock?\r\n  });\r\n\r\n  linkDefinitionPromises.set(id, {\r\n    promise: definitionPromise,\r\n    resolver: resolver\r\n  });\r\n\r\n  return definitionPromise;\r\n};\r\n\r\nexport const setLinkDefinition = (id: string, url: string) => {\r\n  // Store the url\r\n  linkDefinitions.set(id, url);\r\n\r\n  // See if are pending Promises to be resolved\r\n  const pendingPromise = linkDefinitionPromises.get(id);\r\n\r\n  if (pendingPromise !== undefined) {\r\n    pendingPromise.resolver(url);\r\n  }\r\n};\r\n\r\nexport const clearLinkDefinitions = () => {\r\n  linkDefinitions.clear();\r\n  linkDefinitionPromises.clear();\r\n};\r\n","import { h } from \"@stencil/core\";\r\nimport { AlignType, Code, Root, Table } from \"mdast\";\r\nimport { markdownToMdAST } from \"@genexus/markdown-parser\";\r\n\r\nimport {\r\n  ElementsWithChildren,\r\n  ElementsWithoutCustomRender,\r\n  MarkdownToJSXCommonMetadata\r\n} from \"./types\";\r\nimport { parseCodeToJSX } from \"./code-highlight\"; // The implementation is not used in the initial load, only the type.\r\nimport { rawHTMLToJSX } from \"./raw-html-to-jsx\";\r\nimport {\r\n  clearLinkDefinitions,\r\n  getLinkDefinition,\r\n  setLinkDefinition\r\n} from \"./link-resolver\";\r\n\r\n/**\r\n * Regex to match the id of the heading.\r\n *\r\n * @input `\"# Hello, world {#something} \"`\r\n * @output `something`\r\n */\r\nconst HEADING_ID_REGEX = /\\{#(.*?)\\}/;\r\n\r\nexport const LAST_NESTED_CHILD_CLASS = \"last-nested-child\";\r\n\r\n// Lazy load the code parser implementation\r\nlet codeToJSX: typeof parseCodeToJSX;\r\nlet HTMLToJSX: typeof rawHTMLToJSX;\r\nlet lastNestedChild: Root | ElementsWithChildren | Code;\r\n\r\nconst checkAndGetLastNestedChildClass = (element: ElementsWithChildren) =>\r\n  element === lastNestedChild ? LAST_NESTED_CHILD_CLASS : undefined;\r\n\r\nconst depthToHeading = {\r\n  1: (content: any, classes: string | null, id?: string) => (\r\n    <h1 class={classes} id={id}>\r\n      {content}\r\n    </h1>\r\n  ),\r\n  2: (content: any, classes: string | null, id?: string) => (\r\n    <h2 class={classes} id={id}>\r\n      {content}\r\n    </h2>\r\n  ),\r\n  3: (content: any, classes: string | null, id?: string) => (\r\n    <h3 class={classes} id={id}>\r\n      {content}\r\n    </h3>\r\n  ),\r\n  4: (content: any, classes: string | null, id?: string) => (\r\n    <h4 class={classes} id={id}>\r\n      {content}\r\n    </h4>\r\n  ),\r\n  5: (content: any, classes: string | null, id?: string) => (\r\n    <h5 class={classes} id={id}>\r\n      {content}\r\n    </h5>\r\n  ),\r\n  6: (content: any, classes: string | null, id?: string) => (\r\n    <h6 class={classes} id={id}>\r\n      {content}\r\n    </h6>\r\n  )\r\n} as const;\r\n\r\nconst tableAlignmentDictionary: { [key in AlignType]: string } = {\r\n  left: \"ch-markdown-table-column-start\",\r\n  center: \"ch-markdown-table-column-center\",\r\n  right: \"ch-markdown-table-column-end\"\r\n};\r\n\r\nconst tableRender = async (\r\n  table: Table,\r\n  metadata: MarkdownToJSXCommonMetadata\r\n) => {\r\n  const tableHeadRow = table.children[0];\r\n  const tableBodyRows = table.children.slice(1);\r\n  const columnCount = tableHeadRow.children.length;\r\n\r\n  // Head cell promises\r\n  const headCellPromises = tableHeadRow.children.map(tableCell =>\r\n    mdASTtoJSX(tableCell, metadata)\r\n  );\r\n\r\n  const bodyCellPromises = [];\r\n\r\n  // Body cell promises\r\n  tableBodyRows.forEach(tableHead => {\r\n    tableHead.children.forEach(tableCell => {\r\n      bodyCellPromises.push(mdASTtoJSX(tableCell, metadata));\r\n    });\r\n  });\r\n\r\n  // Wait for all results to be completed in parallel\r\n  const tableHeadContent = await Promise.allSettled(headCellPromises);\r\n  const tableBodyContent = await Promise.allSettled(bodyCellPromises);\r\n\r\n  // Return the JSX array\r\n  const headCells = tableHeadContent.map(\r\n    jsx => (jsx as PromiseFulfilledResult<any>).value\r\n  );\r\n  const bodyCells = tableBodyContent.map(\r\n    jsx => (jsx as PromiseFulfilledResult<any>).value\r\n  );\r\n\r\n  const alignments = table.align.map(\r\n    alignment => tableAlignmentDictionary[alignment]\r\n  );\r\n\r\n  return (\r\n    <table>\r\n      <thead>\r\n        <tr>\r\n          {tableHeadRow.children.map((tableCell, index) => (\r\n            <th\r\n              class={{\r\n                [alignments[index]]: !!alignments[index],\r\n                [LAST_NESTED_CHILD_CLASS]: tableCell === lastNestedChild\r\n              }}\r\n            >\r\n              {headCells[index]}\r\n            </th>\r\n          ))}\r\n        </tr>\r\n      </thead>\r\n\r\n      <tbody>\r\n        {tableBodyRows.map((tableHead, rowIndex) => (\r\n          <tr>\r\n            {tableHead.children.map((tableCell, cellIndex) => (\r\n              <td\r\n                class={{\r\n                  [alignments[cellIndex]]: !!alignments[cellIndex],\r\n                  [LAST_NESTED_CHILD_CLASS]: tableCell === lastNestedChild\r\n                }}\r\n              >\r\n                {bodyCells[columnCount * rowIndex + cellIndex]}\r\n              </td>\r\n            ))}\r\n          </tr>\r\n        ))}\r\n      </tbody>\r\n    </table>\r\n  );\r\n};\r\n\r\nexport const renderDictionary: {\r\n  [key in keyof ElementsWithoutCustomRender]: (\r\n    element: ElementsWithoutCustomRender[key],\r\n    metadata: MarkdownToJSXCommonMetadata\r\n  ) => Promise<any> | any;\r\n} = {\r\n  blockquote: async (element, metadata) => {\r\n    const content = await mdASTtoJSX(element, metadata);\r\n\r\n    return (\r\n      <blockquote class={checkAndGetLastNestedChildClass(element)}>\r\n        {content}\r\n      </blockquote>\r\n    );\r\n  }, // TODO: Check if code can be inside this tag\r\n\r\n  break: () => <br />,\r\n\r\n  code: async (element, metadata) => {\r\n    // Load the parser implementation\r\n    codeToJSX ||= (await import(\"./code-highlight\")).parseCodeToJSX; // TODO: Resolve race condition\r\n    const content = await codeToJSX(\r\n      element.value,\r\n      element.lang,\r\n      metadata.renderCode,\r\n      element === lastNestedChild\r\n    );\r\n\r\n    return content;\r\n  },\r\n\r\n  definition: element => setLinkDefinition(element.identifier, element.url),\r\n\r\n  delete: async (element, metadata) => {\r\n    const content = await mdASTtoJSX(element, metadata);\r\n\r\n    return (\r\n      <del class={checkAndGetLastNestedChildClass(element)}>{content}</del>\r\n    );\r\n  }, // TODO: Check if code can be inside this tag\r\n\r\n  emphasis: async (element, metadata) => {\r\n    const content = await mdASTtoJSX(element, metadata);\r\n\r\n    return <em class={checkAndGetLastNestedChildClass(element)}>{content}</em>;\r\n  }, // TODO: Check if code can be inside this tag\r\n\r\n  footnoteDefinition: () => \"\",\r\n\r\n  footnoteReference: () => \"\",\r\n\r\n  heading: async (element, metadata) => {\r\n    // Check if the heading has an id\r\n    const lastChild = element.children.at(-1);\r\n    let headingId: string;\r\n\r\n    if (lastChild?.type === \"text\") {\r\n      const match = lastChild.value.match(HEADING_ID_REGEX);\r\n\r\n      if (match && match.length > 1) {\r\n        headingId = match[1];\r\n\r\n        // Remove markdown id from the header text\r\n        lastChild.value = lastChild.value.replace(`{#${headingId}}`, \"\");\r\n      }\r\n    }\r\n\r\n    // Render the content after the heading id processing\r\n    const content = await mdASTtoJSX(element, metadata);\r\n    const classes = checkAndGetLastNestedChildClass(element);\r\n\r\n    return depthToHeading[element.depth](content, classes, headingId); // TODO: Add anchor icon at the start of the heading\r\n  },\r\n\r\n  html: async (element, metadata) => {\r\n    if (metadata.rawHTML && !HTMLToJSX) {\r\n      // Load the parser implementation\r\n      HTMLToJSX = (await import(\"./raw-html-to-jsx\")).rawHTMLToJSX;\r\n    }\r\n\r\n    return metadata.rawHTML\r\n      ? HTMLToJSX(element.value, metadata.allowDangerousHtml)\r\n      : element.value;\r\n  },\r\n\r\n  image: element => (\r\n    <img\r\n      src={element.url}\r\n      alt={element.alt}\r\n      title={element.title}\r\n      loading=\"lazy\"\r\n    />\r\n  ),\r\n\r\n  imageReference: () => \"\",\r\n\r\n  inlineCode: element => <code class=\"hljs\">{element.value}</code>,\r\n\r\n  link: async (element, metadata) => {\r\n    // Sanitize scripts\r\n    if (element.url.includes(\"javascript:\")) {\r\n      return;\r\n    }\r\n\r\n    const content = await mdASTtoJSX(element, metadata);\r\n\r\n    return (\r\n      <a\r\n        aria-label={element.title || null}\r\n        title={element.title || null}\r\n        class={checkAndGetLastNestedChildClass(element)}\r\n        href={element.url}\r\n      >\r\n        {content}\r\n      </a>\r\n    );\r\n  }, // TODO: Sanitize href?\r\n\r\n  linkReference: async (element, metadata) => {\r\n    const content = await mdASTtoJSX(element, metadata);\r\n    let url = \"\";\r\n\r\n    // TODO: Implement the rest of alternatives for \"referenceType\"\r\n    if (element.referenceType === \"shortcut\") {\r\n      url = await getLinkDefinition(element.identifier);\r\n    }\r\n\r\n    // TODO: It's unnecessary to set aria-label when referenceType === \"shortcut\"\r\n    // TODO: The title is not supported well. See \"An Example Putting the Parts Together\" section in markdown.html\r\n\r\n    // Sanitize scripts\r\n    if (url.includes(\"javascript:\")) {\r\n      return;\r\n    }\r\n\r\n    return (\r\n      <a\r\n        aria-label={element.label || null}\r\n        class={checkAndGetLastNestedChildClass(element)}\r\n        href={url}\r\n      >\r\n        {content}\r\n      </a>\r\n    );\r\n  },\r\n\r\n  list: async (element, metadata) => {\r\n    const content = await mdASTtoJSX(element, metadata);\r\n\r\n    return element.ordered ? (\r\n      <ol\r\n        class={checkAndGetLastNestedChildClass(element)}\r\n        start={element.start}\r\n      >\r\n        {content}\r\n      </ol> // TODO: Implement spread  // TODO: Check if code can be inside this tag\r\n    ) : (\r\n      <ul class={checkAndGetLastNestedChildClass(element)}>{content}</ul> // TODO: Implement spread  // TODO: Check if code can be inside this tag\r\n    );\r\n  },\r\n\r\n  listItem: async (element, metadata) => {\r\n    const content = await mdASTtoJSX(element, metadata);\r\n\r\n    return <li class={checkAndGetLastNestedChildClass(element)}>{content}</li>;\r\n  }, // TODO: Implement spread  // TODO: Check if code can be inside this tag\r\n\r\n  paragraph: async (element, metadata) => {\r\n    const content = await mdASTtoJSX(element, metadata);\r\n\r\n    return <p class={checkAndGetLastNestedChildClass(element)}>{content}</p>;\r\n  }, // TODO: Check if code can be inside this tag\r\n\r\n  strong: async (element, metadata) => {\r\n    const content = await mdASTtoJSX(element, metadata);\r\n\r\n    return (\r\n      <strong class={checkAndGetLastNestedChildClass(element)}>\r\n        {content}\r\n      </strong>\r\n    );\r\n  }, // TODO: Check if code can be inside this tag\r\n\r\n  table: tableRender, // TODO: Check if code can be inside this tag\r\n\r\n  text: element => element.value,\r\n\r\n  thematicBreak: () => <hr />,\r\n\r\n  yaml: () => \"\"\r\n} as const;\r\n\r\nconst findLastNestedChild = (\r\n  elementWithChildren: ElementsWithChildren | Root\r\n) => {\r\n  const lastChild = elementWithChildren.children.at(-1);\r\n\r\n  // The last element have children. We must check its sub children\r\n  if ((lastChild as ElementsWithChildren).children?.length > 0) {\r\n    return findLastNestedChild(lastChild as ElementsWithChildren);\r\n  }\r\n\r\n  if (lastChild.type === \"code\") {\r\n    return lastChild;\r\n  }\r\n\r\n  return elementWithChildren;\r\n};\r\n\r\n/**\r\n * Converts markdown abstract syntax tree (mdast) into JSX.\r\n */\r\nasync function mdASTtoJSX(\r\n  root: ElementsWithChildren | Root,\r\n  metadata: MarkdownToJSXCommonMetadata\r\n) {\r\n  const childrenLength = root.children.length;\r\n  const asyncJSX = new Array(childrenLength);\r\n\r\n  // Get the async JSX\r\n  for (let index = 0; index < childrenLength; index++) {\r\n    const child = root.children[index];\r\n\r\n    asyncJSX.push(renderDictionary[child.type](child, metadata));\r\n  }\r\n\r\n  // Wait for all results to be completed in parallel\r\n  const renderedContent = await Promise.allSettled(asyncJSX);\r\n\r\n  // Return the JSX array\r\n  return renderedContent.map(jsx => (jsx as PromiseFulfilledResult<any>).value);\r\n}\r\n\r\nexport const markdownToJSX = async (\r\n  markdown: string,\r\n  metadata: MarkdownToJSXCommonMetadata\r\n) => {\r\n  const mdAST: Root = markdownToMdAST(markdown);\r\n\r\n  // First, find the last nested child. Useful to set a marker in the element\r\n  // that accomplish this condition\r\n  lastNestedChild = findLastNestedChild(mdAST);\r\n\r\n  // Render the markdown as JSX\r\n  const JSX = await mdASTtoJSX(mdAST, metadata);\r\n\r\n  // Clear all definitions used to render the current markdown, so the next\r\n  // render does not have old information\r\n  clearLinkDefinitions();\r\n\r\n  return JSX;\r\n};\r\n","import { h } from \"@stencil/core\";\r\nimport { Element as HElement, Text as HText, Root as HRoot } from \"hast\";\r\n\r\nimport {\r\n  getActualLanguageWithoutAlias,\r\n  parseCodeToHAST,\r\n  registerLanguage\r\n} from \"@genexus/markdown-parser/dist/parse-code.js\";\r\nimport { MarkdownCodeRender, MarkdownCodeRenderOptions } from \"./types\";\r\nimport { LAST_NESTED_CHILD_CLASS } from \"./markdown-to-jsx\";\r\n\r\nlet lastNestedChild: HRoot | HElement;\r\n\r\nconst checkAndGetLastNestedChildClass = (\r\n  element: HElement\r\n): string | undefined =>\r\n  element === lastNestedChild ? LAST_NESTED_CHILD_CLASS : undefined;\r\n\r\nconst codeToJSXDictionary = {\r\n  element: (element: HElement) => {\r\n    const className = element.properties.className as string[];\r\n\r\n    const lastNestedChildClass = checkAndGetLastNestedChildClass(element);\r\n    const highlightJSClasses = className ? className.join(\" \") : undefined;\r\n\r\n    return (\r\n      <span\r\n        class={{\r\n          [highlightJSClasses]: !!highlightJSClasses,\r\n          [lastNestedChildClass]: !!lastNestedChildClass\r\n        }}\r\n      >\r\n        {renderCodeChildren(element)}\r\n      </span>\r\n    );\r\n  },\r\n\r\n  text: (element: HText) => element.value\r\n};\r\n\r\nfunction renderCodeChildren(element: HElement) {\r\n  return element.children.map(child => codeToJSXDictionary[child.type](child));\r\n}\r\n\r\nconst findLastNestedChild = (elementWithChildren: HRoot | HElement) => {\r\n  const lastChild = elementWithChildren.children.at(-1);\r\n\r\n  // The last element have children. We must check its sub children\r\n  if ((lastChild as HElement).children?.length > 0) {\r\n    return findLastNestedChild(lastChild as HElement);\r\n  }\r\n\r\n  return elementWithChildren;\r\n};\r\n\r\nexport const parseCodeToJSX = async (\r\n  code: string,\r\n  language: string,\r\n  renderCode: MarkdownCodeRender,\r\n  isLastNestedChild: boolean\r\n) => {\r\n  const actualLanguage = getActualLanguageWithoutAlias(language || \"plaintext\");\r\n\r\n  // Register the language\r\n  await registerLanguage(actualLanguage);\r\n\r\n  const tree: HRoot = parseCodeToHAST(actualLanguage, code);\r\n  lastNestedChild = undefined; // Reset last nested child\r\n\r\n  // Find last nested child\r\n  if (isLastNestedChild) {\r\n    lastNestedChild = findLastNestedChild(tree);\r\n  }\r\n\r\n  const nestedChildIsCodeTag = isLastNestedChild && tree === lastNestedChild;\r\n\r\n  return renderCode({\r\n    language: language || \"plaintext\",\r\n    nestedChildIsCodeTag: nestedChildIsCodeTag,\r\n    plainText: code,\r\n    renderedContent: tree.children.map(child =>\r\n      codeToJSXDictionary[child.type](child)\r\n    )\r\n  });\r\n};\r\n\r\n/**\r\n * @deprecated Use the `ch-code` component to render code blocks\r\n */\r\nexport const defaultCodeRender: MarkdownCodeRender = (\r\n  options: MarkdownCodeRenderOptions\r\n): any => (\r\n  <pre>\r\n    <code\r\n      class={{\r\n        [`hljs language-${options.language}`]: true,\r\n        [LAST_NESTED_CHILD_CLASS]: options.nestedChildIsCodeTag\r\n      }}\r\n    >\r\n      <div class=\"code-block__content\">{options.renderedContent}</div>\r\n    </code>\r\n  </pre>\r\n);\r\n","ch-markdown {\r\n  display: grid;\r\n  grid-auto-rows: max-content;\r\n}\r\n\r\n.ch-markdown-table-column-start {\r\n  text-align: start;\r\n}\r\n\r\n.ch-markdown-table-column-center {\r\n  text-align: center;\r\n}\r\n\r\n.ch-markdown-table-column-end {\r\n  text-align: end;\r\n}\r\n","import { Component, Element, Host, Prop, h } from \"@stencil/core\";\r\nimport { markdownToJSX } from \"./parsers/markdown-to-jsx\";\r\nimport { defaultCodeRender } from \"./parsers/code-highlight\";\r\nimport { MarkdownCodeRender } from \"./parsers/types\";\r\n\r\n/**\r\n * @deprecated Use the `ch-markdown-viewer` component instead.\r\n *\r\n * A control to render markdown syntax. It supports GitHub Flavored Markdown\r\n * (GFM) and code highlighting.\r\n *  - It parses the incoming markdown to [mdast](https://github.com/syntax-tree/mdast) using [micromark](https://github.com/micromark/micromark) via [mdast-util-from-markdown](https://github.com/syntax-tree/mdast-util-from-markdown).\r\n *\r\n * - After that, it implements a reactivity layer by implementing its own render for the mdast. With this, changes to the input markdown only update the portion of the DOM that changes.\r\n *\r\n * - It supports Github Flavored Markdown (GFM) by using [mdast-util-gfm](https://github.com/syntax-tree/mdast-util-gfm) and [micromark-extension-gfm](https://github.com/micromark/micromark-extension-gfm).\r\n *\r\n * - It supports code highlight by parsing the incomming code of the markdown to [hast](https://github.com/micromark/micromark-extension-gfm) using [lowlight](lowlight). After that, it implements a reactivity layer by implementing its own render for the hast.\r\n *\r\n * - It also supports all programming languages from [highlight.js](https://github.com/highlightjs/highlight.js).\r\n *\r\n * - When the code highlighting is needed at runtime, the control will load on demand the code parser and the programming language needed to parse the code.\r\n */\r\n@Component({\r\n  shadow: false,\r\n  styleUrl: \"markdown.scss\",\r\n  tag: \"ch-markdown\"\r\n})\r\nexport class ChMarkdown {\r\n  #JSXTree: any;\r\n\r\n  @Element() el: HTMLChMarkdownElement;\r\n\r\n  // /**\r\n  //  * `true` to render potentially dangerous user content when rendering HTML\r\n  //  * with the option `rawHtml === true`\r\n  //  */\r\n  // @Prop() readonly allowDangerousHtml: boolean = false;\r\n\r\n  /**\r\n   * `true` to render raw HTML with sanitization.\r\n   */\r\n  @Prop() readonly rawHtml: boolean = false;\r\n\r\n  /**\r\n   * This property allows us to implement custom rendering for the code blocks.\r\n   */\r\n  @Prop() readonly renderCode: MarkdownCodeRender = defaultCodeRender;\r\n\r\n  /**\r\n   * Specifies the markdown string to parse.\r\n   */\r\n  @Prop() readonly value: string;\r\n\r\n  async componentWillRender() {\r\n    if (!this.value) {\r\n      return;\r\n    }\r\n\r\n    this.#JSXTree = await markdownToJSX(this.value, {\r\n      rawHTML: this.rawHtml,\r\n      allowDangerousHtml: true, // Allow dangerous in this version\r\n      renderCode: this.renderCode\r\n    });\r\n  }\r\n\r\n  render() {\r\n    if (!this.value) {\r\n      return \"\";\r\n    }\r\n\r\n    return <Host>{this.#JSXTree}</Host>;\r\n  }\r\n}\r\n"],"mappings":"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"}