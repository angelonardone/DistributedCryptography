{"version":3,"names":["scrollToEdge","event","container","scrollSpeed","scrollThreshold","mousePositionY","clientY","getBoundingClientRect","top","containerHeight","clientHeight","mouseAtTheTop","mouseAtTheBottom","scrollAmount","scrollTop","treeViewCss","ChTreeViewStyle0","TREE_ITEM_TAG_NAME","TREE_DROP_TAG_NAME","TREE_TAG_NAME","CHECKING","INVALID","TEMPORAL_INVALID","VALID","ITEM_SELECTOR","treeItemId","TEXT_FORMAT","ARROW_DOWN_KEY","ARROW_UP_KEY","EDIT_KEY","isTreeDrop","element","tagName","toLowerCase","isTreeItem","isTreeItemOrTreeDrop","elementTagName","getFocusedTreeItem","focusComposedPath","find","canMoveTreeItemFocus","treeItem","editing","getDroppableZoneKey","newContainerId","draggedItems","dropType","JSON","stringify","POSITION_X_DRAG_CUSTOM_VAR","POSITION_Y_DRAG_CUSTOM_VAR","autoId","ChTreeView","keyDownEvents","preventDefault","focusNextItem","mouseEventModifierKey","focusPreviousItem","editable","draggingSelectedItems","needForRAF","lastDragEvent","openSubTreeTimeout","validDroppableZoneCache","Map","dragStartTimestamp","treeViewId","currentDraggedItem","lastOpenSubTreeItem","dragInfo","draggedIds","draggedParentIds","droppableZoneEnter","expandedItemChange","itemContextmenu","itemsDropped","selectedItemsChange","onContextMenu","target","closest","this","emit","id","itemRef","metadata","contextmenuEvent","onKeyDown","keyHandler","key","onDragStart","clear","data","dataTransfer","getData","paredData","parse","draggingInTheDocument","Date","getTime","onDragEnd","onDragEnter","cancelSubTreeOpening","stopPropagation","eventTarget","containerTargetTagName","targetIsTreeItem","dragEnterInformation","getDropTypeAndTreeItemTarget","treeItemTarget","openSubTreeAfterCountdown","validDroppableZone","dragState","onDragLeave","currentTarget","type","nextElementSibling","previousElementSibling","treeItemOrTreeDrop","forceClear","clearTimeout","onDrop","newContainer","dropInTheSameTree","draggingInTree","onItemDragStart","document","addEventListener","trackItemDrag","capture","allItemsCanBeDragged","checkDragValidityAndUpdateDragInfo","detail","dragEvent","effectAllowed","scrollToEdgeOnDrag","fixScrollPositionOnDrag","onItemDragEnd","removeEventListener","resetVariables","onSelectedItemChange","selectedItemInfo","selectedItemsInfo","selectedItemsCallback","ctrlKeyPressed","multiSelection","selected","set","delete","scrollIntoVisible","readTask","el","querySelector","writeTask","scrollIntoView","updateValidDropZone","requestTimestamp","validDrop","droppableZoneKey","shouldUpdateDragEnterInCurrentContainer","getTreeViewItemRef","itemId","cacheKey","droppableZoneState","get","lazyLoad","downloading","dropDisabled","includes","leaf","expanded","setTimeout","openSubTreeCountdown","draggingInATree","stopImmediatePropagation","updateDropEffect","requestAnimationFrame","style","setProperty","clientX","composedPath","itemTarget","dropEffect","draggedElement","elem","isDraggingSelectedItems","has","dataTransferInfo","dragIsEnabledForAllItems","selectedItemKeys","keys","selectedItemValues","values","selectedItemCount","length","every","dragDisabled","map","caption","toString","getDirectParentsOfDraggableItems","setData","parentTreeItemElem","parentElement","push","forEach","selectedItem","parentId","connectedCallback","subscribeToRTLChanges","rtl","rtlDirection","isRTL","disconnectedCallback","unsubscribeToRTLChanges","render","h","Host","class","waitDropProcessing","exportparts","TREE_VIEW_PARTS_DICTIONARY","DRAG_PREVIEW","part","INITIAL_LEVEL","ROOT_ID","getTreeItemLevelPart","evenLevel","TREE_VIEW_ITEM_PARTS_DICTIONARY","EVEN_LEVEL","ODD_LEVEL","getTreeItemExpandedPart","EXPANDED","COLLAPSED","removeTreeViewItems","items","flattenedTreeModel","flattenedCheckboxTreeModel","selectedItems","atLeastOneElement","atLeastOneCheckbox","atLeastOneSelected","itemUIModel","itemInfo","item","parentArray","parentItem","subItemsId","removeElement","findIndex","resolveNewPromise","value","Promise","resolve","scrollIntoVisibleId","path","visitedNode","visitedNodeUIModel","scrollIntoVisiblePath","async","elementRef","rootNode","lazyLoadTreeItemsCallback","pathHasRepeatedElements","Set","size","indexOfLastItemInPath","lastRenderedItemInPath","undefined","indexOfLastRenderItem","thereAreMoreItemsToLazyLoad","canNotLazyLoadRemainingPath","parentUIModel","forceUpdate","nextIndexToLazyLoad","lazy","result","loadLazyContent","treeViewDropCss","ChTreeViewDropStyle0","ChTreeViewDrop","canShowLines","level","levelPart","treeViewItemCss","ChTreeViewItemStyle0","GET_IMAGE_PATH_CALLBACK_REGISTRY","DISTANCE_TO_CHECKBOX_CUSTOM_VAR","DIRECT_TREE_ITEM_CHILDREN","FIRST_ENABLED_SUB_ITEM","LAST_SUB_ITEM","DENY_DROP_CLASS","START_IMAGE_PARTS","IMAGE","START_IMAGE","END_IMAGE_PARTS","END_IMAGE","EXPANDABLE_ID","ENTER_KEY","ESCAPE_KEY","ChTreeViewItem","watcher","ignoreCheckboxChange","startImage","startImageExpanded","endImage","endImageExpanded","headerRef","inputRef","updateChildrenCheckedValue","newValue","toggleCheckboxes","treeItems","getDirectTreeItems","checked","indeterminate","updateChecked","editingChanged","isEditing","removeEditModeOnClick","focus","endImgSrcChanged","newImage","model","endImgSrc","computeImage","expandedChanged","isExpanded","lazyLoadItems","getImagePathCallbackChanged","lastItemChanged","isLastItem","showLines","setResizeObserver","disconnectObserver","partsChanged","newParts","setExportParts","showLinesChanged","newShowLines","lastItem","startImgSrcChanged","startImgSrc","handleToggleCheckboxesChange","newToggleCheckboxesValue","handleCheckBoxChangeInItems","checkboxChange","checkboxToggleChange","itemDragStart","itemDragEnd","modifyCaption","openReference","selectedItemChange","subItem","setFocus","focusNextSibling","nextSiblingItem","disabled","previousSiblingItem","focusLastItem","lastSubItem","setSelected","newChecked","newIndeterminate","direction","getImagePathCallback","img","imageIsString","parsedImg","base","default","startImgType","updateDirectionInImageCustomVar","endImgType","getImageExpandedOrDefault","Array","from","querySelectorAll","ResizeObserver","distanceToCheckbox","height","observe","disconnect","checkIfShouldRemoveEditMode","code","commitEdition","removeEditMode","pointerType","shouldFocusHeader","newCaption","trim","toggleExpand","getSelectedInfo","toggleSelected","toggleOrSelect","expandOnClick","handleActionDblClick","emitOpenReference","handleActionClick","handleActionKeyDown","handleCheckedChange","chCheckboxRef","checkedValue","updatedCheck","allItemsHaveTheSameCheckedValue","eventMustBeEmitted","renderImg","cssClass","src","imageType","alt","loading","handleDragStart","removeDragImage","handleDragEnd","setAttribute","TREE_VIEW_ITEM_EXPORT_PARTS","replace","getControlRegisterProperty","parts","componentWillLoad","componentDidLoad","hasContent","showAllLines","showLastLine","expandedPart","pseudoStartImage","isPseudoElementImg","pseudoEndImage","hasParts","tokenMap","ITEM","DRAG_ENTER","header","expandableButton","HEADER","DISABLED","SELECTED","NOT_SELECTED","EXPAND_BUTTON","EDITING","NOT_EDITING","LEVEL_0_LEAF","styles","onClick","draggable","ref","EXPANDABLE_BUTTON","checkbox","accessibleName","TREE_VIEW_ITEM_CHECKBOX_EXPORT_PARTS","CHECKBOX","unCheckedValue","onInput","customRender","name","action","ACTION","onDblClick","EDIT_CAPTION","onBlur","showDownloadingSpinner","DOWNLOADING","line","LINE","LAST_LINE","role","expandable","GROUP","LAZY_LOADED","itemHasCheckbox","defaultCheckbox","filterWithCase","stringToFilter","filter","matchCase","filterWithString","filterOptions","match","filterDictionary","filterInfo","defaultChecked","list","filterSet","none","unchecked","computeFilter","filterType","hideMatchesAndShowNonMatches","reloadItems","removeItems","beforeProperties","afterProperties","itemToReloadUIModel","noProperties","updateItemsProperties","newItems","oldItemsSet","reloadNewItemsQueue","newItem","newItemOldUIModel","newItemOldInfo","newItemWasLazyLoaded","allSettled","itemToReload","updateItemProperty","properties","newSelectedItems","newCheckboxItems","Object","propertyName","add","getItemPath","itemPath","currentItemUIModel","reverse","treeViewRenderCss","ChTreeViewRenderStyle0","registerDefaultGetImagePathCallback","treeState","registryControlProperty","iconDirection","useGxRender","fromGxImageToURL","gxSettings","gxImageConstructor","DEFAULT_EXPANDED_VALUE","DEFAULT_INDETERMINATE_VALUE","DEFAULT_LAZY_VALUE","DEFAULT_ORDER_VALUE","DEFAULT_SELECTED_VALUE","treeViewHasFilters","gxDragDisabled","itemModel","dragEnabled","gxDropDisabled","dropEnabled","isDropDisabled","treeDropId","defaultRenderItem","treeHasFilter","dropBeforeAndAfterEnabled","filterList","enabled","editableItems","subModel","index","renderItem","lastItemId","dropMode","defaultSortItemsCallback","sort","a","b","order","ChTreeViewRender","selectedChangeScheduled","checkedChangeScheduled","applyFilters","immediateFilter","filterTimeout","filterListAsSet","treeRef","filterChanged","scheduleFilterProcessing","filterDebounceChanged","filterListChanged","filterOptionsChanged","filterTypeChanged","multiSelectionChanged","newMultiSelection","removeAllSelectedItemsExceptForTheLast","modelChanged","flattenModel","checkedItemsChange","itemOpenReference","dropItems","acceptDrop","newParentId","newParentUIModel","actualParent","specificIndexToInsert","moveItemToNewParent","scheduleSelectedItemsChange","flattenItemUIModel","sortItems","scheduleCheckedItemsChange","getItemsInfo","itemsId","treeViewItemsInfo","itemToLazyLoadContent","flattenSubModel","removeItemsResult","treeHasFilters","updateSelectedItems","success","hasOnlyTheItemId","parentInfo","toggleItems","treeItemIds","expand","modifiedTreeItems","updateAllItemsProperties","checkIfThereAreDifferentItemsWithCheckbox","checkIfThereAreDifferentSelectedItems","onCheckboxChange","onLoadLazyContent","promise","then","onModifyCaption","modifyItemCaptionCallback","oldCaption","status","onOpenReference","handleDroppableZoneEnter","checkDroppableZoneCallback","dropInformation","handleSelectedItemsChange","itemsToProcess","previousSelectedItems","selectedItemId","itemIsStillSelected","newSelectedItemInfo","newSelectedItem","handleExpandedItemChange","handleItemContextmenu","handleItemsDropped","dropItemsCallback","response","currentSelectedItems","selectedItemsArray","lastItemIndex","newParentItem","specificIndex","itemUIModelExtended","oldParentItem","oldIndex","newIndex","insertIntoIndex","parentModel","sortItemsCallback","filterSubModel","currentCheckboxItems","aSubItemIsRendered","itemSatisfiesFilter","satisfiesFilter","updateCheckedItems","allItemsWithCheckbox","_","updateFilters","itemsWithCheckbox","validateCheckedAndSelectedItems","processWithDebounce","filterDebounce","filterFunction","currentCheckedItems","getSelectedItemsCallback","componentWillRender","onDroppableZoneEnter","onExpandedItemChange","onItemContextmenu","onItemsDropped","onSelectedItemsChange"],"sources":["src/common/scroll-to-edge.ts","src/components/tree-view/internal/tree-view/tree-view.scss?tag=ch-tree-view&encapsulation=shadow","src/components/tree-view/internal/tree-view/tree-view.tsx","src/components/tree-view/utils.ts","src/components/tree-view/internal/tree-view-drop/tree-view-drop.scss?tag=ch-tree-view-drop&encapsulation=shadow","src/components/tree-view/internal/tree-view-drop/tree-view-drop.tsx","src/components/tree-view/internal/tree-view-item/tree-view-item.scss?tag=ch-tree-view-item&encapsulation=shadow","src/components/tree-view/internal/tree-view-item/tree-view-item.tsx","src/components/tree-view/helpers.ts","src/components/tree-view/reload-items.ts","src/components/tree-view/update-item-property.ts","src/components/tree-view/methods/getItemPath.ts","src/components/tree-view/tree-view-render.scss?tag=ch-tree-view-render&encapsulation=shadow","src/components/tree-view/tree-view-render.tsx"],"sourcesContent":["export const scrollToEdge = (\r\n  event: MouseEvent,\r\n  container: HTMLElement,\r\n  scrollSpeed: number,\r\n  scrollThreshold: number\r\n) => {\r\n  const mousePositionY = event.clientY - container.getBoundingClientRect().top;\r\n\r\n  const containerHeight = container.clientHeight;\r\n  const mouseAtTheTop = mousePositionY <= scrollThreshold;\r\n  const mouseAtTheBottom = mousePositionY > containerHeight - scrollThreshold;\r\n\r\n  if (mouseAtTheTop || mouseAtTheBottom) {\r\n    const scrollAmount = mouseAtTheTop\r\n      ? mousePositionY - scrollThreshold\r\n      : mousePositionY - (containerHeight - scrollThreshold);\r\n\r\n    // Adjust container scroll position\r\n    container.scrollTop += scrollAmount / scrollSpeed;\r\n  }\r\n};\r\n",":host {\r\n  display: contents;\r\n}\r\n\r\n:host(.rtl-direction) > .drag-info {\r\n  --rtl-offset: -100%;\r\n}\r\n\r\n// - - - - - - - - - - - - - - - -\r\n//            Drag info\r\n// - - - - - - - - - - - - - - - -\r\n.drag-info {\r\n  --rtl-offset: 16px;\r\n\r\n  position: fixed;\r\n  left: 0; // Necessary since the custom vars are physical values\r\n  top: 0; // Necessary since the custom vars are physical values\r\n  transform: translate(\r\n    calc(var(--ch-tree-view-dragging-item-x) + var(--rtl-offset)),\r\n    calc(var(--ch-tree-view-dragging-item-y) + 8px)\r\n  );\r\n  pointer-events: none;\r\n  z-index: 1; // Necessary to show the element above the expandable buttons\r\n  animation: fade-in 10ms;\r\n}\r\n\r\n// Remove mouse actions when processing the drop of items\r\n// @todo: Remove keyboard actions\r\n.waiting-drop-processing {\r\n  cursor: wait;\r\n\r\n  ::slotted(*) {\r\n    pointer-events: none;\r\n  }\r\n}\r\n\r\n// Wait until the custom var values are updated to avoid flickering\r\n@keyframes fade-in {\r\n  0%,\r\n  100% {\r\n    opacity: 0;\r\n  }\r\n}\r\n","import {\r\n  Component,\r\n  Element,\r\n  Event,\r\n  EventEmitter,\r\n  Host,\r\n  Listen,\r\n  Method,\r\n  Prop,\r\n  State,\r\n  h,\r\n  readTask,\r\n  writeTask\r\n} from \"@stencil/core\";\r\n\r\nimport {\r\n  TreeViewDataTransferInfo,\r\n  TreeViewDropCheckInfo,\r\n  TreeViewDroppableZoneState,\r\n  TreeViewItemContextMenu,\r\n  TreeViewItemDragStartInfo,\r\n  TreeViewItemExpandedInfo,\r\n  TreeViewItemSelectedInfo,\r\n  TreeViewItemSelected,\r\n  TreeViewDropType\r\n} from \"./types\";\r\nimport {\r\n  focusComposedPath,\r\n  mouseEventModifierKey\r\n} from \"../../../common/helpers\";\r\nimport { scrollToEdge } from \"../../../../common/scroll-to-edge\";\r\nimport { GxDataTransferInfo } from \"../../../../common/types\";\r\nimport { ChTreeViewItemCustomEvent } from \"../../../../components\";\r\nimport { TREE_VIEW_PARTS_DICTIONARY } from \"../../../../common/reserved-names\";\r\nimport {\r\n  isRTL,\r\n  subscribeToRTLChanges,\r\n  unsubscribeToRTLChanges\r\n} from \"../../../../common/utils\";\r\n\r\nconst TREE_ITEM_TAG_NAME = \"ch-tree-view-item\";\r\nconst TREE_DROP_TAG_NAME = \"ch-tree-view-drop\";\r\nconst TREE_TAG_NAME = \"ch-tree-view\";\r\n\r\n// Droppable zone states\r\nconst CHECKING: TreeViewDroppableZoneState = \"checking\";\r\nconst INVALID: TreeViewDroppableZoneState = \"invalid\";\r\nconst TEMPORAL_INVALID: TreeViewDroppableZoneState = \"temporal-invalid\";\r\nconst VALID: TreeViewDroppableZoneState = \"valid\";\r\n\r\n// Selectors\r\n// const CHECKED_ITEMS = `${TREE_ITEM_TAG_NAME}[checked]`;\r\nconst ITEM_SELECTOR = (treeItemId: string) =>\r\n  `${TREE_ITEM_TAG_NAME}[id=\"${treeItemId}\"]`;\r\n\r\nconst TEXT_FORMAT = \"text/plain\";\r\n\r\nconst ARROW_DOWN_KEY = \"ArrowDown\";\r\nconst ARROW_UP_KEY = \"ArrowUp\";\r\nconst EDIT_KEY = \"F2\";\r\n\r\ntype KeyEvents = typeof ARROW_DOWN_KEY | typeof ARROW_UP_KEY | typeof EDIT_KEY;\r\n\r\nconst isTreeDrop = (element: HTMLElement) =>\r\n  element.tagName.toLowerCase() === TREE_DROP_TAG_NAME;\r\n\r\nconst isTreeItem = (element: HTMLElement) =>\r\n  element.tagName.toLowerCase() === TREE_ITEM_TAG_NAME;\r\n\r\nconst isTreeItemOrTreeDrop = (elementTagName: string) =>\r\n  elementTagName === TREE_ITEM_TAG_NAME ||\r\n  elementTagName === TREE_DROP_TAG_NAME;\r\n\r\nconst getFocusedTreeItem = (): HTMLChTreeViewItemElement | undefined =>\r\n  focusComposedPath().find(isTreeItem) as HTMLChTreeViewItemElement;\r\n\r\nconst canMoveTreeItemFocus = (treeItem: HTMLChTreeViewItemElement): boolean =>\r\n  treeItem && !treeItem.editing;\r\n\r\nconst getDroppableZoneKey = (\r\n  newContainerId: string,\r\n  draggedItems: GxDataTransferInfo[],\r\n  dropType: TreeViewDropType\r\n) =>\r\n  `\"newContainerId\":\"${newContainerId}\",\"metadata\":\"${JSON.stringify(\r\n    draggedItems\r\n  )}\",\"dropType\":\"${dropType}\"`;\r\n\r\nconst POSITION_X_DRAG_CUSTOM_VAR = \"--ch-tree-view-dragging-item-x\";\r\nconst POSITION_Y_DRAG_CUSTOM_VAR = \"--ch-tree-view-dragging-item-y\";\r\n\r\nlet autoId = 0;\r\n\r\n/**\r\n * @part drag-preview - The element that contains the preview information for the current drag.\r\n */\r\n@Component({\r\n  tag: \"ch-tree-view\",\r\n  styleUrl: \"tree-view.scss\",\r\n  shadow: true\r\n})\r\nexport class ChTreeView {\r\n  // @todo TODO: Check if key codes works in Safari\r\n  #keyDownEvents: {\r\n    [key in KeyEvents]: (event: KeyboardEvent) => void;\r\n  } = {\r\n    [ARROW_DOWN_KEY]: event => {\r\n      const treeItem = getFocusedTreeItem();\r\n\r\n      if (!canMoveTreeItemFocus(treeItem)) {\r\n        return;\r\n      }\r\n      event.preventDefault();\r\n      treeItem.focusNextItem(mouseEventModifierKey(event));\r\n    },\r\n\r\n    [ARROW_UP_KEY]: event => {\r\n      const treeItem = getFocusedTreeItem();\r\n\r\n      if (!canMoveTreeItemFocus(treeItem)) {\r\n        return;\r\n      }\r\n      event.preventDefault();\r\n      treeItem.focusPreviousItem(mouseEventModifierKey(event));\r\n    },\r\n\r\n    [EDIT_KEY]: event => {\r\n      const treeItem = getFocusedTreeItem();\r\n\r\n      if (!treeItem || !treeItem.editable) {\r\n        return;\r\n      }\r\n\r\n      event.preventDefault();\r\n      treeItem.editing = true;\r\n    }\r\n  };\r\n\r\n  #draggingSelectedItems = false;\r\n  #needForRAF = true; // To prevent redundant RAF (request animation frame) calls\r\n  #lastDragEvent: MouseEvent;\r\n\r\n  #openSubTreeTimeout: NodeJS.Timeout;\r\n\r\n  /**\r\n   * Cache to avoid duplicate requests when checking the droppable zone in the\r\n   * same drag event.\r\n   */\r\n  // eslint-disable-next-line @stencil-community/own-props-must-be-private\r\n  #validDroppableZoneCache: Map<string, TreeViewDroppableZoneState> = new Map();\r\n  #dragStartTimestamp: number; // Useful to avoid race conditions where the server response is slow\r\n  #draggedItems: GxDataTransferInfo[];\r\n\r\n  /**\r\n   * Useful to identify the control and subscribe to RTL changes\r\n   */\r\n  // eslint-disable-next-line @stencil-community/own-props-must-be-private\r\n  #treeViewId: string;\r\n\r\n  // Refs\r\n  #currentDraggedItem: HTMLChTreeViewItemElement;\r\n  #lastOpenSubTreeItem: HTMLChTreeViewItemElement | HTMLChTreeViewDropElement;\r\n\r\n  /**\r\n   * Text displayed when dragging an item.\r\n   */\r\n  // eslint-disable-next-line @stencil-community/own-props-must-be-private\r\n  #dragInfo: string;\r\n  #draggedIds: string[] = [];\r\n  #draggedParentIds: string[] = [];\r\n\r\n  @Element() el: HTMLChTreeViewElement;\r\n\r\n  @State() draggingInTheDocument = false;\r\n\r\n  @State() draggingInTree = false;\r\n\r\n  @State() rtlDirection = false;\r\n\r\n  /**\r\n   * Set this attribute if you want to allow multi selection of the items.\r\n   */\r\n  @Prop() readonly multiSelection: boolean = false;\r\n\r\n  /**\r\n   * This property lets you specify the time (in ms) that the mouse must be\r\n   * over in a subtree to open it when dragging.\r\n   */\r\n  @Prop() readonly openSubTreeCountdown: number = 750;\r\n\r\n  /**\r\n   * Callback that is executed to get the current selected items.\r\n   */\r\n  @Prop() readonly selectedItemsCallback: () => Map<\r\n    string,\r\n    TreeViewItemSelectedInfo\r\n  >;\r\n\r\n  /**\r\n   * `true` to scroll in the tree when dragging an item near the edges of the\r\n   * tree.\r\n   */\r\n  @Prop() readonly scrollToEdgeOnDrag: boolean = true;\r\n\r\n  /**\r\n   * This property lets you specify if the tree is waiting to process the drop\r\n   * of items.\r\n   */\r\n  @Prop() readonly waitDropProcessing: boolean = false;\r\n\r\n  /**\r\n   * Fired when an element attempts to enter in a droppable zone where the tree\r\n   * has no information about the validity of the drop.\r\n   */\r\n  @Event() droppableZoneEnter: EventEmitter<TreeViewDropCheckInfo>;\r\n\r\n  /**\r\n   * Fired when an item is expanded or collapsed.\r\n   */\r\n  @Event() expandedItemChange: EventEmitter<TreeViewItemExpandedInfo>;\r\n\r\n  /**\r\n   * Fired when an element displays its contextmenu.\r\n   */\r\n  @Event() itemContextmenu: EventEmitter<TreeViewItemContextMenu>;\r\n\r\n  /**\r\n   * Fired when the dragged items are dropped in another item of the tree.\r\n   */\r\n  @Event() itemsDropped: EventEmitter<TreeViewDataTransferInfo>;\r\n\r\n  /**\r\n   * Fired when the selected items change.\r\n   */\r\n  @Event() selectedItemsChange: EventEmitter<\r\n    Map<string, TreeViewItemSelectedInfo>\r\n  >;\r\n\r\n  @Listen(\"contextmenu\", { capture: true })\r\n  onContextMenu(event: PointerEvent) {\r\n    const treeItem = (event.target as HTMLElement).closest(TREE_ITEM_TAG_NAME);\r\n\r\n    if (!treeItem) {\r\n      return;\r\n    }\r\n    event.preventDefault();\r\n\r\n    this.itemContextmenu.emit({\r\n      id: treeItem.id,\r\n      itemRef: treeItem,\r\n      metadata: treeItem.metadata,\r\n      contextmenuEvent: event\r\n    });\r\n  }\r\n\r\n  // Set edit mode in items\r\n  @Listen(\"keydown\", { capture: true })\r\n  onKeyDown(event: KeyboardEvent) {\r\n    const keyHandler = this.#keyDownEvents[event.key];\r\n\r\n    if (keyHandler) {\r\n      keyHandler(event);\r\n    }\r\n  }\r\n\r\n  // We can't use capture, because the dataTransfer info would not be defined\r\n  // Also, we cant use capture and setTimeout with 0 seconds, because the\r\n  // getData method can only be accessed during the dragstart and drop event\r\n  @Listen(\"dragstart\", { passive: true, target: \"window\" })\r\n  onDragStart(event: DragEvent) {\r\n    // Reset the validity of the droppable zones with each new drag start\r\n    this.#validDroppableZoneCache.clear();\r\n\r\n    // If there is no data, the dragstart does not achieve the interface required\r\n    const data = event.dataTransfer.getData(TEXT_FORMAT);\r\n    if (data === \"\") {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      // Try to parse the data\r\n      const paredData = JSON.parse(data);\r\n\r\n      this.#draggedItems = paredData;\r\n      this.draggingInTheDocument = true;\r\n      this.#dragStartTimestamp = new Date().getTime();\r\n    } catch {\r\n      // Empty\r\n    }\r\n  }\r\n\r\n  @Listen(\"dragend\", { capture: true, passive: true, target: \"window\" })\r\n  onDragEnd() {\r\n    this.draggingInTheDocument = false;\r\n  }\r\n\r\n  @Listen(\"dragenter\", { capture: true, passive: true })\r\n  onDragEnter(event: DragEvent) {\r\n    this.#cancelSubTreeOpening(null, true);\r\n    event.stopPropagation();\r\n\r\n    // The event target can be either a tree item or a tree drop element\r\n    const eventTarget = event.target as\r\n      | HTMLChTreeViewItemElement\r\n      | HTMLChTreeViewDropElement;\r\n    const containerTargetTagName = eventTarget.tagName.toLowerCase();\r\n\r\n    // Check if it is a valid item\r\n    if (!isTreeItemOrTreeDrop(containerTargetTagName)) {\r\n      return;\r\n    }\r\n\r\n    const targetIsTreeItem = containerTargetTagName === TREE_ITEM_TAG_NAME;\r\n    const dragEnterInformation = this.#getDropTypeAndTreeItemTarget(\r\n      eventTarget,\r\n      targetIsTreeItem\r\n    );\r\n    const treeItemTarget = dragEnterInformation.treeItem;\r\n    const dropType = dragEnterInformation.dropType;\r\n\r\n    this.#lastOpenSubTreeItem = eventTarget;\r\n\r\n    // Only the tree view items can open its subtree when hovering\r\n    if (targetIsTreeItem) {\r\n      this.#openSubTreeAfterCountdown(treeItemTarget);\r\n    }\r\n\r\n    if (this.#validDroppableZone(event, treeItemTarget, dropType) === VALID) {\r\n      eventTarget.dragState = \"enter\";\r\n    }\r\n  }\r\n\r\n  @Listen(\"dragleave\", { capture: true, passive: true })\r\n  onDragLeave(event: DragEvent) {\r\n    const currentTarget = event.target as\r\n      | HTMLChTreeViewItemElement\r\n      | HTMLChTreeViewDropElement;\r\n\r\n    if (!isTreeItemOrTreeDrop(currentTarget.tagName.toLowerCase())) {\r\n      return;\r\n    }\r\n\r\n    currentTarget.dragState = \"none\";\r\n\r\n    if (isTreeItem(currentTarget)) {\r\n      this.#cancelSubTreeOpening(currentTarget as HTMLChTreeViewItemElement);\r\n    }\r\n  }\r\n\r\n  #getDropTypeAndTreeItemTarget = (\r\n    eventTarget: HTMLChTreeViewItemElement | HTMLChTreeViewDropElement,\r\n    targetIsTreeItem: boolean\r\n  ): {\r\n    treeItem: HTMLChTreeViewItemElement;\r\n    dropType: TreeViewDropType;\r\n  } => {\r\n    // Only the tree view items can open its subtree when hovering\r\n    if (targetIsTreeItem) {\r\n      return {\r\n        treeItem: eventTarget as HTMLChTreeViewItemElement,\r\n        dropType: \"above\"\r\n      };\r\n    }\r\n\r\n    // The drop is intended to be performed before or after the tree item\r\n    const dropType: TreeViewDropType = (\r\n      eventTarget as HTMLChTreeViewDropElement\r\n    ).type;\r\n\r\n    return {\r\n      // Depending on the position of the tree drop, we get the treeItem ref\r\n      treeItem: (dropType === \"before\"\r\n        ? eventTarget.nextElementSibling\r\n        : eventTarget.previousElementSibling) as HTMLChTreeViewItemElement,\r\n      dropType: (eventTarget as HTMLChTreeViewDropElement).type\r\n    };\r\n  };\r\n\r\n  #cancelSubTreeOpening = (\r\n    treeItemOrTreeDrop: HTMLChTreeViewItemElement | HTMLChTreeViewDropElement,\r\n    forceClear = false\r\n  ) => {\r\n    if (this.#lastOpenSubTreeItem === treeItemOrTreeDrop || forceClear) {\r\n      clearTimeout(this.#openSubTreeTimeout);\r\n      this.#lastOpenSubTreeItem = null;\r\n    }\r\n  };\r\n\r\n  @Listen(\"drop\")\r\n  onDrop(event: DragEvent) {\r\n    event.stopPropagation();\r\n\r\n    this.#cancelSubTreeOpening(null, true);\r\n    const eventTarget = event.target as\r\n      | HTMLChTreeViewItemElement\r\n      | HTMLChTreeViewDropElement;\r\n    const containerTargetTagName = eventTarget.tagName.toLowerCase();\r\n\r\n    // Check if it is a valid item\r\n    if (!isTreeItemOrTreeDrop(containerTargetTagName)) {\r\n      return;\r\n    }\r\n\r\n    // Remove drag enter mode\r\n    eventTarget.dragState = \"none\";\r\n\r\n    const targetIsTreeItem = containerTargetTagName === TREE_ITEM_TAG_NAME;\r\n    const dragEnterInformation = this.#getDropTypeAndTreeItemTarget(\r\n      eventTarget,\r\n      targetIsTreeItem\r\n    );\r\n    const treeItemTarget = dragEnterInformation.treeItem;\r\n    const dropType = dragEnterInformation.dropType;\r\n\r\n    // The droppable zone must be checked, even if it was marked as not valid\r\n    // @todo Try to drop an item with high delays in droppable zone checking\r\n    if (this.#validDroppableZone(event, treeItemTarget, dropType) !== VALID) {\r\n      return;\r\n    }\r\n\r\n    // TODO: Check dataTransfer format before parsing?\r\n    const draggedItems: GxDataTransferInfo[] = JSON.parse(\r\n      event.dataTransfer.getData(TEXT_FORMAT)\r\n    );\r\n\r\n    this.itemsDropped.emit({\r\n      newContainer: {\r\n        id: treeItemTarget.id,\r\n        metadata: treeItemTarget.metadata\r\n      },\r\n      draggingSelectedItems: this.#draggingSelectedItems,\r\n      draggedItems: draggedItems,\r\n      dropInTheSameTree: this.draggingInTree,\r\n      dropType: dropType\r\n    });\r\n  }\r\n\r\n  @Listen(\"itemDragStart\")\r\n  onItemDragStart(event: ChTreeViewItemCustomEvent<TreeViewItemDragStartInfo>) {\r\n    // Avoid bubbling as this event can listened in other components (e.g. ch-flexible-layout)\r\n    event.stopPropagation();\r\n\r\n    document.addEventListener(\"dragover\", this.#trackItemDrag, {\r\n      capture: true\r\n    });\r\n\r\n    this.#currentDraggedItem = event.target;\r\n    const allItemsCanBeDragged = this.#checkDragValidityAndUpdateDragInfo(\r\n      event.detail\r\n    );\r\n\r\n    if (!allItemsCanBeDragged) {\r\n      // This effect disables drop interactions in all page elements, so there\r\n      // is no need to capture and prevent the drop event in the window\r\n      event.detail.dragEvent.dataTransfer.effectAllowed = \"none\";\r\n      return;\r\n    }\r\n\r\n    this.draggingInTree = true;\r\n\r\n    if (this.scrollToEdgeOnDrag) {\r\n      this.#fixScrollPositionOnDrag();\r\n    }\r\n  }\r\n\r\n  @Listen(\"itemDragEnd\")\r\n  onItemDragEnd() {\r\n    this.draggingInTree = false;\r\n\r\n    document.removeEventListener(\"dragover\", this.#trackItemDrag, {\r\n      capture: true\r\n    });\r\n\r\n    // Reset not allowed droppable ids\r\n    this.#resetVariables();\r\n  }\r\n\r\n  @Listen(\"selectedItemChange\")\r\n  onSelectedItemChange(event: ChTreeViewItemCustomEvent<TreeViewItemSelected>) {\r\n    event.stopPropagation();\r\n    const selectedItemInfo = event.detail;\r\n    const selectedItemsInfo = this.selectedItemsCallback();\r\n\r\n    // If the Control key was not pressed or multi selection is disabled,\r\n    // remove all selected items\r\n    if (!selectedItemInfo.ctrlKeyPressed || !this.multiSelection) {\r\n      // Clear selected items\r\n      selectedItemsInfo.clear();\r\n    }\r\n\r\n    // If the item is selected, add it to list\r\n    if (selectedItemInfo.selected) {\r\n      selectedItemsInfo.set(selectedItemInfo.id, selectedItemInfo);\r\n    } else {\r\n      selectedItemsInfo.delete(selectedItemInfo.id);\r\n    }\r\n\r\n    // Sync with UI model\r\n    this.selectedItemsChange.emit(selectedItemsInfo);\r\n  }\r\n\r\n  /**\r\n   * Given an item id, it scrolls into the item's view.\r\n   */\r\n  @Method()\r\n  async scrollIntoVisible(treeItemId: string) {\r\n    readTask(() => {\r\n      const itemRef = this.el.querySelector(ITEM_SELECTOR(treeItemId));\r\n      if (!itemRef) {\r\n        return;\r\n      }\r\n\r\n      writeTask(() => {\r\n        itemRef.scrollIntoView();\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update the information about the valid droppable zones.\r\n   * @param requestTimestamp Time where the request to the server was made. Useful to avoid having old information.\r\n   * @param newContainerId ID of the container where the drag is trying to be made.\r\n   * @param draggedItems Information about the dragged items.\r\n   * @param validDrop Current state of the droppable zone.\r\n   */\r\n  @Method()\r\n  async updateValidDropZone(\r\n    requestTimestamp: number,\r\n    newContainerId: string,\r\n    draggedItems: GxDataTransferInfo[],\r\n    dropType: TreeViewDropType,\r\n    validDrop: boolean\r\n  ) {\r\n    if (\r\n      !this.draggingInTheDocument ||\r\n      requestTimestamp <= this.#dragStartTimestamp\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    const droppableZoneKey = getDroppableZoneKey(\r\n      newContainerId,\r\n      draggedItems,\r\n      dropType\r\n    );\r\n    this.#validDroppableZoneCache.set(\r\n      droppableZoneKey,\r\n      validDrop ? VALID : INVALID\r\n    );\r\n\r\n    // Don't show droppable zones if the dragEnter is invalid or the last\r\n    // dragover was not performed in the same node that this method validates\r\n    if (!validDrop || !this.#lastOpenSubTreeItem) {\r\n      return;\r\n    }\r\n\r\n    const treeItemId = isTreeDrop(this.#lastOpenSubTreeItem)\r\n      ? (this.#lastOpenSubTreeItem as HTMLChTreeViewDropElement).treeItemId\r\n      : this.#lastOpenSubTreeItem.id;\r\n\r\n    const shouldUpdateDragEnterInCurrentContainer =\r\n      treeItemId === newContainerId;\r\n\r\n    if (shouldUpdateDragEnterInCurrentContainer) {\r\n      this.#lastOpenSubTreeItem.dragState = \"enter\";\r\n    }\r\n  }\r\n\r\n  #getTreeViewItemRef = itemId =>\r\n    this.el.querySelector(ITEM_SELECTOR(itemId)) as HTMLChTreeViewItemElement;\r\n\r\n  #validDroppableZone = (\r\n    event: DragEvent,\r\n    treeItemTarget: HTMLChTreeViewItemElement,\r\n    dropType: TreeViewDropType\r\n  ): TreeViewDroppableZoneState => {\r\n    const cacheKey = getDroppableZoneKey(\r\n      treeItemTarget.id,\r\n      this.#draggedItems,\r\n      dropType\r\n    );\r\n    let droppableZoneState = this.#validDroppableZoneCache.get(cacheKey);\r\n\r\n    // Invalidate the cache, because the item is no longer waiting for its\r\n    // content to be downloaded\r\n    if (\r\n      droppableZoneState === TEMPORAL_INVALID &&\r\n      !treeItemTarget.lazyLoad &&\r\n      !treeItemTarget.downloading\r\n    ) {\r\n      droppableZoneState = null;\r\n    }\r\n\r\n    // If there is a cached value, return the cached value\r\n    if (droppableZoneState != null) {\r\n      return droppableZoneState;\r\n    }\r\n\r\n    // Do not show drop zones if:\r\n    //   - The effect does not allow it.\r\n    //   - The drop is disabled in the container target when dragging \"above\".\r\n    //   - When dragging in the same tree, don't mark droppable zones if they are\r\n    //     the dragged items or their direct parents.\r\n    //\r\n    // There is no need to check the following case, because the tree drop is\r\n    // not even rendered:\r\n    //   - When dragging \"before\" and \"after\" an item and the direct parent\r\n    //     has drops disabled.\r\n    if (\r\n      event.dataTransfer.effectAllowed === \"none\" ||\r\n      (dropType === \"above\" && treeItemTarget.dropDisabled) ||\r\n      (this.draggingInTree &&\r\n        (this.#draggedIds.includes(treeItemTarget.id) ||\r\n          this.#draggedParentIds.includes(treeItemTarget.id)))\r\n    ) {\r\n      this.#validDroppableZoneCache.set(cacheKey, INVALID);\r\n      return INVALID;\r\n    }\r\n\r\n    // Disable \"above\" drops when items need to lazy load their content first\r\n    if (\r\n      dropType === \"above\" &&\r\n      (treeItemTarget.lazyLoad || treeItemTarget.downloading)\r\n    ) {\r\n      this.#validDroppableZoneCache.set(cacheKey, TEMPORAL_INVALID);\r\n      return TEMPORAL_INVALID;\r\n    }\r\n\r\n    // Otherwise, emit the event to check the droppable zone\r\n    this.#validDroppableZoneCache.set(cacheKey, CHECKING);\r\n    this.droppableZoneEnter.emit({\r\n      newContainer: {\r\n        id: treeItemTarget.id,\r\n        metadata: treeItemTarget.metadata\r\n      },\r\n      draggedItems: this.#draggedItems,\r\n      dropType: dropType\r\n    });\r\n    return CHECKING;\r\n  };\r\n\r\n  #openSubTreeAfterCountdown = (currentTarget: HTMLChTreeViewItemElement) => {\r\n    if (currentTarget.leaf || currentTarget.expanded) {\r\n      return;\r\n    }\r\n\r\n    this.#openSubTreeTimeout = setTimeout(() => {\r\n      currentTarget.expanded = true;\r\n      this.expandedItemChange.emit({ id: currentTarget.id, expanded: true });\r\n    }, this.openSubTreeCountdown);\r\n  };\r\n\r\n  #trackItemDrag = (event: DragEvent) => {\r\n    const draggingInATree =\r\n      (event.target as HTMLElement).closest(TREE_TAG_NAME) !== null;\r\n\r\n    // The Tree View must be the only element that processes the \"dragover\"\r\n    // event. Any other handler that processes this event can modify the\r\n    // `dropEffect` an thus break the drag and drop implementation\r\n    if (draggingInATree) {\r\n      event.stopImmediatePropagation();\r\n    }\r\n\r\n    event.preventDefault();\r\n    this.#lastDragEvent = event;\r\n\r\n    this.#updateDropEffect(event);\r\n\r\n    if (!this.#needForRAF) {\r\n      return;\r\n    }\r\n    this.#needForRAF = false; // No need to call RAF up until next frame\r\n\r\n    requestAnimationFrame(() => {\r\n      this.#needForRAF = true; // RAF now consumes the movement instruction so a new one can come\r\n\r\n      this.el.style.setProperty(\r\n        POSITION_X_DRAG_CUSTOM_VAR,\r\n        `${this.#lastDragEvent.clientX}px`\r\n      );\r\n      this.el.style.setProperty(\r\n        POSITION_Y_DRAG_CUSTOM_VAR,\r\n        `${this.#lastDragEvent.clientY}px`\r\n      );\r\n    });\r\n  };\r\n\r\n  #updateDropEffect = (event: DragEvent) => {\r\n    // Drag over was performed outside of the Tree View\r\n    if (!event.composedPath().includes(this.el)) {\r\n      return;\r\n    }\r\n\r\n    // We have to used composePath to find if an item is a target in the\r\n    // dragover event\r\n    const itemTarget = event.composedPath().find((element: HTMLElement) => {\r\n      if (!element.tagName) {\r\n        return false;\r\n      }\r\n\r\n      return (\r\n        isTreeItemOrTreeDrop(element.tagName.toLowerCase()) &&\r\n        element.closest(TREE_TAG_NAME) === this.el\r\n      );\r\n    }) as HTMLChTreeViewItemElement | HTMLChTreeViewDropElement;\r\n\r\n    const targetIsTreeItem =\r\n      itemTarget.tagName.toLowerCase() === TREE_ITEM_TAG_NAME;\r\n    const dragEnterInformation = this.#getDropTypeAndTreeItemTarget(\r\n      itemTarget,\r\n      targetIsTreeItem\r\n    );\r\n    const treeItemTarget = dragEnterInformation.treeItem;\r\n    const dropType = dragEnterInformation.dropType;\r\n\r\n    const droppableZoneState = this.#validDroppableZone(\r\n      event,\r\n      treeItemTarget,\r\n      dropType\r\n    );\r\n\r\n    if (\r\n      droppableZoneState === INVALID ||\r\n      droppableZoneState === TEMPORAL_INVALID\r\n    ) {\r\n      event.dataTransfer.dropEffect = \"none\";\r\n    }\r\n  };\r\n\r\n  #resetVariables = () => {\r\n    this.#draggedIds = [];\r\n    this.#draggedParentIds = [];\r\n  };\r\n\r\n  /**\r\n   * First, it check if all items can be dragged. If so, it updates the\r\n   * dataTransfer in the drag event to store the ids and metadata of the\r\n   * dragged items. Also it updates the visual information of the dragged\r\n   * items.\r\n   * @returns If all selected items can be dragged.\r\n   */\r\n  // eslint-disable-next-line @stencil-community/own-props-must-be-private\r\n  #checkDragValidityAndUpdateDragInfo = (\r\n    dragInfo: TreeViewItemDragStartInfo\r\n  ): boolean => {\r\n    const draggedElement = dragInfo.elem;\r\n\r\n    const selectedItemsInfo = this.selectedItemsCallback();\r\n    const isDraggingSelectedItems = selectedItemsInfo.has(draggedElement.id);\r\n    this.#draggingSelectedItems = isDraggingSelectedItems;\r\n\r\n    let dataTransferInfo: GxDataTransferInfo[] = [];\r\n    let dragIsEnabledForAllItems: boolean;\r\n\r\n    if (isDraggingSelectedItems) {\r\n      const selectedItemKeys = [...selectedItemsInfo.keys()];\r\n      const selectedItemValues = [...selectedItemsInfo.values()];\r\n      const selectedItemCount = selectedItemKeys.length;\r\n\r\n      dragIsEnabledForAllItems = selectedItemValues.every(\r\n        el => !this.#getTreeViewItemRef(el.id).dragDisabled\r\n      );\r\n\r\n      this.#draggedIds = selectedItemKeys;\r\n      dataTransferInfo = selectedItemValues.map(el => ({\r\n        id: el.id,\r\n        metadata: el.metadata\r\n      }));\r\n\r\n      this.#dragInfo =\r\n        selectedItemCount === 1\r\n          ? draggedElement.caption\r\n          : selectedItemCount.toString();\r\n    } else {\r\n      dragIsEnabledForAllItems = !draggedElement.dragDisabled;\r\n      dataTransferInfo = [\r\n        { id: draggedElement.id, metadata: draggedElement.metadata }\r\n      ];\r\n      this.#draggedIds = [draggedElement.id];\r\n      this.#dragInfo = draggedElement.caption;\r\n    }\r\n\r\n    this.#getDirectParentsOfDraggableItems(isDraggingSelectedItems);\r\n\r\n    // Update drag event info\r\n    const data = JSON.stringify(dataTransferInfo);\r\n    dragInfo.dragEvent.dataTransfer.setData(TEXT_FORMAT, data);\r\n\r\n    // We must keep the data binding and processing even if there is an item\r\n    // that can't be dragged, otherwise, other trees or element might behave\r\n    // unexpected when a dragstart event comes\r\n    return dragIsEnabledForAllItems;\r\n  };\r\n\r\n  #fixScrollPositionOnDrag = () => {\r\n    if (!this.draggingInTree || !this.#lastDragEvent) {\r\n      return;\r\n    }\r\n\r\n    requestAnimationFrame(() => {\r\n      scrollToEdge(this.#lastDragEvent, this.el, 10, 30);\r\n\r\n      requestAnimationFrame(this.#fixScrollPositionOnDrag);\r\n    });\r\n  };\r\n\r\n  #getDirectParentsOfDraggableItems = (draggingSelectedItems: boolean) => {\r\n    if (!draggingSelectedItems) {\r\n      const parentTreeItemElem = this.#currentDraggedItem.parentElement;\r\n\r\n      if (parentTreeItemElem.tagName.toLowerCase() === TREE_ITEM_TAG_NAME) {\r\n        this.#draggedParentIds.push(parentTreeItemElem.id);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    // Dragging selected items\r\n    const selectedItemsInfo = this.selectedItemsCallback();\r\n    selectedItemsInfo.forEach(selectedItem => {\r\n      const parentId = selectedItem.parentId;\r\n\r\n      // parentId === \"\" when the item is in the first level of the tree\r\n      if (parentId !== \"\") {\r\n        this.#draggedParentIds.push(parentId);\r\n      }\r\n    });\r\n  };\r\n\r\n  connectedCallback() {\r\n    this.#treeViewId = `ch-tree-view-id-${autoId++}`;\r\n\r\n    subscribeToRTLChanges(this.#treeViewId, (rtl: boolean) => {\r\n      this.rtlDirection = rtl;\r\n    });\r\n\r\n    // Initialize rtlDirection value\r\n    this.rtlDirection = isRTL();\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    unsubscribeToRTLChanges(this.#treeViewId);\r\n\r\n    this.#resetVariables();\r\n\r\n    // Remove dragover body event\r\n    this.onItemDragEnd();\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <Host\r\n        class={{\r\n          \"dragging-item\": this.draggingInTheDocument,\r\n          \"not-dragging-item\": !this.draggingInTheDocument, // WA for some bugs in GeneXus' DSO\r\n          \"dragging-selected-items\":\r\n            this.draggingInTree && this.#draggingSelectedItems,\r\n          \"rtl-direction\": this.rtlDirection,\r\n          \"waiting-drop-processing\": this.waitDropProcessing\r\n        }}\r\n        exportparts={TREE_VIEW_PARTS_DICTIONARY.DRAG_PREVIEW}\r\n      >\r\n        <slot />\r\n\r\n        {this.draggingInTree && (\r\n          <span\r\n            aria-hidden=\"true\"\r\n            class=\"drag-info\"\r\n            part={TREE_VIEW_PARTS_DICTIONARY.DRAG_PREVIEW}\r\n          >\r\n            {this.#dragInfo}\r\n          </span>\r\n        )}\r\n      </Host>\r\n    );\r\n  }\r\n}\r\n","import { forceUpdate } from \"@stencil/core\";\r\nimport { removeElement } from \"../../common/array\";\r\nimport {\r\n  TreeViewItemModel,\r\n  TreeViewItemModelExtended,\r\n  TreeViewRemoveItemsResult\r\n} from \"./types\";\r\nimport { TREE_VIEW_ITEM_PARTS_DICTIONARY } from \"../../common/reserved-names\";\r\n\r\nexport const INITIAL_LEVEL = 0;\r\nexport const ROOT_ID: null = null;\r\n\r\n// Parts\r\nexport const getTreeItemLevelPart = (evenLevel: boolean) =>\r\n  evenLevel\r\n    ? TREE_VIEW_ITEM_PARTS_DICTIONARY.EVEN_LEVEL\r\n    : TREE_VIEW_ITEM_PARTS_DICTIONARY.ODD_LEVEL;\r\n\r\nexport const getTreeItemExpandedPart = (expanded: boolean) =>\r\n  expanded\r\n    ? TREE_VIEW_ITEM_PARTS_DICTIONARY.EXPANDED\r\n    : TREE_VIEW_ITEM_PARTS_DICTIONARY.COLLAPSED;\r\n\r\nexport const removeTreeViewItems = (\r\n  items: string[] | undefined,\r\n  flattenedTreeModel: Map<string, TreeViewItemModelExtended>,\r\n  flattenedCheckboxTreeModel: Map<string, TreeViewItemModelExtended>,\r\n  selectedItems: Set<string>\r\n): TreeViewRemoveItemsResult => {\r\n  let atLeastOneElement = false;\r\n  let atLeastOneCheckbox = false;\r\n  let atLeastOneSelected = false;\r\n\r\n  items.forEach(itemId => {\r\n    const itemUIModel = flattenedTreeModel.get(itemId);\r\n\r\n    if (itemUIModel) {\r\n      const itemInfo = itemUIModel.item;\r\n      const parentArray = itemUIModel.parentItem.items;\r\n\r\n      // Remove subitems\r\n      if (itemInfo.leaf !== true && itemInfo.items?.length > 0) {\r\n        const subItemsId = itemInfo.items.map(item => item.id);\r\n\r\n        removeTreeViewItems(\r\n          subItemsId,\r\n          flattenedTreeModel,\r\n          flattenedCheckboxTreeModel,\r\n          selectedItems\r\n        );\r\n      }\r\n\r\n      // Remove item\r\n      atLeastOneElement ||= flattenedTreeModel.delete(itemId);\r\n      atLeastOneCheckbox ||= flattenedCheckboxTreeModel.delete(itemId);\r\n      atLeastOneSelected ||= selectedItems.delete(itemId);\r\n      removeElement(\r\n        parentArray,\r\n        parentArray.findIndex(element => element.id === itemId)\r\n      );\r\n    }\r\n  });\r\n\r\n  return {\r\n    atLeastOneElement: atLeastOneElement,\r\n    atLeastOneCheckbox: atLeastOneCheckbox,\r\n    atLeastOneSelected: atLeastOneSelected\r\n  };\r\n};\r\n\r\nconst resolveNewPromise = <T>(value: T): Promise<T> =>\r\n  new Promise(resolve => resolve(value));\r\n\r\n/**\r\n * Given an item id, it displays and scrolls into the item view.\r\n *\r\n * @returns If the operation was completed successfully.\r\n */\r\nexport const scrollIntoVisibleId = (\r\n  path: string,\r\n  flattenedTreeModel: Map<string, TreeViewItemModelExtended>\r\n): Promise<boolean> => {\r\n  const itemUIModel = flattenedTreeModel.get(path);\r\n\r\n  if (!itemUIModel) {\r\n    return resolveNewPromise(false);\r\n  }\r\n\r\n  let visitedNode = itemUIModel.parentItem as TreeViewItemModel;\r\n\r\n  // While the parent is not the root, update the UI Models\r\n  while (visitedNode && visitedNode.id != null) {\r\n    // Expand the item\r\n    visitedNode.expanded = true;\r\n\r\n    const visitedNodeUIModel = flattenedTreeModel.get(visitedNode.id);\r\n    visitedNode = visitedNodeUIModel.parentItem as TreeViewItemModel;\r\n  }\r\n\r\n  return resolveNewPromise(true);\r\n};\r\n\r\n/**\r\n * Given the path of the item (represent by a sorted array containing all ids\r\n * from the root to the item), it displays and scrolls into the item view.\r\n *\r\n * @returns If the operation was completed successfully.\r\n */\r\nexport const scrollIntoVisiblePath = async (\r\n  elementRef: HTMLChTreeViewRenderElement,\r\n  path: string[],\r\n  flattenedTreeModel: Map<string, TreeViewItemModelExtended>,\r\n  rootNode: TreeViewItemModel,\r\n  lazyLoadTreeItemsCallback: (\r\n    treeItemId: string\r\n  ) => Promise<TreeViewItemModel[]>\r\n): Promise<boolean> => {\r\n  const pathHasRepeatedElements = new Set(path).size !== path.length;\r\n\r\n  if (pathHasRepeatedElements) {\r\n    return false;\r\n  }\r\n\r\n  const indexOfLastItemInPath = path.length - 1;\r\n  let lastRenderedItemInPath = indexOfLastItemInPath;\r\n\r\n  // Start from the last item in the path\r\n  let itemUIModel = flattenedTreeModel.get(path[lastRenderedItemInPath]);\r\n\r\n  // Find the last item that is rendered\r\n  while (itemUIModel === undefined && lastRenderedItemInPath > 0) {\r\n    lastRenderedItemInPath--;\r\n    itemUIModel = flattenedTreeModel.get(path[lastRenderedItemInPath]);\r\n  }\r\n\r\n  if (!itemUIModel) {\r\n    return false;\r\n  }\r\n\r\n  const indexOfLastRenderItem = lastRenderedItemInPath;\r\n\r\n  // At this point, we have the index of the last render item. We must check if\r\n  // the rest of the path up to the root is valid\r\n  while (lastRenderedItemInPath >= 0) {\r\n    if (flattenedTreeModel.get(path[lastRenderedItemInPath]) === undefined) {\r\n      return false;\r\n    }\r\n\r\n    lastRenderedItemInPath--;\r\n  }\r\n\r\n  // Check if the first item in the path is the root, to completely validate\r\n  // the path\r\n  if (flattenedTreeModel.get(path[0]).parentItem !== rootNode) {\r\n    return false;\r\n  }\r\n\r\n  // - - - - - - - - - - - - - - - - - -\r\n  // At this point, we now that the path starts from the root and is valid up to\r\n  // the last rendered item\r\n  // root, node1, node2, ..., indexOfLastRenderItem, unloadedNode1, unloadedNode2, ..., nodeToScrollIntoVisible\r\n  // - - - - - - - - - - - - - - - - - -\r\n  const thereAreMoreItemsToLazyLoad =\r\n    indexOfLastRenderItem !== indexOfLastItemInPath;\r\n  const canNotLazyLoadRemainingPath =\r\n    thereAreMoreItemsToLazyLoad && !lazyLoadTreeItemsCallback;\r\n\r\n  if (canNotLazyLoadRemainingPath) {\r\n    return false;\r\n  }\r\n\r\n  // Expand all parent items\r\n  let parentUIModel = flattenedTreeModel.get(\r\n    path[indexOfLastRenderItem]\r\n  ).parentItem;\r\n\r\n  while (parentUIModel !== rootNode) {\r\n    parentUIModel.expanded = true;\r\n    parentUIModel = flattenedTreeModel.get(parentUIModel.id).parentItem;\r\n  }\r\n\r\n  forceUpdate(elementRef);\r\n\r\n  // Load the remaining path (unloadedNode1, unloadedNode2, ..., nodeToScrollIntoVisible),\r\n  // checking in each step if the next item to lazy load exists\r\n  let nextIndexToLazyLoad = indexOfLastRenderItem;\r\n\r\n  // The reloaded processing will end in the parent of the last item\r\n  while (nextIndexToLazyLoad < indexOfLastItemInPath) {\r\n    const itemId = path[nextIndexToLazyLoad];\r\n\r\n    const itemUIModel = flattenedTreeModel.get(itemId);\r\n\r\n    // Check if the rest of the path up to the last item is valid, if not,\r\n    // cancel the scrollIntoVisible operation\r\n    if (!itemUIModel) {\r\n      return false;\r\n    }\r\n\r\n    const itemInfo = itemUIModel.item;\r\n\r\n    // The remaining path is invalid, because there is an item that isn't a folder\r\n    if (itemInfo.leaf === true) {\r\n      return false;\r\n    }\r\n\r\n    // Expand the parent and set the downloading state\r\n    itemInfo.downloading = true;\r\n    itemInfo.expanded = true;\r\n    itemInfo.lazy = false;\r\n    forceUpdate(elementRef);\r\n\r\n    const result = await lazyLoadTreeItemsCallback(itemId);\r\n    await elementRef.loadLazyContent(itemId, result);\r\n\r\n    nextIndexToLazyLoad++;\r\n  }\r\n\r\n  return true;\r\n};\r\n",":host {\r\n  --ch-tree-view-drop--size: 8px;\r\n  display: grid;\r\n  position: relative;\r\n  transform: translateY(calc(var(--ch-tree-view-drop--size) * -0.5));\r\n}\r\n\r\n:host::before {\r\n  content: \"\";\r\n  display: flex;\r\n  position: absolute;\r\n  inset-inline: 0;\r\n  block-size: var(--ch-tree-view-drop--size);\r\n  // background-color: #9c9c9c6c;\r\n}\r\n\r\n:host::after {\r\n  display: flex;\r\n  position: absolute;\r\n  align-self: center;\r\n  inset-block-start: calc(var(--ch-tree-view-drop--size) * 0.25);\r\n  inset-inline: 0;\r\n  block-size: calc(var(--ch-tree-view-drop--size) * 0.5);\r\n  background-color: currentColor;\r\n  opacity: 0;\r\n}\r\n\r\n:host(.ch-tree-view-drop--drag-enter)::after {\r\n  content: \"\";\r\n  opacity: 1;\r\n}\r\n","import { Component, Host, Prop, h } from \"@stencil/core\";\r\nimport { INITIAL_LEVEL, getTreeItemLevelPart } from \"../../utils\";\r\nimport { DragState } from \"../tree-view-item/tree-view-item\";\r\nimport { TreeViewDropType } from \"../tree-view/types\";\r\n\r\nconst TREE_DROP_TAG_NAME = \"ch-tree-view-drop\";\r\n\r\n@Component({\r\n  tag: \"ch-tree-view-drop\",\r\n  styleUrl: \"tree-view-drop.scss\",\r\n  shadow: true\r\n})\r\nexport class ChTreeViewDrop {\r\n  /**\r\n   * This property lets you define the current state of the item when it's\r\n   * being dragged.\r\n   */\r\n  @Prop() readonly dragState: DragState = \"none\";\r\n\r\n  /**\r\n   * Level in the tree at which the item is placed.\r\n   */\r\n  @Prop() readonly level: number = INITIAL_LEVEL;\r\n\r\n  /**\r\n   * Specifies the id of the tree item that this element controls.\r\n   */\r\n  @Prop() readonly treeItemId: string;\r\n\r\n  /**\r\n   * Specifies the type of drop that is performed over the control.\r\n   */\r\n  @Prop() readonly type: Exclude<TreeViewDropType, \"above\"> = \"before\";\r\n\r\n  render() {\r\n    const canShowLines = this.level !== INITIAL_LEVEL;\r\n    const levelPart = getTreeItemLevelPart(this.level % 2 === 0);\r\n\r\n    return (\r\n      <Host\r\n        class={{\r\n          [\"gx-\" + levelPart]: canShowLines,\r\n          [TREE_DROP_TAG_NAME + \"--drag-enter\"]: this.dragState === \"enter\"\r\n        }}\r\n        style={{ \"--level\": `${this.level}` }}\r\n      ></Host>\r\n    );\r\n  }\r\n}\r\n","@import \"../../../../common/base\";\r\n@import \"../../../../common/icons\";\r\n\r\n@include box-sizing();\r\n\r\n:where(button) {\r\n  all: unset;\r\n  display: flex;\r\n\r\n  // Disallow selecting the text\r\n  user-select: none;\r\n\r\n  // Avoid zooming on double tap on iOS devices\r\n  touch-action: manipulation;\r\n\r\n  // Allow user drag\r\n  -webkit-user-drag: element;\r\n}\r\n\r\n:host {\r\n  display: grid;\r\n  grid-template-rows: min-content;\r\n  // overflow: hidden;\r\n}\r\n\r\n.header {\r\n  display: flex;\r\n  gap: var(--ch-tree-view-item-gap);\r\n  align-items: center;\r\n\r\n  &--disabled {\r\n    pointer-events: none;\r\n\r\n    & > .action {\r\n      --ch-start-img: var(--ch-start-img--disabled, var(--ch-start-img--base));\r\n      --ch-end-img: var(--ch-end-img--disabled, var(--ch-end-img--base));\r\n    }\r\n  }\r\n\r\n  &:hover > .action {\r\n    --ch-start-img: var(--ch-start-img--hover, var(--ch-start-img--base));\r\n    --ch-end-img: var(--ch-end-img--hover, var(--ch-end-img--base));\r\n  }\r\n\r\n  &:active > .action {\r\n    --ch-start-img: var(--ch-start-img--active, var(--ch-start-img--base));\r\n    --ch-end-img: var(--ch-end-img--active, var(--ch-end-img--base));\r\n  }\r\n\r\n  &:focus > .action {\r\n    --ch-start-img: var(\r\n      --ch-start-img--focus,\r\n      var(--ch-start-img--active, var(--ch-start-img--base))\r\n    );\r\n    --ch-end-img: var(\r\n      --ch-end-img--focus,\r\n      var(--ch-end-img--active, var(--ch-end-img--base))\r\n    );\r\n  }\r\n}\r\n\r\n// - - - - - - - - - - - - - - - -\r\n//              Line\r\n// - - - - - - - - - - - - - - - -\r\n.line {\r\n  $parent-padding-inline-start: \"var(--ch-tree-tab-size) * (var(--level) - 1) - var(--parent-offset, 0px) + var(--ch-tree-view-item-custom-padding-inline-start)\";\r\n  $correction: \"var(--ch-tree-view-item__expandable-button-size) * 0.5 + var(--ch-tree-view-item__line--inset-inline-start)\";\r\n\r\n  --inset-inline-start: calc(#{$parent-padding-inline-start} + #{$correction});\r\n\r\n  position: absolute;\r\n  inset-inline-start: var(--inset-inline-start);\r\n  inline-size: calc(\r\n    var(--ch-tree-view-item-indentation) - var(--inset-inline-start) -\r\n      var(--ch-tree-view-item__line--inset-inline-end)\r\n  );\r\n  block-size: 1px;\r\n\r\n  border: 0 dashed color-mix(in srgb, currentColor 65%, transparent);\r\n  border-block-end-width: 1px;\r\n  pointer-events: none; // Improve hover effect\r\n  content-visibility: hidden;\r\n  z-index: 1;\r\n}\r\n\r\n// Last line of the tree\r\n.last-all-line {\r\n  inset-block-start: 0;\r\n  height: calc(100% - var(--ch-tree-view-item-distance-to-checkbox));\r\n  border-inline-start-width: 1px;\r\n  border-end-start-radius: 2px;\r\n}\r\n\r\n.last-line {\r\n  inset-block-start: 0;\r\n  height: 100%;\r\n  border-inline-start-width: 1px;\r\n  border-inline-start-style: solid; // Don't use \"border-style: solid\". Theia uses Chrome 110 where this property is buggy\r\n  border-block-end: unset; // Remove block-end border\r\n}\r\n\r\n// - - - - - - - - - - - - - - - -\r\n//        Expandable button\r\n// - - - - - - - - - - - - - - - -\r\n.expandable-button,\r\n.expandable-button-decorative::before {\r\n  display: grid;\r\n  place-items: center;\r\n  inline-size: var(--ch-tree-view-item__expandable-button-size);\r\n  block-size: var(--ch-tree-view-item__expandable-button-size);\r\n  z-index: 1;\r\n  cursor: pointer;\r\n}\r\n\r\n.expandable-button {\r\n  &-decorative {\r\n    &::before {\r\n      content: \"\";\r\n      background-color: currentColor;\r\n      -webkit-mask: $expandable-icon 50% 50% / calc(100% - 4px) calc(100% - 4px)\r\n        no-repeat;\r\n\r\n      cursor: unset;\r\n    }\r\n\r\n    &--collapsed::before {\r\n      transform: rotate(-90deg); // TODO: Add RTL support\r\n    }\r\n  }\r\n\r\n  &::before {\r\n    content: \"\";\r\n    inline-size: calc(100% - 4px);\r\n    block-size: calc(100% - 4px);\r\n    background-color: currentColor;\r\n    -webkit-mask-size: calc(\r\n      var(--ch-tree-view-item__expandable-button-size) - 4px\r\n    );\r\n  }\r\n\r\n  &--collapsed::before {\r\n    -webkit-mask-image: url('data:image/svg+xml,<svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M14.15,8.5H8.54v5.61h-1V8.5H1.93v-1H7.54V1.89h1V7.5h5.61Z\"/></svg>');\r\n  }\r\n\r\n  &--expanded::before {\r\n    -webkit-mask-image: url('data:image/svg+xml,<svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M14.15,8.5H1.93v-1H14.15Z\"/></svg>');\r\n  }\r\n}\r\n\r\n.checkbox {\r\n  // Necessary to avoid CLS when the ch-checkbox control is downloaded after\r\n  // the tree-view-item did render\r\n  inline-size: var(--ch-tree-view-item__checkbox-size);\r\n  --ch-checkbox__container-size: var(--ch-tree-view-item__checkbox-size);\r\n}\r\n\r\n// - - - - - - - - - - - - - - - -\r\n//             Action\r\n// - - - - - - - - - - - - - - - -\r\n.action {\r\n  --ch-start-img: var(--ch-start-img--base);\r\n  --ch-end-img: var(--ch-end-img--base);\r\n  display: grid;\r\n  grid-template: \"start-img text\" / max-content 1fr;\r\n  gap: var(--ch-tree-view-item-gap);\r\n  align-items: center;\r\n  block-size: 100%;\r\n  flex: 1;\r\n  cursor: pointer;\r\n\r\n  // This distinction is necessary to avoid displaying a separation at the end\r\n  // of the input when editing the caption\r\n  &--end-img {\r\n    grid-template: \"start-img text end-img\" / max-content 1fr max-content;\r\n  }\r\n}\r\n\r\n.edit-caption {\r\n  grid-area: text;\r\n  inline-size: 100%;\r\n  block-size: 100%;\r\n  padding: 0;\r\n  margin: 0;\r\n  background-color: unset;\r\n  border: unset;\r\n  color: unset;\r\n  font: unset;\r\n  outline: unset;\r\n}\r\n\r\n// - - - - - - - - - - - - - - - -\r\n//             Images\r\n// - - - - - - - - - - - - - - - -\r\n.pseudo-img--start::before,\r\n.pseudo-img--end::after,\r\n.img {\r\n  display: block;\r\n  inline-size: var(--ch-tree-view-item__image-size);\r\n  block-size: var(--ch-tree-view-item__image-size);\r\n  content-visibility: auto;\r\n  contain-intrinsic-size: auto var(--ch-tree-view-item__image-size);\r\n}\r\n\r\n.pseudo-img--start::before,\r\n.start-img {\r\n  content: \"\";\r\n  grid-area: start-img;\r\n}\r\n\r\n.pseudo-img--end::after,\r\n.end-img {\r\n  content: \"\";\r\n  grid-area: end-img;\r\n}\r\n\r\n// Background\r\n.start-img-type--background::before {\r\n  background: no-repeat center / var(--ch-tree-view-item__background-image-size)\r\n    var(--ch-start-img);\r\n}\r\n.end-img-type--background::after {\r\n  background: no-repeat center / var(--ch-tree-view-item__background-image-size)\r\n    var(--ch-end-img);\r\n}\r\n\r\n// Mask\r\n.start-img-type--mask::before {\r\n  -webkit-mask: no-repeat center /\r\n    var(--ch-tree-view-item__background-image-size) var(--ch-start-img);\r\n  background-color: currentColor;\r\n}\r\n.end-img-type--mask::after {\r\n  -webkit-mask: no-repeat center /\r\n    var(--ch-tree-view-item__background-image-size) var(--ch-end-img);\r\n  background-color: currentColor;\r\n}\r\n\r\n// - - - - - - - - - - - - - - - -\r\n//           Downloading\r\n// - - - - - - - - - - - - - - - -\r\n.downloading {\r\n  $delay-to-show-downloading: 75ms;\r\n\r\n  inline-size: 0.75em;\r\n  block-size: 0.75em;\r\n  // The \"2px\" separation is necessary to avoid issues with the horizontal scrollbar in Firefox\r\n  margin-inline: 8px 2px;\r\n  border: 2px solid currentColor;\r\n  border-inline-start-color: transparent;\r\n  border-radius: 50%;\r\n  opacity: 0.75;\r\n  animation: spin 1s linear infinite,\r\n    avoid-flickering $delay-to-show-downloading;\r\n}\r\n\r\n@keyframes avoid-flickering {\r\n  0%,\r\n  100% {\r\n    display: none;\r\n  }\r\n}\r\n\r\n@keyframes spin {\r\n  0% {\r\n    transform: rotate(0deg);\r\n  }\r\n\r\n  100% {\r\n    transform: rotate(360deg);\r\n  }\r\n}\r\n\r\n// - - - - - - - - - - - - - - - -\r\n//       Expandable content\r\n// - - - - - - - - - - - - - - - -\r\n.expandable {\r\n  display: grid;\r\n  grid-auto-rows: min-content;\r\n  position: relative;\r\n\r\n  &--lazy-loaded {\r\n    content-visibility: auto;\r\n    contain-intrinsic-size: auto 100px;\r\n  }\r\n}\r\n\r\n.expandable--collapsed {\r\n  display: none;\r\n  overflow: hidden;\r\n}\r\n","import {\r\n  Component,\r\n  Element,\r\n  Event,\r\n  EventEmitter,\r\n  Host,\r\n  Method,\r\n  Prop,\r\n  Watch,\r\n  h,\r\n  writeTask\r\n} from \"@stencil/core\";\r\nimport {\r\n  TreeViewItemDragStartInfo,\r\n  TreeViewLines,\r\n  TreeViewItemCheckedInfo,\r\n  TreeViewItemNewCaption,\r\n  TreeViewItemOpenReferenceInfo,\r\n  TreeViewItemSelected\r\n} from \"../tree-view/types\";\r\nimport {\r\n  TreeViewImagePathCallback,\r\n  TreeViewItemImageMultiState,\r\n  TreeViewItemModel\r\n} from \"../../types\";\r\nimport { mouseEventModifierKey } from \"../../../common/helpers\";\r\nimport {\r\n  ChCheckboxCustomEvent,\r\n  ChTreeViewItemCustomEvent\r\n} from \"../../../../components\";\r\nimport {\r\n  isPseudoElementImg,\r\n  removeDragImage,\r\n  tokenMap,\r\n  updateDirectionInImageCustomVar\r\n} from \"../../../../common/utils\";\r\nimport {\r\n  INITIAL_LEVEL,\r\n  getTreeItemExpandedPart,\r\n  getTreeItemLevelPart\r\n} from \"../../utils\";\r\nimport {\r\n  GxImageMultiState,\r\n  GxImageMultiStateEnd,\r\n  GxImageMultiStateStart,\r\n  ImageRender\r\n} from \"../../../../common/types\";\r\nimport {\r\n  TREE_VIEW_ITEM_CHECKBOX_EXPORT_PARTS,\r\n  TREE_VIEW_ITEM_EXPORT_PARTS,\r\n  TREE_VIEW_ITEM_PARTS_DICTIONARY,\r\n  TREE_VIEW_PARTS_DICTIONARY\r\n} from \"../../../../common/reserved-names\";\r\nimport { getControlRegisterProperty } from \"../../../../common/registry-properties\";\r\n\r\n// Drag and drop\r\nexport type DragState = \"enter\" | \"none\" | \"start\";\r\n\r\nlet GET_IMAGE_PATH_CALLBACK_REGISTRY: TreeViewImagePathCallback | undefined;\r\n\r\nconst DISTANCE_TO_CHECKBOX_CUSTOM_VAR =\r\n  \"--ch-tree-view-item-distance-to-checkbox\";\r\n\r\n// Selectors\r\nconst TREE_ITEM_TAG_NAME = \"ch-tree-view-item\";\r\n\r\nconst DIRECT_TREE_ITEM_CHILDREN = `:scope>${TREE_ITEM_TAG_NAME}`;\r\nconst FIRST_ENABLED_SUB_ITEM = `${TREE_ITEM_TAG_NAME}:not([disabled])`;\r\nconst LAST_SUB_ITEM = `:scope>${TREE_ITEM_TAG_NAME}:last-child`;\r\n\r\n// Custom classes\r\nconst DENY_DROP_CLASS = `item-deny-drop`;\r\n\r\n// Custom parts\r\nconst START_IMAGE_PARTS =\r\n  `${TREE_VIEW_ITEM_PARTS_DICTIONARY.IMAGE} ${TREE_VIEW_ITEM_PARTS_DICTIONARY.START_IMAGE}` as const;\r\nconst END_IMAGE_PARTS =\r\n  `${TREE_VIEW_ITEM_PARTS_DICTIONARY.IMAGE} ${TREE_VIEW_ITEM_PARTS_DICTIONARY.END_IMAGE}` as const;\r\n\r\n// Keys\r\nconst EXPANDABLE_ID = \"expandable\";\r\nconst ENTER_KEY = \"Enter\";\r\nconst ESCAPE_KEY = \"Escape\";\r\n\r\n/**\r\n * @part item__action - A sub element of the header (item__header part) that contains the main information related to the item (startImage, caption/edit-caption, endImage and downloading).\r\n *\r\n * @part item__checkbox - The host element of the checkbox.\r\n * @part item__checkbox-container - The container that serves as a wrapper for the `input` and the `option` parts of the checkbox.\r\n * @part item__checkbox-input - The input element that implements the interactions for the checkbox.\r\n * @part item__checkbox-option - The actual \"input\" that is rendered above the `item__checkbox-input` part of the checkbox. This part has `position: absolute` and `pointer-events: none`.\r\n *\r\n * @part item__downloading - The spinner element that is rendered when the control is lazy loading its content. This element is rendered at the end of the `item__action` part.\r\n *\r\n * @part item__edit-caption - The input element that is rendered when the control is editing its caption. When rendered this element replaces the caption of the `item__action` part.\r\n *\r\n * @part item__expandable-button - The actionable expandable button element that is rendered when the control has subitems and the expandable button is interactive (`leaf !== true` and `expandableButton === \"action\"`). When rendered this element is placed at the start of the `item__action` part.\r\n *\r\n * @part item__group - The container element for the subitems of the control that is rendered when the content has been lazy loaded (`leaf !== true` and `lazyLoad !== true`).\r\n *\r\n * @part item__header - The container for all elements -excepts the subitems (`item__group` part)- of the control. It contains the `item__expandable-button`, `item_checkbox` and `item__action` parts.\r\n *\r\n * @part item__img - The img element that is rendered when the control has images (`startImgSrc` is defined and/or `endImgSrc` is defined).\r\n *\r\n * @part item__line - The element that is rendered to display the relationship between the control and its parent. Rendered if `level !== 0` and `showLines !== \"none\"`.\r\n *\r\n * @part disabled - Present in the `item__header`, `item__expandable-button`, `item__checkbox-input`, `item__checkbox-option` and `item__checkbox-container` parts when the control is disabled (`disabled` === `true`).\r\n *\r\n * @part expanded - Present in the `item__action`, `item__expandable-button` and `item__group` parts when the control is expanded (`expanded` === `true`).\r\n * @part collapsed - Present in the `item__action`, `item__expandable-button` and `item__group` parts when the control is collapsed (`expanded` !== `true`).\r\n *\r\n * @part expand-button - Present in the `item__header` part when the control has an expandable button (`level !== 0`, `leaf !== true` and `expandableButton !== \"no\"`).\r\n *\r\n * @part even-level - Present in the `item__group` and `item__header` parts when the control is in an even level (`level % 2 === 0`).\r\n * @part odd-level - Present in the `item__group` and `item__header` parts when the control is in an odd level (`level % 2 !== 0`).\r\n *\r\n * @part last-line - Present in the `item__line` part if the control is the last control of its parent item in `showLines = \"last\"` mode (`showLines === \"last\"`, `level !== 0` and `lastItem === true`).\r\n *\r\n * @part lazy-loaded - Present in the `item__group` part when the content of the control has been loaded (`leaf !== true`, `lazyLoad !== true` and `downloading !== true`).\r\n *\r\n * @part start-img - Present in the `item__img` part when the control has an start image element (`startImgSrc` is defined and `startImgType` === \"img\").\r\n * @part end-img - Present in the `item__img` part when the control has an end image element (`endImgSrc` is defined and `endImgType` === \"img\").\r\n *\r\n * @part editing - Present in the `item__header` and `item__action` parts when the control is in edit mode (`editable === true` and `editing === true`).\r\n * @part not-editing - Present in the `item__header` and `item__action` parts when the control isn't in edit mode (`editable !== true` or `editing !== true`).\r\n *\r\n * @part selected - Present in the `item__header` part when the control is selected (`selected` === `true`).\r\n * @part not-selected - Present in the `item__header` part when the control isn't selected (`selected` !== `true`).\r\n *\r\n * @part checked - Present in the `item__checkbox-input`, `item__checkbox-option` and `item__checkbox-container` parts when the control is checked and not indeterminate (`checked` === `true` and `indeterminate !== true`).\r\n * @part indeterminate - Present in the `item__checkbox-input`, `item__checkbox-option` and `item__checkbox-container` parts when the control is indeterminate (`indeterminate` === `true`).\r\n * @part unchecked - Present in the `item__checkbox-input`, `item__checkbox-option` and `item__checkbox-container` parts when the control is unchecked and not indeterminate (`checked` !== `true` and `indeterminate !== true`).\r\n *\r\n * @part drag-enter - Present in the `item__header` part when the control has `dragState === \"enter\"`.\r\n */\r\n@Component({\r\n  tag: \"ch-tree-view-item\",\r\n  styleUrl: \"tree-view-item.scss\",\r\n  shadow: true\r\n})\r\nexport class ChTreeViewItem {\r\n  #watcher: ResizeObserver;\r\n\r\n  /**\r\n   * Useful to ignore the checkbox change when it was committed from a children.\r\n   */\r\n  // eslint-disable-next-line @stencil-community/own-props-must-be-private\r\n  #ignoreCheckboxChange = false;\r\n\r\n  #startImage: GxImageMultiStateStart | undefined;\r\n  #startImageExpanded: GxImageMultiStateStart | undefined;\r\n  #endImage: GxImageMultiStateEnd | undefined;\r\n  #endImageExpanded: GxImageMultiStateEnd | undefined;\r\n\r\n  // Refs\r\n  #headerRef: HTMLButtonElement;\r\n  #inputRef: HTMLInputElement;\r\n\r\n  @Element() el: HTMLChTreeViewItemElement;\r\n\r\n  /**\r\n   * This attributes specifies the caption of the control\r\n   */\r\n  @Prop() readonly caption: string;\r\n\r\n  /**\r\n   * Set this attribute if you want display a checkbox in the control.\r\n   */\r\n  @Prop() readonly checkbox: boolean = false;\r\n\r\n  /**\r\n   * Set this attribute if you want the checkbox to be checked by default.\r\n   * Only works if `checkbox = true`\r\n   */\r\n  @Prop({ reflect: true, mutable: true }) checked = false;\r\n  @Watch(\"checked\")\r\n  updateChildrenCheckedValue(newValue: boolean) {\r\n    if (!this.toggleCheckboxes || this.leaf || this.#ignoreCheckboxChange) {\r\n      this.#ignoreCheckboxChange = false;\r\n      return;\r\n    }\r\n\r\n    const treeItems = this.#getDirectTreeItems();\r\n\r\n    treeItems.forEach(treeItem => {\r\n      if (treeItem.checked !== newValue || treeItem.indeterminate !== false) {\r\n        treeItem.updateChecked(newValue, false);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set this attribute if you want to set a custom render for the control, by\r\n   * passing a slot.\r\n   */\r\n  @Prop() readonly customRender: boolean = false;\r\n\r\n  /**\r\n   * This attribute lets you specify if the element is disabled.\r\n   * If disabled, it will not fire any user interaction related event\r\n   * (for example, click event).\r\n   */\r\n  @Prop({ reflect: true }) readonly disabled: boolean = false;\r\n\r\n  /**\r\n   * This attribute lets you specify if the drag operation is disabled in the\r\n   * control. If `true`, the control can't be dragged.\r\n   */\r\n  @Prop() readonly dragDisabled: boolean = false;\r\n\r\n  /**\r\n   * This attribute lets you specify if the drop operation is disabled in the\r\n   * control. If `true`, the control won't accept any drops.\r\n   */\r\n  @Prop() readonly dropDisabled: boolean = false;\r\n\r\n  /**\r\n   * This property lets you define the current state of the item when it's\r\n   * being dragged.\r\n   */\r\n  @Prop({ mutable: true }) dragState: DragState = \"none\";\r\n\r\n  /**\r\n   * This attribute lets you specify when items are being lazy loaded in the\r\n   * control.\r\n   */\r\n  @Prop({ mutable: true }) downloading = false;\r\n\r\n  /**\r\n   * This attribute lets you specify if the edit operation is enabled in the\r\n   * control. If `true`, the control can edit its caption in place.\r\n   */\r\n  @Prop() readonly editable: boolean;\r\n\r\n  /**\r\n   * Set this attribute when the item is in edit mode\r\n   */\r\n  @Prop({ mutable: true }) editing = false;\r\n  @Watch(\"editing\")\r\n  editingChanged(isEditing: boolean) {\r\n    if (!isEditing) {\r\n      return;\r\n    }\r\n\r\n    document.addEventListener(\"click\", this.#removeEditModeOnClick, {\r\n      capture: true\r\n    });\r\n\r\n    // Wait until the input is rendered to focus it\r\n    writeTask(() => {\r\n      requestAnimationFrame(() => {\r\n        if (this.#inputRef) {\r\n          this.#inputRef.focus();\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Specifies the src of the end image.\r\n   */\r\n  @Prop() readonly endImgSrc: string;\r\n  @Watch(\"endImgSrc\")\r\n  endImgSrcChanged(newImage: string) {\r\n    // Necessary to avoid race condition where the image is updated, the Watch\r\n    // is dispatched and then the model is updated\r\n    this.model.endImgSrc = newImage;\r\n    this.#computeImage(\"end\");\r\n  }\r\n\r\n  /**\r\n   * Specifies how the end image will be rendered.\r\n   */\r\n  @Prop() readonly endImgType: ImageRender = \"background\";\r\n\r\n  /**\r\n   * Specifies what kind of expandable button is displayed.\r\n   * Only works if `leaf === false`.\r\n   *  - `\"expandableButton\"`: Expandable button that allows to expand/collapse\r\n   *     the items of the control.\r\n   *  - `\"decorative\"`: Only a decorative icon is rendered to display the state\r\n   *     of the item.\r\n   */\r\n  @Prop() readonly expandableButton: \"action\" | \"decorative\" | \"no\" =\r\n    \"decorative\";\r\n\r\n  /**\r\n   * `true` to expand the control on click interaction. If `false`, with mouse\r\n   * interaction the control will only be expanded on double click.\r\n   */\r\n  @Prop() readonly expandOnClick: boolean = true;\r\n\r\n  /**\r\n   * If the item has a sub-tree, this attribute determines if the subtree is\r\n   * displayed.\r\n   */\r\n  @Prop({ mutable: true }) expanded = false;\r\n  @Watch(\"expanded\")\r\n  expandedChanged(isExpanded: boolean) {\r\n    // Wait until all properties are updated before lazy loading. Otherwise, the\r\n    // lazyLoad property could be updated just after the executing of the function\r\n    setTimeout(() => {\r\n      this.#lazyLoadItems(isExpanded);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * This property specifies a callback that is executed when the path for an\r\n   * item image needs to be resolved.\r\n   */\r\n  @Prop() readonly getImagePathCallback!: TreeViewImagePathCallback;\r\n  @Watch(\"getImagePathCallback\")\r\n  getImagePathCallbackChanged() {\r\n    this.#computeImage(\"start\");\r\n    this.#computeImage(\"end\");\r\n  }\r\n\r\n  /**\r\n   * This attribute specifies if the control is the last items in its subtree\r\n   */\r\n  @Prop() readonly lastItem: boolean = false;\r\n  @Watch(\"lastItem\")\r\n  lastItemChanged(isLastItem: boolean) {\r\n    if (isLastItem && this.showLines) {\r\n      // Use RAF to set the observer after the render method has completed\r\n      requestAnimationFrame(() => {\r\n        this.#setResizeObserver();\r\n      });\r\n    } else {\r\n      this.#disconnectObserver();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Determine if the items are lazy loaded when opening the first time the\r\n   * control.\r\n   */\r\n  @Prop({ mutable: true }) lazyLoad = false;\r\n\r\n  /**\r\n   * The presence of this attribute determine whether the item contains a\r\n   * subtree. `true` if the item does not have a subtree.\r\n   */\r\n  @Prop() readonly leaf: boolean = false;\r\n\r\n  /**\r\n   * Level in the tree at which the item is placed.\r\n   */\r\n  @Prop() readonly level: number = INITIAL_LEVEL;\r\n\r\n  /**\r\n   * `true` if the checkbox's value is indeterminate.\r\n   */\r\n  @Prop({ mutable: true }) indeterminate = false;\r\n\r\n  /**\r\n   * This attribute represents additional info for the control that is included\r\n   * when dragging the item.\r\n   */\r\n  @Prop() readonly metadata: string;\r\n\r\n  /**\r\n   * Specifies the model of the item.\r\n   */\r\n  @Prop() readonly model: TreeViewItemModel;\r\n\r\n  /**\r\n   * Specifies a set of parts to use in every DOM element of the control.\r\n   */\r\n  @Prop() readonly parts?: string;\r\n  @Watch(\"parts\")\r\n  partsChanged(newParts: string) {\r\n    this.#setExportParts(newParts);\r\n  }\r\n\r\n  /**\r\n   * This attribute lets you specify if the item is selected\r\n   */\r\n  @Prop({ mutable: true, reflect: true }) selected = false;\r\n\r\n  /**\r\n   * `true` to show the downloading spinner when lazy loading the sub items of\r\n   * the control.\r\n   */\r\n  @Prop() readonly showDownloadingSpinner: boolean = true;\r\n\r\n  /**\r\n   * `true` to display the relation between tree items and tree lists using\r\n   * lines.\r\n   */\r\n  @Prop() readonly showLines: TreeViewLines = \"none\";\r\n  @Watch(\"showLines\")\r\n  showLinesChanged(newShowLines: TreeViewLines) {\r\n    if (newShowLines && this.lastItem) {\r\n      this.#setResizeObserver();\r\n    } else {\r\n      this.#disconnectObserver();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Specifies the src of the start image.\r\n   */\r\n  @Prop() readonly startImgSrc: string;\r\n  @Watch(\"startImgSrc\")\r\n  startImgSrcChanged(newImage: string) {\r\n    // Necessary to avoid race condition where the image is updated, the Watch\r\n    // is dispatched and then the model is updated\r\n    this.model.startImgSrc = newImage;\r\n    this.#computeImage(\"start\");\r\n  }\r\n\r\n  /**\r\n   * Specifies how the start image will be rendered.\r\n   */\r\n  @Prop() readonly startImgType: ImageRender = \"background\";\r\n\r\n  /**\r\n   * Set this attribute if you want all the children item's checkboxes to be\r\n   * checked when the parent item checkbox is checked, or to be unchecked when\r\n   * the parent item checkbox is unchecked.\r\n   */\r\n  @Prop() readonly toggleCheckboxes: boolean = false;\r\n  @Watch(\"toggleCheckboxes\")\r\n  handleToggleCheckboxesChange(newToggleCheckboxesValue: boolean) {\r\n    if (newToggleCheckboxesValue) {\r\n      this.el.addEventListener(\r\n        \"checkboxChange\",\r\n        this.#handleCheckBoxChangeInItems\r\n      );\r\n    } else {\r\n      this.el.removeEventListener(\r\n        \"checkboxChange\",\r\n        this.#handleCheckBoxChangeInItems\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fired when the checkbox value of the control is changed.\r\n   */\r\n  @Event() checkboxChange: EventEmitter<TreeViewItemCheckedInfo>;\r\n\r\n  /**\r\n   * Fired when the checkbox value of the control is changed. This event only\r\n   * applies when the control has `toggleCheckboxes = true`\r\n   */\r\n  @Event() checkboxToggleChange: EventEmitter<TreeViewItemCheckedInfo>;\r\n\r\n  /**\r\n   * Fired when the item is being dragged.\r\n   */\r\n  @Event() itemDragStart: EventEmitter<TreeViewItemDragStartInfo>;\r\n\r\n  /**\r\n   * Fired when the item is no longer being dragged.\r\n   */\r\n  @Event() itemDragEnd: EventEmitter;\r\n\r\n  /**\r\n   * Fired when the lazy control is expanded an its content must be loaded.\r\n   */\r\n  @Event() loadLazyContent: EventEmitter<string>;\r\n\r\n  /**\r\n   * Fired when the item is asking to modify its caption.\r\n   */\r\n  @Event() modifyCaption: EventEmitter<TreeViewItemNewCaption>;\r\n\r\n  /**\r\n   * Fired when the user interacts with the control in a way that its reference\r\n   * must be opened.\r\n   */\r\n  @Event() openReference: EventEmitter<TreeViewItemOpenReferenceInfo>;\r\n\r\n  /**\r\n   * Fired when the selected state is updated by user interaction on the\r\n   * control.\r\n   */\r\n  @Event() selectedItemChange: EventEmitter<TreeViewItemSelected>;\r\n\r\n  /**\r\n   * Focus the next item in the tree. If the control is expanded, it focuses\r\n   * the first subitem in its tree.\r\n   */\r\n  @Method()\r\n  async focusNextItem(ctrlKeyPressed: boolean) {\r\n    // Focus the first subitem if expanded\r\n    if (!this.leaf && this.expanded) {\r\n      const subItem = this.el.querySelector(\r\n        FIRST_ENABLED_SUB_ITEM\r\n      ) as HTMLChTreeViewItemElement;\r\n\r\n      // The tree item could be empty or downloading subitem, so it is uncertain\r\n      // if the query won't fail\r\n      if (subItem) {\r\n        subItem.setFocus(ctrlKeyPressed);\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Otherwise, focus the next sibling\r\n    this.focusNextSibling(ctrlKeyPressed);\r\n  }\r\n\r\n  /**\r\n   * Focus the next sibling item in the tree.\r\n   */\r\n  @Method()\r\n  async focusNextSibling(ctrlKeyPressed: boolean) {\r\n    const nextSiblingItem = this.el\r\n      .nextElementSibling as HTMLChTreeViewItemElement;\r\n\r\n    // Focus the next sibling, if exists\r\n    if (nextSiblingItem) {\r\n      // If the next sibling is disabled, ask for its next sibling\r\n      if (nextSiblingItem.disabled) {\r\n        nextSiblingItem.focusNextItem(ctrlKeyPressed);\r\n      } else {\r\n        nextSiblingItem.setFocus(ctrlKeyPressed);\r\n      }\r\n      return;\r\n    }\r\n\r\n    // The item is the last one of the tree at the first level\r\n    if (this.level === INITIAL_LEVEL) {\r\n      return;\r\n    }\r\n\r\n    // Otherwise, ask the parent to focus the next sibling\r\n    const parentItem = this.el.parentElement as HTMLChTreeViewItemElement;\r\n    parentItem.focusNextSibling(ctrlKeyPressed);\r\n  }\r\n\r\n  /**\r\n   * Focus the previous item in the tree. If the previous item is expanded, it focuses\r\n   * the last subitem in its tree.\r\n   */\r\n  @Method()\r\n  async focusPreviousItem(ctrlKeyPressed: boolean) {\r\n    const previousSiblingItem = this.el\r\n      .previousElementSibling as HTMLChTreeViewItemElement;\r\n\r\n    // Focus last item of the previous sibling\r\n    if (previousSiblingItem) {\r\n      previousSiblingItem.focusLastItem(ctrlKeyPressed);\r\n      return;\r\n    }\r\n\r\n    // The item is the first one of the tree at the first level\r\n    if (this.level === INITIAL_LEVEL) {\r\n      return;\r\n    }\r\n\r\n    // Otherwise, set focus in the parent element\r\n    const parentItem = this.el.parentElement as HTMLChTreeViewItemElement;\r\n\r\n    // Check if the parent is not disabled\r\n    if (parentItem.disabled) {\r\n      parentItem.focusPreviousItem(ctrlKeyPressed);\r\n      return;\r\n    }\r\n\r\n    parentItem.setFocus(ctrlKeyPressed);\r\n  }\r\n\r\n  /**\r\n   * Focus the last item in its subtree. If the control is not expanded, it\r\n   * focus the control.\r\n   */\r\n  @Method()\r\n  async focusLastItem(ctrlKeyPressed: boolean) {\r\n    // Focus the last subitem if expanded and not lazy loading\r\n    if (!this.leaf && this.expanded) {\r\n      const lastSubItem = this.el.querySelector(\r\n        LAST_SUB_ITEM\r\n      ) as HTMLChTreeViewItemElement;\r\n\r\n      // The tree item could be empty or downloading subitem, so it is uncertain\r\n      // if the query won't fail\r\n      if (lastSubItem) {\r\n        lastSubItem.focusLastItem(ctrlKeyPressed);\r\n        return;\r\n      }\r\n    }\r\n\r\n    // If the last item is disabled, try to focus the previous sibling\r\n    if (this.disabled) {\r\n      this.focusPreviousItem(ctrlKeyPressed);\r\n      return;\r\n    }\r\n\r\n    // Otherwise, it focuses the control\r\n    this.setFocus(ctrlKeyPressed);\r\n  }\r\n\r\n  /**\r\n   * Set focus in the control.\r\n   */\r\n  @Method()\r\n  async setFocus(ctrlKeyPressed: boolean) {\r\n    this.#headerRef.focus();\r\n\r\n    // Normal navigation auto selects the item.\r\n    if (!ctrlKeyPressed) {\r\n      this.#setSelected();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update `checked` and `indeterminate` properties.\r\n   */\r\n  @Method()\r\n  async updateChecked(newChecked: boolean, newIndeterminate: boolean) {\r\n    this.checked = newChecked;\r\n    this.indeterminate = newIndeterminate;\r\n\r\n    // Emit the event to sync with the UI model, even if the item does not\r\n    // have toggleCheckboxes property\r\n    this.checkboxToggleChange.emit({\r\n      id: this.el.id,\r\n      checked: newChecked,\r\n      indeterminate: newIndeterminate\r\n    });\r\n  }\r\n\r\n  #computeImage = (direction: \"start\" | \"end\") => {\r\n    if (\r\n      (direction === \"start\" && !this.startImgSrc) ||\r\n      (direction === \"end\" && !this.endImgSrc)\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    const getImagePathCallback =\r\n      this.getImagePathCallback ?? GET_IMAGE_PATH_CALLBACK_REGISTRY;\r\n\r\n    const img = getImagePathCallback(this.model, direction);\r\n    const imageIsString = typeof img === \"string\";\r\n    const parsedImg: GxImageMultiState = imageIsString\r\n      ? { base: img }\r\n      : img?.default;\r\n\r\n    if (direction === \"start\") {\r\n      if (!img) {\r\n        this.#startImage = null;\r\n        this.#startImageExpanded = null;\r\n        return;\r\n      }\r\n\r\n      // Add url(\"\") wrapper for the image path as it is going to be used in a\r\n      // background or mask\r\n      if (imageIsString && this.startImgType !== \"img\") {\r\n        parsedImg.base = `url(\"${parsedImg.base}\")`;\r\n      }\r\n      // If the image is not a string, then the expanded member could be defined\r\n      else {\r\n        this.#startImageExpanded = this.startImgSrc\r\n          ? (updateDirectionInImageCustomVar(\r\n              (img as TreeViewItemImageMultiState).expanded,\r\n              \"start\",\r\n              this.startImgType\r\n            ) as GxImageMultiStateStart)\r\n          : undefined;\r\n      }\r\n\r\n      this.#startImage = this.startImgSrc\r\n        ? (updateDirectionInImageCustomVar(\r\n            parsedImg,\r\n            \"start\",\r\n            this.startImgType\r\n          ) as GxImageMultiStateStart)\r\n        : undefined;\r\n    }\r\n    // End image\r\n    else {\r\n      if (!img) {\r\n        this.#endImage = null;\r\n        this.#endImageExpanded = null;\r\n        return;\r\n      }\r\n\r\n      // Add url(\"\") wrapper for the image path as it is going to be used in a\r\n      // background or mask\r\n      if (imageIsString && this.endImgType !== \"img\") {\r\n        parsedImg.base = `url(\"${parsedImg.base}\")`;\r\n      }\r\n      // If the image is not a string, then the expanded member could be defined\r\n      else {\r\n        this.#endImageExpanded = this.endImgSrc\r\n          ? (updateDirectionInImageCustomVar(\r\n              (img as TreeViewItemImageMultiState).expanded,\r\n              \"end\",\r\n              this.endImgType\r\n            ) as GxImageMultiStateEnd)\r\n          : undefined;\r\n      }\r\n\r\n      this.#endImage = this.endImgSrc\r\n        ? (updateDirectionInImageCustomVar(\r\n            parsedImg,\r\n            \"end\",\r\n            this.endImgType\r\n          ) as GxImageMultiStateEnd)\r\n        : undefined;\r\n    }\r\n  };\r\n\r\n  #getImageExpandedOrDefault = <\r\n    T extends GxImageMultiStateStart | GxImageMultiStateEnd\r\n  >(\r\n    base: T,\r\n    expanded: T\r\n  ): T => (this.expanded ? expanded ?? base : base);\r\n\r\n  #getDirectTreeItems = (): HTMLChTreeViewItemElement[] =>\r\n    Array.from(\r\n      this.el.querySelectorAll(DIRECT_TREE_ITEM_CHILDREN)\r\n    ) as HTMLChTreeViewItemElement[];\r\n\r\n  #setResizeObserver = () => {\r\n    this.#watcher = new ResizeObserver(() => {\r\n      const distanceToCheckbox =\r\n        this.el.getBoundingClientRect().height -\r\n        this.#headerRef.getBoundingClientRect().height / 2;\r\n\r\n      this.el.style.setProperty(\r\n        DISTANCE_TO_CHECKBOX_CUSTOM_VAR,\r\n        distanceToCheckbox + \"px\"\r\n      );\r\n    });\r\n\r\n    this.#watcher.observe(this.el);\r\n    this.#watcher.observe(this.#headerRef);\r\n  };\r\n\r\n  #disconnectObserver = () => {\r\n    if (!this.#watcher) {\r\n      return;\r\n    }\r\n    this.#watcher.disconnect();\r\n    this.#watcher = null;\r\n  };\r\n\r\n  #checkIfShouldRemoveEditMode = (event: KeyboardEvent) => {\r\n    event.stopPropagation();\r\n\r\n    if (event.code !== ENTER_KEY && event.code !== ESCAPE_KEY) {\r\n      return;\r\n    }\r\n\r\n    event.preventDefault();\r\n    const commitEdition = event.code === ENTER_KEY;\r\n    this.#removeEditMode(true, commitEdition)();\r\n  };\r\n\r\n  #removeEditModeOnClick = (event: PointerEvent) => {\r\n    // The click is executed outside the input and the pointer type is defined,\r\n    // meaning that the button click was not triggered by the Enter or Space keys\r\n    if (!event.composedPath().includes(this.#inputRef) && event.pointerType) {\r\n      this.#removeEditMode(false)();\r\n    }\r\n  };\r\n\r\n  #removeEditMode =\r\n    (shouldFocusHeader: boolean, commitEdition = false) =>\r\n    () => {\r\n      // When pressing the enter key in the input, the removeEditMode event is\r\n      // triggered twice (due to the headerRef.focus() triggering the onBlur\r\n      // event in the input), so we need to check if the edit mode was disabled\r\n      if (!this.editing) {\r\n        return;\r\n      }\r\n      this.editing = false;\r\n\r\n      document.removeEventListener(\"click\", this.#removeEditModeOnClick, {\r\n        capture: true\r\n      });\r\n\r\n      const newCaption = this.#inputRef.value;\r\n\r\n      if (commitEdition && newCaption.trim() !== \"\") {\r\n        this.modifyCaption.emit({\r\n          id: this.el.id,\r\n          caption: newCaption\r\n        });\r\n      }\r\n\r\n      if (shouldFocusHeader) {\r\n        this.#headerRef.focus();\r\n      }\r\n    };\r\n\r\n  #toggleExpand = (event: MouseEvent) => {\r\n    event.stopPropagation();\r\n\r\n    if (!this.leaf) {\r\n      this.expanded = !this.expanded;\r\n    }\r\n\r\n    this.selected = true;\r\n    this.selectedItemChange.emit(\r\n      this.#getSelectedInfo(mouseEventModifierKey(event), true)\r\n    );\r\n  };\r\n\r\n  #lazyLoadItems = (expanded: boolean) => {\r\n    if (!this.lazyLoad || !expanded) {\r\n      return;\r\n    }\r\n\r\n    // Load items\r\n    this.lazyLoad = false;\r\n    this.downloading = true;\r\n\r\n    this.loadLazyContent.emit(this.el.id);\r\n  };\r\n\r\n  #toggleSelected = () => {\r\n    const selected = !this.selected;\r\n    this.selected = selected;\r\n\r\n    this.selectedItemChange.emit(this.#getSelectedInfo(true, selected));\r\n  };\r\n\r\n  #setSelected = () => {\r\n    this.selected = true;\r\n    this.selectedItemChange.emit(this.#getSelectedInfo(false, true));\r\n  };\r\n\r\n  #toggleOrSelect = (event: MouseEvent) => {\r\n    // Ctrl key\r\n    if (mouseEventModifierKey(event)) {\r\n      this.#toggleSelected();\r\n      return;\r\n    }\r\n\r\n    // Double click was triggered, don't update the selection or expand\r\n    if (event.detail >= 2) {\r\n      return;\r\n    }\r\n\r\n    // Expand on click interaction\r\n    if (this.expandOnClick) {\r\n      this.#toggleExpand(event);\r\n    }\r\n    // Click only selects the item\r\n    else {\r\n      this.#setSelected();\r\n    }\r\n  };\r\n\r\n  #getSelectedInfo = (\r\n    ctrlKeyPressed: boolean,\r\n    selected: boolean\r\n  ): TreeViewItemSelected => ({\r\n    ctrlKeyPressed: ctrlKeyPressed,\r\n    expanded: this.expanded,\r\n    id: this.el.id,\r\n    metadata: this.metadata,\r\n    parentId: this.el.parentElement?.id, // TODO: Improve this\r\n    selected: selected\r\n  });\r\n\r\n  #handleActionDblClick = (event: PointerEvent) => {\r\n    event.stopPropagation();\r\n\r\n    if (mouseEventModifierKey(event)) {\r\n      this.#toggleSelected();\r\n      return;\r\n    }\r\n\r\n    this.#emitOpenReference();\r\n\r\n    // The Control key is not pressed, so the control can be expanded if double\r\n    // click expands the item\r\n    if (!this.leaf && !this.expandOnClick) {\r\n      this.#toggleExpand(event);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Event triggered by the following actions on the main button:\r\n   *   - Click\r\n   *   - Enter keydown\r\n   *   - Space keydown and keyup\r\n   */\r\n  // eslint-disable-next-line @stencil-community/own-props-must-be-private\r\n  #handleActionClick = (event: PointerEvent) => {\r\n    event.stopPropagation();\r\n\r\n    // Don't perform actions when editing\r\n    if (this.editing) {\r\n      return;\r\n    }\r\n\r\n    event.preventDefault();\r\n\r\n    // Click event\r\n    if (event.pointerType) {\r\n      this.#toggleOrSelect(event);\r\n      return;\r\n    }\r\n\r\n    // The action was provoked by the keyboard, emit openReference event\r\n    this.#emitOpenReference();\r\n\r\n    // Enter or space\r\n    this.#toggleExpand(event);\r\n  };\r\n\r\n  /**\r\n   * Event triggered by key events on the main button.\r\n   */\r\n  // eslint-disable-next-line @stencil-community/own-props-must-be-private\r\n  #handleActionKeyDown = (event: KeyboardEvent) => {\r\n    // Only toggle if the Enter key was pressed with the Ctrl key\r\n    if (mouseEventModifierKey(event) && event.code === ENTER_KEY) {\r\n      event.stopPropagation();\r\n      this.#toggleSelected();\r\n    }\r\n  };\r\n\r\n  #emitOpenReference = () => {\r\n    this.openReference.emit({\r\n      id: this.el.id,\r\n      leaf: this.leaf,\r\n      metadata: this.metadata\r\n    });\r\n  };\r\n\r\n  #handleCheckedChange = (event: ChCheckboxCustomEvent<any> & InputEvent) => {\r\n    event.stopPropagation();\r\n    const chCheckboxRef = event.target;\r\n\r\n    const checked = chCheckboxRef.checkedValue === chCheckboxRef.value;\r\n    this.checked = checked;\r\n    this.indeterminate = false; // Changing the checked value makes it no longer indeterminate\r\n\r\n    this.checkboxChange.emit({\r\n      id: this.el.id,\r\n      checked: this.checked,\r\n      indeterminate: false\r\n    });\r\n  };\r\n\r\n  #handleCheckBoxChangeInItems = (\r\n    event: ChTreeViewItemCustomEvent<TreeViewItemCheckedInfo>\r\n  ) => {\r\n    // No need to update the checkbox value based on the children checkbox\r\n    if (this.el === event.target) {\r\n      return;\r\n    }\r\n\r\n    const updatedCheck = event.detail.checked;\r\n    const treeItems = this.#getDirectTreeItems();\r\n\r\n    // Check if all the items have the same value as the updated item\r\n    const allItemsHaveTheSameCheckedValue = treeItems.every(\r\n      treeItem => treeItem.checked === updatedCheck\r\n    );\r\n\r\n    const eventMustBeEmitted =\r\n      this.checked !== updatedCheck ||\r\n      this.indeterminate !== !allItemsHaveTheSameCheckedValue;\r\n\r\n    this.#ignoreCheckboxChange = this.checked !== updatedCheck;\r\n    this.checked = updatedCheck;\r\n    this.indeterminate = !allItemsHaveTheSameCheckedValue;\r\n\r\n    // Sync with the UI Model\r\n    if (eventMustBeEmitted) {\r\n      this.checkboxToggleChange.emit({\r\n        id: this.el.id,\r\n        checked: updatedCheck,\r\n        indeterminate: !allItemsHaveTheSameCheckedValue\r\n      });\r\n    }\r\n  };\r\n\r\n  #renderImg = (cssClass: string, src: string, imageType: ImageRender) =>\r\n    imageType === \"img\" && (\r\n      <img\r\n        aria-hidden=\"true\"\r\n        class={`img ${cssClass}`}\r\n        part={cssClass}\r\n        alt=\"\"\r\n        src={src}\r\n        loading=\"lazy\"\r\n      />\r\n    );\r\n\r\n  #handleDragStart = (event: DragEvent) => {\r\n    // Disallow drag when editing the caption\r\n    if (this.editing) {\r\n      event.preventDefault();\r\n      event.stopPropagation();\r\n      return;\r\n    }\r\n\r\n    removeDragImage(event);\r\n    event.dataTransfer.effectAllowed = \"move\";\r\n\r\n    this.dragState = \"start\";\r\n    this.itemDragStart.emit({\r\n      elem: this.el,\r\n      dragEvent: event\r\n    });\r\n  };\r\n\r\n  #handleDragEnd = () => {\r\n    // event.preventDefault();\r\n\r\n    // this.el.style.cursor = null;\r\n    this.dragState = \"none\";\r\n    this.itemDragEnd.emit();\r\n  };\r\n\r\n  #setExportParts = (exportparts: string | undefined) => {\r\n    if (exportparts) {\r\n      this.el.setAttribute(\r\n        \"exportparts\",\r\n        // Replace sequential empty characters with a comma\r\n        // TODO: Use replaceAll?\r\n        `${TREE_VIEW_ITEM_EXPORT_PARTS},${exportparts.replace(/\\s+/g, \",\")}`\r\n      );\r\n    } else {\r\n      this.el.setAttribute(\"exportparts\", TREE_VIEW_ITEM_EXPORT_PARTS);\r\n    }\r\n  };\r\n\r\n  connectedCallback() {\r\n    // Initialize default getImagePathCallback\r\n    GET_IMAGE_PATH_CALLBACK_REGISTRY ??= getControlRegisterProperty(\r\n      \"getImagePathCallback\",\r\n      \"ch-tree-view-render\"\r\n    );\r\n\r\n    if (this.toggleCheckboxes) {\r\n      this.el.addEventListener(\r\n        \"checkboxChange\",\r\n        this.#handleCheckBoxChangeInItems\r\n      );\r\n    }\r\n\r\n    this.#computeImage(\"start\");\r\n    this.#computeImage(\"end\");\r\n\r\n    // Static attributes that we including in the Host functional component to\r\n    // eliminate additional overhead\r\n    this.el.setAttribute(\"role\", \"treeitem\");\r\n    this.el.setAttribute(\"aria-level\", `${this.level + 1}`);\r\n    this.el.style.setProperty(\"--level\", `${this.level}`);\r\n    this.#setExportParts(this.parts);\r\n  }\r\n\r\n  componentWillLoad() {\r\n    // Check if must lazy load\r\n    this.#lazyLoadItems(this.expanded);\r\n  }\r\n\r\n  componentDidLoad() {\r\n    if (this.lastItem && this.showLines) {\r\n      this.#setResizeObserver();\r\n    }\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    // If it was disconnected on edit mode, remove the body event handler\r\n    if (this.editing) {\r\n      this.#removeEditMode(false);\r\n    }\r\n\r\n    this.#disconnectObserver();\r\n\r\n    this.el.removeEventListener(\r\n      \"checkboxChange\",\r\n      this.#handleCheckBoxChangeInItems\r\n    );\r\n  }\r\n\r\n  render() {\r\n    const evenLevel = this.level % 2 === 0;\r\n\r\n    const hasContent = !this.leaf && !this.lazyLoad;\r\n\r\n    const canShowLines = this.level !== INITIAL_LEVEL;\r\n    const showAllLines = this.showLines === \"all\" && canShowLines;\r\n    const showLastLine =\r\n      this.showLines === \"last\" && canShowLines && this.lastItem;\r\n\r\n    const levelPart = getTreeItemLevelPart(evenLevel);\r\n    const expandedPart = getTreeItemExpandedPart(this.expanded);\r\n\r\n    const pseudoStartImage = isPseudoElementImg(\r\n      this.startImgSrc,\r\n      this.startImgType\r\n    );\r\n    const pseudoEndImage = isPseudoElementImg(this.endImgSrc, this.endImgType);\r\n\r\n    const hasParts = !!this.parts;\r\n\r\n    return (\r\n      <Host\r\n        aria-selected={this.selected ? \"true\" : null}\r\n        class={this.leaf ? DENY_DROP_CLASS : null}\r\n        part={tokenMap({\r\n          [TREE_VIEW_PARTS_DICTIONARY.ITEM]: true,\r\n          [TREE_VIEW_PARTS_DICTIONARY.DRAG_ENTER]: this.dragState === \"enter\",\r\n          [this.parts]: hasParts\r\n        })}\r\n      >\r\n        <button\r\n          aria-controls={hasContent ? EXPANDABLE_ID : null}\r\n          aria-expanded={hasContent ? this.expanded.toString() : null}\r\n          class={{\r\n            header: true,\r\n            \"header--selected\": this.selected,\r\n            \"header--disabled\": this.disabled,\r\n\r\n            \"expandable-button-decorative\":\r\n              !this.leaf && this.expandableButton === \"decorative\",\r\n            \"expandable-button-decorative--collapsed\":\r\n              !this.leaf &&\r\n              this.expandableButton === \"decorative\" &&\r\n              !this.expanded\r\n          }}\r\n          part={tokenMap({\r\n            [TREE_VIEW_ITEM_PARTS_DICTIONARY.HEADER]: true,\r\n            [TREE_VIEW_ITEM_PARTS_DICTIONARY.DISABLED]: this.disabled,\r\n            [TREE_VIEW_ITEM_PARTS_DICTIONARY.DRAG_ENTER]:\r\n              this.dragState === \"enter\",\r\n            [TREE_VIEW_ITEM_PARTS_DICTIONARY.SELECTED]: this.selected,\r\n            [TREE_VIEW_ITEM_PARTS_DICTIONARY.NOT_SELECTED]: !this.selected,\r\n            [TREE_VIEW_ITEM_PARTS_DICTIONARY.EXPAND_BUTTON]:\r\n              canShowLines && !this.leaf && this.expandableButton !== \"no\",\r\n            [this.editing\r\n              ? TREE_VIEW_ITEM_PARTS_DICTIONARY.EDITING\r\n              : TREE_VIEW_ITEM_PARTS_DICTIONARY.NOT_EDITING]: true,\r\n            [levelPart]: canShowLines,\r\n\r\n            // TODO: Add unit test\r\n            // Undocumented. Only used for implementation purposes\r\n            [TREE_VIEW_ITEM_PARTS_DICTIONARY.LEVEL_0_LEAF]:\r\n              !canShowLines && this.leaf && this.expandableButton !== \"no\",\r\n            [this.parts]: hasParts\r\n          })}\r\n          style={\r\n            pseudoStartImage && (this.#startImage || this.#startImageExpanded)\r\n              ? this.#getImageExpandedOrDefault(\r\n                  this.#startImage,\r\n                  this.#startImageExpanded\r\n                ).styles\r\n              : undefined\r\n          }\r\n          type=\"button\"\r\n          disabled={this.disabled}\r\n          onClick={this.#handleActionClick}\r\n          onKeyDown={!this.editing ? this.#handleActionKeyDown : null}\r\n          // Drag and drop\r\n          draggable={!this.dragDisabled}\r\n          onDragStart={this.#handleDragStart}\r\n          onDragEnd={\r\n            !this.dragDisabled && this.dragState === \"start\"\r\n              ? this.#handleDragEnd\r\n              : null\r\n          }\r\n          ref={el => (this.#headerRef = el)}\r\n        >\r\n          {!this.leaf && this.expandableButton === \"action\" && (\r\n            <button\r\n              key=\"expandable-button\"\r\n              type=\"button\"\r\n              class={{\r\n                \"expandable-button\": true,\r\n                \"expandable-button--expanded\": this.expanded,\r\n                \"expandable-button--collapsed\": !this.expanded\r\n              }}\r\n              part={tokenMap({\r\n                [TREE_VIEW_ITEM_PARTS_DICTIONARY.EXPANDABLE_BUTTON]: true,\r\n                [TREE_VIEW_ITEM_PARTS_DICTIONARY.DISABLED]: this.disabled,\r\n                [expandedPart]: true,\r\n                [this.parts]: hasParts\r\n              })}\r\n              disabled={this.disabled}\r\n              onClick={this.#toggleExpand}\r\n            ></button>\r\n          )}\r\n\r\n          {this.checkbox && (\r\n            <ch-checkbox\r\n              key=\"checkbox\"\r\n              accessibleName={this.caption}\r\n              class=\"checkbox\"\r\n              exportparts={TREE_VIEW_ITEM_CHECKBOX_EXPORT_PARTS}\r\n              part={\r\n                hasParts\r\n                  ? `${TREE_VIEW_ITEM_PARTS_DICTIONARY.CHECKBOX} ${this.parts}`\r\n                  : TREE_VIEW_ITEM_PARTS_DICTIONARY.CHECKBOX\r\n              }\r\n              checkedValue=\"true\"\r\n              disabled={this.disabled}\r\n              indeterminate={this.indeterminate}\r\n              unCheckedValue=\"false\"\r\n              value={`${this.checked}`}\r\n              onInput={this.#handleCheckedChange}\r\n            ></ch-checkbox>\r\n          )}\r\n\r\n          {this.customRender ? (\r\n            <slot name=\"custom-content\" />\r\n          ) : (\r\n            [\r\n              <div\r\n                class={{\r\n                  action: true,\r\n                  \"action--end-img\": !!this.endImgSrc,\r\n\r\n                  [`start-img-type--${this.startImgType} pseudo-img--start`]:\r\n                    pseudoStartImage,\r\n                  [`end-img-type--${this.endImgType} pseudo-img--end`]:\r\n                    pseudoEndImage\r\n                }}\r\n                part={tokenMap({\r\n                  [TREE_VIEW_ITEM_PARTS_DICTIONARY.ACTION]: true,\r\n                  [this.editing\r\n                    ? TREE_VIEW_ITEM_PARTS_DICTIONARY.EDITING\r\n                    : TREE_VIEW_ITEM_PARTS_DICTIONARY.NOT_EDITING]: true,\r\n                  [expandedPart]: !this.leaf,\r\n                  [this.parts]: hasParts\r\n                })}\r\n                style={\r\n                  pseudoEndImage && (this.#endImage || this.#endImageExpanded)\r\n                    ? this.#getImageExpandedOrDefault(\r\n                        this.#endImage,\r\n                        this.#endImageExpanded\r\n                      ).styles\r\n                    : undefined\r\n                }\r\n                onDblClick={!this.editing ? this.#handleActionDblClick : null}\r\n              >\r\n                {this.startImgSrc &&\r\n                  this.#startImage &&\r\n                  this.#renderImg(\r\n                    hasParts\r\n                      ? `${START_IMAGE_PARTS} ${this.parts}`\r\n                      : START_IMAGE_PARTS,\r\n                    this.#startImage.styles[\"--ch-start-img--base\"],\r\n                    this.startImgType\r\n                  )}\r\n\r\n                {this.editable && this.editing ? (\r\n                  <input\r\n                    key=\"edit-caption\"\r\n                    class=\"edit-caption\"\r\n                    part={\r\n                      hasParts\r\n                        ? `${TREE_VIEW_ITEM_PARTS_DICTIONARY.EDIT_CAPTION} ${this.parts}`\r\n                        : TREE_VIEW_ITEM_PARTS_DICTIONARY.EDIT_CAPTION\r\n                    }\r\n                    disabled={this.disabled}\r\n                    type=\"text\"\r\n                    value={this.caption}\r\n                    onBlur={this.#removeEditMode(false)}\r\n                    onKeyDown={this.#checkIfShouldRemoveEditMode}\r\n                    ref={el => (this.#inputRef = el)}\r\n                  />\r\n                ) : (\r\n                  this.caption\r\n                )}\r\n\r\n                {this.endImgSrc &&\r\n                  this.#endImage &&\r\n                  this.#renderImg(\r\n                    hasParts\r\n                      ? `${END_IMAGE_PARTS} ${this.parts}`\r\n                      : END_IMAGE_PARTS,\r\n                    this.#endImage.styles[\"--ch-end-img--base\"],\r\n                    this.endImgType\r\n                  )}\r\n              </div>,\r\n\r\n              this.showDownloadingSpinner && !this.leaf && this.downloading && (\r\n                <div\r\n                  class=\"downloading\"\r\n                  part={\r\n                    hasParts\r\n                      ? `${TREE_VIEW_ITEM_PARTS_DICTIONARY.DOWNLOADING} ${this.parts}`\r\n                      : TREE_VIEW_ITEM_PARTS_DICTIONARY.DOWNLOADING\r\n                  }\r\n                ></div>\r\n              )\r\n            ]\r\n          )}\r\n\r\n          {(showAllLines || showLastLine) && (\r\n            <div\r\n              key=\"line\"\r\n              class={{\r\n                line: true,\r\n                \"last-all-line\": showAllLines && this.lastItem,\r\n                \"last-line\": showLastLine\r\n              }}\r\n              part={tokenMap({\r\n                [TREE_VIEW_ITEM_PARTS_DICTIONARY.LINE]: true,\r\n                [TREE_VIEW_ITEM_PARTS_DICTIONARY.LAST_LINE]: this.lastItem,\r\n                [this.parts]: hasParts\r\n              })}\r\n            ></div>\r\n          )}\r\n        </button>\r\n\r\n        {hasContent && (\r\n          <div\r\n            role=\"group\"\r\n            aria-busy={(!!this.downloading).toString()}\r\n            aria-live={this.downloading ? \"polite\" : null}\r\n            id={EXPANDABLE_ID}\r\n            class={{\r\n              expandable: true,\r\n              \"expandable--collapsed\": !this.expanded,\r\n              \"expandable--lazy-loaded\": !this.downloading,\r\n\r\n              \"expandable--even\": canShowLines && evenLevel,\r\n              \"expandable--odd\": canShowLines && !evenLevel\r\n            }}\r\n            part={tokenMap({\r\n              [TREE_VIEW_ITEM_PARTS_DICTIONARY.GROUP]: true,\r\n              [TREE_VIEW_ITEM_PARTS_DICTIONARY.LAZY_LOADED]: !this.downloading,\r\n              [expandedPart]: true,\r\n              [levelPart]: canShowLines,\r\n              [this.parts]: hasParts\r\n            })}\r\n          >\r\n            <slot />\r\n          </div>\r\n        )}\r\n      </Host>\r\n    );\r\n  }\r\n}\r\n","import {\r\n  TreeViewFilterInfo,\r\n  TreeViewFilterOptions,\r\n  TreeViewFilterType,\r\n  TreeViewItemModel\r\n} from \"./types\";\r\n\r\nexport const itemHasCheckbox = (\r\n  item: TreeViewItemModel,\r\n  defaultCheckbox: boolean\r\n) => item.checkbox ?? defaultCheckbox;\r\n\r\nconst filterWithCase = (\r\n  stringToFilter: string,\r\n  filter: string,\r\n  matchCase?: boolean\r\n) =>\r\n  matchCase\r\n    ? stringToFilter.includes(filter)\r\n    : stringToFilter.toLowerCase().includes(filter.toLowerCase());\r\n\r\nconst filterWithString = (\r\n  stringToFilter: string,\r\n  filter: string | RegExp,\r\n  filterOptions: TreeViewFilterOptions\r\n) =>\r\n  typeof filter === \"object\"\r\n    ? stringToFilter.match(filter) !== null\r\n    : filterWithCase(stringToFilter, filter, filterOptions?.matchCase);\r\n\r\nconst filterDictionary: {\r\n  [key in TreeViewFilterType]: (\r\n    item: TreeViewItemModel,\r\n    filterInfo: TreeViewFilterInfo\r\n  ) => boolean;\r\n} = {\r\n  caption: (item, filterInfo) =>\r\n    filterInfo.filter\r\n      ? filterWithString(\r\n          item.caption ?? \"\",\r\n          filterInfo.filter,\r\n          filterInfo.filterOptions\r\n        )\r\n      : true,\r\n\r\n  checked: (item, filterInfo) =>\r\n    itemHasCheckbox(item, filterInfo.defaultCheckbox) &&\r\n    !item.indeterminate &&\r\n    (item.checked ?? filterInfo.defaultChecked),\r\n\r\n  list: (item, filterInfo) => filterInfo.filterSet.has(item.id),\r\n\r\n  metadata: (item, filterInfo) =>\r\n    filterInfo.filter\r\n      ? filterWithString(\r\n          item.metadata ?? \"\",\r\n          filterInfo.filter,\r\n          filterInfo.filterOptions\r\n        )\r\n      : true,\r\n\r\n  none: () => true,\r\n\r\n  unchecked: (item, filterInfo) =>\r\n    itemHasCheckbox(item, filterInfo.defaultCheckbox) &&\r\n    !item.indeterminate &&\r\n    !(item.checked ?? filterInfo.defaultChecked)\r\n};\r\n\r\nexport const computeFilter = (\r\n  filterType: TreeViewFilterType,\r\n  item: TreeViewItemModel,\r\n  filterInfo: TreeViewFilterInfo\r\n): boolean =>\r\n  filterInfo.filterOptions?.hideMatchesAndShowNonMatches === true\r\n    ? !filterDictionary[filterType](item, filterInfo)\r\n    : filterDictionary[filterType](item, filterInfo);\r\n\r\nexport type TreeViewItemSimplifiedModel = {\r\n  id: string;\r\n  items: TreeViewItemSimplifiedModel[];\r\n};\r\n\r\nexport function simplifyModel(\r\n  model: TreeViewItemModel\r\n): TreeViewItemSimplifiedModel[] {\r\n  const items = model.items;\r\n\r\n  if (!items) {\r\n    return [];\r\n  }\r\n\r\n  const simplifiedModel: TreeViewItemSimplifiedModel[] = items.map(item => ({\r\n    id: item.id,\r\n    items: simplifyModel(item)\r\n  }));\r\n\r\n  return simplifiedModel;\r\n}\r\n\r\nexport const prettyPrint = (value: any) => JSON.stringify(value, undefined, 2);\r\n","import {\r\n  LazyLoadTreeItemsCallback,\r\n  TreeViewItemModel,\r\n  TreeViewItemModelExtended\r\n} from \"./types\";\r\n\r\nexport const reloadItems = async (\r\n  elementRef: HTMLChTreeViewRenderElement,\r\n  itemId: string,\r\n  flattenedTreeModel: Map<string, TreeViewItemModelExtended>,\r\n  lazyLoadTreeItemsCallback: LazyLoadTreeItemsCallback,\r\n  loadLazyContent: (\r\n    itemId: string,\r\n    items?: TreeViewItemModel[]\r\n  ) => Promise<void>,\r\n  removeItems: (items: string[]) => void,\r\n  beforeProperties?: Partial<TreeViewItemModel>,\r\n  afterProperties?: Partial<TreeViewItemModel>\r\n): Promise<boolean> => {\r\n  const itemToReloadUIModel = flattenedTreeModel.get(itemId);\r\n\r\n  if (\r\n    !lazyLoadTreeItemsCallback ||\r\n    !itemToReloadUIModel ||\r\n    itemToReloadUIModel.item.leaf === true\r\n  ) {\r\n    return false;\r\n  }\r\n\r\n  const noProperties = !beforeProperties && !afterProperties;\r\n  if (noProperties) {\r\n    beforeProperties = { downloading: true };\r\n    afterProperties = { downloading: false };\r\n  }\r\n\r\n  if (beforeProperties) {\r\n    elementRef.updateItemsProperties([itemId], beforeProperties);\r\n  }\r\n\r\n  const newItems = await lazyLoadTreeItemsCallback(itemId);\r\n\r\n  // Store previous ids in a Set for efficient access\r\n  const oldItemsSet = new Set(\r\n    itemToReloadUIModel.item.items.map(item => item.id)\r\n  );\r\n\r\n  const reloadNewItemsQueue: string[] = [];\r\n\r\n  // Reconcile the state of old items to new ones\r\n  newItems.forEach(newItem => {\r\n    const newItemOldUIModel = flattenedTreeModel.get(newItem.id);\r\n\r\n    // If the item previously existed in the client\r\n    if (newItemOldUIModel && oldItemsSet.has(newItem.id)) {\r\n      const newItemOldInfo = newItemOldUIModel.item;\r\n\r\n      // Reconciliate the state\r\n      newItem.checked = newItemOldInfo.checked;\r\n      newItem.expanded = newItemOldInfo.expanded;\r\n      newItem.indeterminate = newItemOldInfo.indeterminate;\r\n      newItem.selected = newItemOldInfo.selected;\r\n\r\n      const newItemWasLazyLoaded =\r\n        newItem.lazy && newItemOldInfo.lazy === false;\r\n\r\n      if (newItemWasLazyLoaded) {\r\n        newItem.lazy = false;\r\n\r\n        // Don't remove items until the child item is reloaded\r\n        newItem.items = newItemOldInfo.items;\r\n\r\n        // Add the item to be reloaded after its parent has finished its reload\r\n        reloadNewItemsQueue.push(newItem.id);\r\n      }\r\n\r\n      // Remove the item from the set to properly count items that no longer\r\n      // exist in the node\r\n      oldItemsSet.delete(newItem.id);\r\n    }\r\n  });\r\n\r\n  // Remove all the items that no longer exists in the node\r\n  if (oldItemsSet.size > 0) {\r\n    removeItems([...oldItemsSet.keys()]);\r\n  }\r\n\r\n  // Update the items of the reloaded node\r\n  await loadLazyContent(itemId, newItems);\r\n\r\n  if (afterProperties) {\r\n    elementRef.updateItemsProperties([itemId], afterProperties);\r\n  }\r\n\r\n  // Reload child items that were lazy loaded\r\n  await Promise.allSettled(\r\n    reloadNewItemsQueue.map(itemToReload =>\r\n      reloadItems(\r\n        elementRef,\r\n        itemToReload,\r\n        flattenedTreeModel,\r\n        lazyLoadTreeItemsCallback,\r\n        loadLazyContent,\r\n        removeItems\r\n      )\r\n    )\r\n  );\r\n\r\n  return true;\r\n};\r\n","import { itemHasCheckbox } from \"./helpers\";\r\nimport { TreeViewItemModel, TreeViewItemModelExtended } from \"./types\";\r\n\r\nexport const updateItemProperty = (\r\n  itemId: string,\r\n  properties: Partial<TreeViewItemModel>,\r\n  flattenedTreeModel: Map<string, TreeViewItemModelExtended>,\r\n  newSelectedItems: Set<string>,\r\n  newCheckboxItems: Map<string, TreeViewItemModelExtended>,\r\n  defaultCheckbox: boolean\r\n) => {\r\n  const itemUIModel = flattenedTreeModel.get(itemId);\r\n  if (!itemUIModel) {\r\n    return;\r\n  }\r\n\r\n  const itemInfo = itemUIModel.item;\r\n\r\n  Object.keys(properties).forEach(propertyName => {\r\n    if (properties[propertyName] !== undefined) {\r\n      itemInfo[propertyName] = properties[propertyName];\r\n    }\r\n  });\r\n\r\n  // Accumulate selection/deselection\r\n  if (properties.selected) {\r\n    newSelectedItems.add(itemId);\r\n  } else if (properties.selected === false) {\r\n    newSelectedItems.delete(itemId);\r\n  }\r\n\r\n  // Accumulate/remove items with checkbox\r\n  if (itemHasCheckbox(itemInfo, defaultCheckbox)) {\r\n    newCheckboxItems.set(itemId, itemUIModel);\r\n  } else {\r\n    newCheckboxItems.delete(itemId);\r\n  }\r\n};\r\n","import { TreeViewItemModel, TreeViewItemModelExtended } from \"../types\";\r\nimport { ROOT_ID } from \"../utils\";\r\n\r\nexport const getItemPath = (\r\n  itemId: string,\r\n  flattenedTreeModel: Map<string, TreeViewItemModelExtended>\r\n): TreeViewItemModel[] | null => {\r\n  const itemUIModel = flattenedTreeModel.get(itemId);\r\n\r\n  if (!itemUIModel) {\r\n    return null;\r\n  }\r\n\r\n  const itemPath: TreeViewItemModel[] = [itemUIModel.item];\r\n  let currentItemUIModel = itemUIModel;\r\n\r\n  while (currentItemUIModel.parentItem.id !== ROOT_ID) {\r\n    itemPath.push(currentItemUIModel.parentItem);\r\n    currentItemUIModel = flattenedTreeModel.get(\r\n      currentItemUIModel.parentItem.id\r\n    );\r\n  }\r\n\r\n  return itemPath.reverse();\r\n};\r\n","@import \"../../common/base\";\r\n\r\n:host {\r\n  /**\r\n   * @prop --ch-tree-view-item-custom-padding-inline-start:\r\n   * Specifies an additional value for the padding-inline-start of the items\r\n   * without breaking the indentation of the items.\r\n   * @default 0px\r\n   */\r\n  --ch-tree-view-item-custom-padding-inline-start: 0px;\r\n\r\n  /**\r\n   * @prop --ch-tree-view-item-gap:\r\n   * Specifies the spacing between the images, checkbox, text and the\r\n   * expandable button of the items.\r\n   * @default 0px\r\n   */\r\n  --ch-tree-view-item-gap: 0px;\r\n\r\n  /**\r\n   * @prop --ch-tree-view-item__checkbox-size:\r\n   * Specifies the checkbox size of the items.\r\n   * @default #{$default-decorative-image-size}\r\n   */\r\n  --ch-tree-view-item__checkbox-size: #{$default-decorative-image-size};\r\n\r\n  /**\r\n   * @prop --ch-tree-view-item__checkbox-size:\r\n   * Specifies the expandable button size of the items.\r\n   * @default #{$default-decorative-image-size}\r\n   */\r\n  --ch-tree-view-item__expandable-button-size: #{$default-decorative-image-size};\r\n\r\n  /**\r\n   * @prop --ch-tree-view-item__image-size:\r\n   * Specifies the box size that contains the start or end images of the items.\r\n   * @default #{$default-decorative-image-size}\r\n   */\r\n  --ch-tree-view-item__image-size: #{$default-decorative-image-size};\r\n\r\n  /**\r\n   * @prop --ch-tree-view-item__image-size:\r\n   * Specifies the size of the start and end images of the items.\r\n   * @default 100%\r\n   */\r\n  --ch-tree-view-item__background-image-size: 100%;\r\n\r\n  /**\r\n   * @prop --ch-tree-view-item__line--inset-inline-start:\r\n   * Specifies an additional separation that only applies for the inline start\r\n   * position of the item's line.\r\n   * @default 0px\r\n   */\r\n  --ch-tree-view-item__line--inset-inline-start: 0px;\r\n\r\n  /**\r\n   * @prop --ch-tree-view-item__line--inset-inline-end:\r\n   * Specifies the separation that only applies for the inline end position of\r\n   * the item's line. This separation visually shows a gap between the line and\r\n   * the item's header.\r\n   * @default 0px\r\n   */\r\n  --ch-tree-view-item__line--inset-inline-end: 0px;\r\n\r\n  --ch-tree-tab-size: calc(\r\n    var(--ch-tree-view-item__image-size) +\r\n      var(--ch-tree-view-item__expandable-button-size) +\r\n      (var(--ch-tree-view-item-gap) * 2)\r\n  );\r\n\r\n  display: grid;\r\n  grid-auto-rows: max-content;\r\n  block-size: 100%;\r\n  overflow: auto;\r\n  contain: size;\r\n}\r\n\r\n// Reset useful droppable areas\r\n.dragging-item ch-tree-view-item {\r\n  pointer-events: var(--ch-tree-view-pointer-events, all);\r\n}\r\n\r\n// Remove un-useful droppable areas\r\n.dragging-item .item-deny-drop {\r\n  pointer-events: none;\r\n}\r\n\r\n// Remove droppable areas on selected items\r\n.dragging-selected-items ch-tree-view-item[selected] {\r\n  --ch-tree-view-pointer-events: none;\r\n}\r\n\r\n// - - - - - - - - - - - - - - - -\r\n//        Item indentation\r\n// - - - - - - - - - - - - - - - -\r\n::part(item__header),\r\nch-tree-view-drop {\r\n  --own-offset: 0px;\r\n\r\n  --ch-tree-view-item-indentation: calc(\r\n    var(--ch-tree-tab-size) * var(--level) - var(--own-offset) -\r\n      var(--parent-offset, 0px) +\r\n      var(--ch-tree-view-item-custom-padding-inline-start)\r\n  );\r\n}\r\n\r\n// Properly ident first level leafs when the expand button is visible\r\n::part(item__header level-0-leaf) {\r\n  --ch-tree-view-item-indentation: calc(\r\n    var(--ch-tree-view-item__expandable-button-size) +\r\n      var(--ch-tree-view-item-gap) +\r\n      var(--ch-tree-view-item-custom-padding-inline-start)\r\n  );\r\n}\r\n\r\n::part(item__header expand-button),\r\nch-tree-view-drop {\r\n  --own-offset: calc(\r\n    var(--ch-tree-view-item__expandable-button-size) +\r\n      var(--ch-tree-view-item-gap)\r\n  );\r\n}\r\n\r\n// Even level\r\n::part(item__header even-level),\r\nch-tree-view-drop.gx-even-level {\r\n  --parent-offset: var(--parent-offset-odd);\r\n}\r\n\r\n// Odd level\r\n::part(item__header odd-level),\r\nch-tree-view-drop.gx-odd-level {\r\n  --parent-offset: var(--parent-offset-even);\r\n}\r\n\r\nch-tree-view-drop {\r\n  margin-inline-start: var(--ch-tree-view-item-indentation);\r\n}\r\n\r\n::part(item__header) {\r\n  padding-inline-start: var(--ch-tree-view-item-indentation);\r\n}\r\n\r\n::part(item__group even-level) {\r\n  --parent-offset-even: calc(\r\n    var(--ch-tree-view-item__expandable-button-size) +\r\n      var(--ch-tree-view-item-gap) + var(--parent-offset-odd, 0px)\r\n  );\r\n}\r\n\r\n::part(item__group odd-level) {\r\n  --parent-offset-odd: calc(\r\n    var(--ch-tree-view-item__expandable-button-size) +\r\n      var(--ch-tree-view-item-gap) + var(--parent-offset-even, 0px)\r\n  );\r\n}\r\n\r\nch-tree-view-item {\r\n  // Improve the position of the first-child to avoid clipping the droppable\r\n  // area, since the parent has content-visibility: \"auto\" which creates a new\r\n  // containing block\r\n  & > ch-tree-view-drop:first-child {\r\n    transform: translateY(0);\r\n\r\n    &::after {\r\n      inset-block-start: 0px;\r\n    }\r\n  }\r\n\r\n  // Improve collision with the end drop (level N + 1) of a group and the next\r\n  // drop in the level N\r\n  & > ch-tree-view-drop:last-child {\r\n    transform: translateY(calc(var(--ch-tree-view-drop--size) * -1));\r\n\r\n    &::after {\r\n      inset-block-start: calc(var(--ch-tree-view-drop--size) * 0.5);\r\n    }\r\n  }\r\n}\r\n","import {\r\n  Component,\r\n  Element,\r\n  Event,\r\n  EventEmitter,\r\n  h,\r\n  Prop,\r\n  Listen,\r\n  Watch,\r\n  State,\r\n  forceUpdate,\r\n  Method,\r\n  Host\r\n} from \"@stencil/core\";\r\nimport type {\r\n  TreeViewDataTransferInfo,\r\n  TreeViewDropCheckInfo,\r\n  TreeViewItemContextMenu,\r\n  TreeViewLines,\r\n  TreeViewItemCheckedInfo,\r\n  TreeViewItemExpandedInfo,\r\n  TreeViewItemNewCaption,\r\n  TreeViewItemOpenReferenceInfo,\r\n  TreeViewItemSelectedInfo,\r\n  TreeViewDropType\r\n} from \"./internal/tree-view/types\";\r\nimport {\r\n  LazyLoadTreeItemsCallback,\r\n  TreeViewFilterInfo,\r\n  TreeViewFilterOptions,\r\n  TreeViewFilterType,\r\n  TreeViewImagePathCallback,\r\n  TreeViewItemModel,\r\n  TreeViewItemModelExtended,\r\n  TreeViewModel,\r\n  TreeViewOperationStatusModifyCaption,\r\n  TreeViewRemoveItemsResult\r\n} from \"./types\";\r\nimport {\r\n  ChTreeViewCustomEvent,\r\n  ChTreeViewItemCustomEvent\r\n} from \"../../components\";\r\nimport { GxDataTransferInfo } from \"../../common/types\";\r\nimport { computeFilter, itemHasCheckbox } from \"./helpers\";\r\nimport {\r\n  GXRender,\r\n  TreeViewGXItemModel,\r\n  fromGxImageToURL\r\n} from \"./genexus-implementation\";\r\nimport {\r\n  removeTreeViewItems,\r\n  ROOT_ID,\r\n  scrollIntoVisibleId,\r\n  scrollIntoVisiblePath\r\n} from \"./utils\";\r\nimport { reloadItems } from \"./reload-items\";\r\nimport { updateItemProperty } from \"./update-item-property\";\r\nimport { insertIntoIndex, removeElement } from \"../../common/array\";\r\nimport {\r\n  getControlRegisterProperty,\r\n  registryControlProperty\r\n} from \"../../common/registry-properties\";\r\nimport { getItemPath } from \"./methods/getItemPath\";\r\n\r\n// - - - - - - - - - - - - - - - - - - - -\r\n//                Registry\r\n// - - - - - - - - - - - - - - - - - - - -\r\n// This callback will be registered by default. If it is used in GeneXus, all\r\n// tree views will have the same state, so the parameters used of the treeState\r\n// are \"shared\" across all tree view instances\r\nconst registerDefaultGetImagePathCallback = (treeState: ChTreeViewRender) =>\r\n  registryControlProperty(\r\n    \"getImagePathCallback\",\r\n    \"ch-tree-view-render\",\r\n    (item: TreeViewItemModel, iconDirection: \"start\" | \"end\" = \"start\") => {\r\n      const img = iconDirection === \"start\" ? item.startImgSrc : item.endImgSrc;\r\n\r\n      return treeState.useGxRender\r\n        ? fromGxImageToURL(\r\n            img,\r\n            treeState.gxSettings,\r\n            treeState.gxImageConstructor\r\n          )\r\n        : img;\r\n    }\r\n  );\r\n\r\n// - - - - - - - - - - - - - - - - - - - -\r\n//                Defaults\r\n// - - - - - - - - - - - - - - - - - - - -\r\n\r\nconst DEFAULT_EXPANDED_VALUE = false;\r\nconst DEFAULT_INDETERMINATE_VALUE = false;\r\nconst DEFAULT_LAZY_VALUE = false;\r\nconst DEFAULT_ORDER_VALUE = 0;\r\nconst DEFAULT_SELECTED_VALUE = false;\r\n\r\n// There are a filter applied and, if the type is \"caption\" or\r\n// \"metadata\", the filter property must be set\r\nconst treeViewHasFilters = (\r\n  filterType: TreeViewFilterType,\r\n  filter: string | RegExp\r\n) => {\r\n  if (filterType === \"none\") {\r\n    return false;\r\n  }\r\n\r\n  if (filterType !== \"caption\" && filterType !== \"metadata\") {\r\n    return true;\r\n  }\r\n\r\n  if (!filter) {\r\n    return false;\r\n  }\r\n\r\n  // The RegExp has \"object\" type\r\n  // TODO: Add unit tests for the trim case\r\n  return typeof filter === \"object\" || filter.trim() !== \"\";\r\n};\r\n\r\n// GeneXus implementation\r\nconst gxDragDisabled = (\r\n  itemModel: TreeViewGXItemModel,\r\n  treeState: ChTreeViewRender\r\n) =>\r\n  itemModel.dragEnabled != null\r\n    ? !itemModel.dragEnabled\r\n    : treeState.dragDisabled;\r\n\r\n// GeneXus implementation\r\nconst gxDropDisabled = (\r\n  itemModel: TreeViewGXItemModel,\r\n  treeState: ChTreeViewRender\r\n) =>\r\n  itemModel.dropEnabled != null\r\n    ? !itemModel.dropEnabled\r\n    : treeState.dropDisabled;\r\n\r\nconst isDropDisabled = (\r\n  itemModel: TreeViewGXItemModel,\r\n  treeState: ChTreeViewRender,\r\n  useGxRender: boolean\r\n) =>\r\n  useGxRender\r\n    ? gxDropDisabled(itemModel, treeState)\r\n    : (itemModel as GXRender<false>).dropDisabled ?? treeState.dropDisabled;\r\n\r\nconst treeDropId = (treeItemId: string) => `ch-tree-view-drop__${treeItemId}`;\r\n\r\nconst defaultRenderItem = <T extends true | false>(\r\n  itemModel: GXRender<T>,\r\n  treeState: ChTreeViewRender,\r\n  treeHasFilter: boolean,\r\n  lastItem: boolean,\r\n  level: number,\r\n  dropBeforeAndAfterEnabled: boolean,\r\n  useGxRender = false\r\n) =>\r\n  (treeState.filterType === \"none\" ||\r\n    itemModel.render !== false ||\r\n    (treeState.filterType === \"list\" &&\r\n      (treeState.filterList === undefined ||\r\n        treeState.filterList === null))) && [\r\n    dropBeforeAndAfterEnabled && (\r\n      <ch-tree-view-drop\r\n        id={treeDropId(itemModel.id)}\r\n        level={level}\r\n        treeItemId={itemModel.id}\r\n        type=\"before\"\r\n      ></ch-tree-view-drop>\r\n    ),\r\n\r\n    <ch-tree-view-item\r\n      key={itemModel.id}\r\n      id={itemModel.id}\r\n      caption={itemModel.caption}\r\n      checkbox={itemModel.checkbox ?? treeState.checkbox}\r\n      checked={itemModel.checked ?? treeState.checked}\r\n      disabled={\r\n        useGxRender\r\n          ? (itemModel as GXRender<true>).enabled === false\r\n          : (itemModel as GXRender<false>).disabled\r\n      }\r\n      downloading={itemModel.downloading}\r\n      dragDisabled={\r\n        useGxRender\r\n          ? gxDragDisabled(itemModel, treeState)\r\n          : (itemModel as GXRender<false>).dragDisabled ??\r\n            treeState.dragDisabled\r\n      }\r\n      dropDisabled={isDropDisabled(itemModel, treeState, useGxRender)}\r\n      editable={itemModel.editable ?? treeState.editableItems}\r\n      endImgSrc={itemModel.endImgSrc}\r\n      endImgType={itemModel.endImgType ?? \"background\"}\r\n      expanded={itemModel.expanded}\r\n      expandableButton={treeState.expandableButton}\r\n      expandOnClick={treeState.expandOnClick}\r\n      getImagePathCallback={treeState.getImagePathCallback}\r\n      indeterminate={itemModel.indeterminate}\r\n      lastItem={lastItem}\r\n      lazyLoad={itemModel.lazy}\r\n      leaf={itemModel.leaf}\r\n      level={level}\r\n      metadata={itemModel.metadata}\r\n      model={itemModel}\r\n      parts={itemModel.parts}\r\n      selected={itemModel.selected}\r\n      showLines={treeState.showLines}\r\n      toggleCheckboxes={\r\n        itemModel.toggleCheckboxes ?? treeState.toggleCheckboxes\r\n      }\r\n      startImgSrc={itemModel.startImgSrc}\r\n      startImgType={itemModel.startImgType ?? \"background\"}\r\n    >\r\n      {!itemModel.leaf &&\r\n        itemModel.items != null &&\r\n        itemModel.items.map((subModel, index) =>\r\n          treeState.renderItem(\r\n            subModel,\r\n            treeState,\r\n            treeHasFilter,\r\n            treeState.showLines !== \"none\" &&\r\n              // If there is a filter applied in the current list, use the\r\n              // lastItemId value to calculate the last item\r\n              (treeHasFilter && itemModel.lastItemId !== undefined\r\n                ? subModel.id === itemModel.lastItemId\r\n                : index === itemModel.items.length - 1),\r\n            level + 1,\r\n\r\n            // When dragging \"before\" and \"after\" an item and the direct parent\r\n            // has drops disabled, don't render the ch-tree-view-drop elements.\r\n            treeState.dropMode !== \"above\" &&\r\n              isDropDisabled(itemModel, treeState, useGxRender) !== true,\r\n            useGxRender\r\n          )\r\n        )}\r\n    </ch-tree-view-item>,\r\n\r\n    dropBeforeAndAfterEnabled && lastItem && (\r\n      <ch-tree-view-drop\r\n        id={treeDropId(itemModel.id) + \"-after\"}\r\n        level={level}\r\n        treeItemId={itemModel.id}\r\n        type=\"after\"\r\n      ></ch-tree-view-drop>\r\n    )\r\n  ];\r\n\r\nconst defaultSortItemsCallback = (subModel: TreeViewModel): void => {\r\n  subModel.sort((a, b) => {\r\n    if (a.order < b.order) {\r\n      return -1;\r\n    }\r\n\r\n    if (a.order > b.order) {\r\n      return 0;\r\n    }\r\n\r\n    return a.caption <= b.caption ? -1 : 0;\r\n  });\r\n};\r\n\r\ntype ImmediateFilter = \"immediate\" | \"debounced\" | undefined;\r\n\r\n/**\r\n * @part drag-preview - The element that contains the preview information for the current drag.\r\n *\r\n * @part item - The host element of the each item.\r\n *\r\n * @part item__action - A sub element of the header (item__header part) that contains the main information related to the item (startImage, caption/edit-caption, endImage and downloading).\r\n *\r\n * @part item__checkbox - The host element of the item's checkbox.\r\n * @part item__checkbox-container - The container that serves as a wrapper for the `input` and the `option` parts of the checkbox.\r\n * @part item__checkbox-input - The input element that implements the interactions for the checkbox.\r\n * @part item__checkbox-option - The actual \"input\" that is rendered above the `item__checkbox-input` part of the checkbox. This part has `position: absolute` and `pointer-events: none`.\r\n *\r\n * @part item__downloading - The spinner element that is rendered when an item is lazy loading its content. This element is rendered at the end of the `item__action` part.\r\n *\r\n * @part item__edit-caption - The input element that is rendered when an item is editing its caption. When rendered this element replaces the caption of the `item__action` part.\r\n *\r\n * @part item__expandable-button - The actionable expandable button element that is rendered when an item has subitems and the expandable button is interactive (`leaf !== true` and `expandableButton === \"action\"`). When rendered this element is placed at the start of the `item__action` part.\r\n *\r\n * @part item__group - The container element for the subitems that is rendered when the content of an item has been lazy loaded.\r\n *\r\n * @part item__header - The container for all elements -excepts the subitems (`item__group` part)- of an item. It contains the `item__expandable-button`, `item_checkbox` and `item__action` parts.\r\n *\r\n * @part item__img - The img element that is rendered when an item has images (`startImgSrc` is defined and/or `endImgSrc` is defined).\r\n *\r\n * @part item__line - The element that is rendered to display the relationship between the an item and its parent. Rendered if the item is not in the first level and `showLines !== \"none\"`.\r\n *\r\n * @part disabled - Present in the `item__header`, `item__expandable-button`, `item__checkbox-input`, `item__checkbox-option` and `item__checkbox-container` parts when the item is disabled (`disabled` === `true`).\r\n *\r\n * @part expanded - Present in the `item__action`, `item__expandable-button` and `item__group` parts when the item is expanded (`expanded` === `true`).\r\n * @part collapsed - Present in the `item__action`, `item__expandable-button` and `item__group` parts when the item is collapsed (`expanded` !== `true`).\r\n *\r\n * @part expand-button - Present in the `item__header` part when the item has an expandable button (`level !== 0`, `leaf !== true` and `expandableButton !== \"no\"`).\r\n *\r\n * @part even-level - Present in the `item__group` and `item__header` parts when the item is in an even level.\r\n * @part odd-level - Present in the `item__group` and `item__header` parts when the item is in an odd level.\r\n *\r\n * @part last-line - Present in the `item__line` part if the item is the last item of its parent item in `showLines = \"last\"` mode (`showLines === \"last\"`, `level !== 0` and `lastItem === true`).\r\n *\r\n * @part lazy-loaded - Present in the `item__group` part when the content of the item has been loaded.\r\n *\r\n * @part start-img - Present in the `item__img` part when the item has an start image element (`startImgSrc` is defined and `startImgType` === \"img\").\r\n * @part end-img - Present in the `item__img` part when the item has an end image element (`endImgSrc` is defined and `endImgType` === \"img\").\r\n *\r\n * @part editing - Present in the `item__header` and `item__action` parts when the item is in edit mode.\r\n * @part not-editing - Present in the `item__header` and `item__action` parts when the item isn't in edit mode.\r\n *\r\n * @part selected - Present in the `item__header` part when the item is selected (`selected` === `true`).\r\n * @part not-selected - Present in the `item__header` part when the item isn't selected (`selected` !== `true`).\r\n *\r\n * @part checked - Present in the `item__checkbox-input`, `item__checkbox-option` and `item__checkbox-container` parts when the item is checked and not indeterminate (`checked` === `true` and `indeterminate !== true`).\r\n * @part indeterminate - Present in the `item__checkbox-input`, `item__checkbox-option` and `item__checkbox-container` parts when the item is indeterminate (`indeterminate` === `true`).\r\n * @part unchecked - Present in the `item__checkbox-input`, `item__checkbox-option` and `item__checkbox-container` parts when the item is unchecked and not indeterminate (`checked` !== `true` and `indeterminate !== true`).\r\n *\r\n * @part drag-enter - Present in the `item` and `item__header` parts when a valid drop operation is over the item.\r\n */\r\n@Component({\r\n  tag: \"ch-tree-view-render\",\r\n  styleUrl: \"tree-view-render.scss\",\r\n  shadow: true\r\n})\r\nexport class ChTreeViewRender {\r\n  // UI Models\r\n  #flattenedTreeModel: Map<string, TreeViewItemModelExtended> = new Map();\r\n  #flattenedCheckboxTreeModel: Map<string, TreeViewItemModelExtended> =\r\n    new Map();\r\n  #selectedItems: Set<string> = new Set();\r\n\r\n  #selectedChangeScheduled = false;\r\n\r\n  #checkedChangeScheduled = false;\r\n\r\n  #rootNode: TreeViewItemModel;\r\n\r\n  // Filters info\r\n  #applyFilters = false;\r\n  #immediateFilter: ImmediateFilter;\r\n  #filterTimeout: NodeJS.Timeout;\r\n  #filterListAsSet: Set<string>;\r\n\r\n  // Refs\r\n  #treeRef: HTMLChTreeViewElement;\r\n\r\n  @Element() el: HTMLChTreeViewRenderElement;\r\n\r\n  /**\r\n   * This property lets you specify if the tree is waiting to process the drop\r\n   * of items.\r\n   */\r\n  @State() waitDropProcessing = false;\r\n\r\n  /**\r\n   * Set this attribute if you want display a checkbox in all items by default.\r\n   */\r\n  @Prop() readonly checkbox: boolean = false;\r\n\r\n  /**\r\n   * Set this attribute if you want the checkbox to be checked in all items by\r\n   * default.\r\n   * Only works if `checkbox = true`\r\n   */\r\n  @Prop() readonly checked: boolean = false;\r\n\r\n  /**\r\n   * Callback that is executed when an element tries to drop in another item of\r\n   * the tree. Returns whether the drop is valid.\r\n   */\r\n  @Prop() readonly checkDroppableZoneCallback: (\r\n    dropInformation: TreeViewDropCheckInfo\r\n  ) => Promise<boolean>;\r\n\r\n  /**\r\n   * This attribute lets you specify if the drag operation is disabled in all\r\n   * items by default. If `true`, the items can't be dragged.\r\n   */\r\n  @Prop() readonly dragDisabled: boolean = true;\r\n\r\n  /**\r\n   * This attribute lets you specify if the drop operation is disabled in all\r\n   * items by default. If `true`, the items won't accept any drops.\r\n   */\r\n  @Prop() readonly dropDisabled: boolean = true;\r\n\r\n  /**\r\n   * Callback that is executed when a list of items request to be dropped into\r\n   * another item.\r\n   */\r\n  @Prop() readonly dropItemsCallback: (\r\n    dataTransferInfo: TreeViewDataTransferInfo\r\n  ) => Promise<{ acceptDrop: boolean; model?: TreeViewModel }>;\r\n\r\n  /**\r\n   * This attribute lets you specify which kind of drop operation can be\r\n   * effected in the items.\r\n   */\r\n  @Prop() readonly dropMode: \"above\" | \"before-and-after\" | \"all\" = \"above\";\r\n\r\n  /**\r\n   * This attribute lets you specify if the edit operation is enabled in all\r\n   * items by default. If `true`, the items can edit its caption in place.\r\n   */\r\n  @Prop() readonly editableItems: boolean = false;\r\n\r\n  /**\r\n   * Specifies what kind of expandable button is displayed in the items by\r\n   * default.\r\n   *  - `\"expandableButton\"`: Expandable button that allows to expand/collapse\r\n   *     the items of the control.\r\n   *  - `\"decorative\"`: Only a decorative icon is rendered to display the state\r\n   *     of the item.\r\n   */\r\n  @Prop() readonly expandableButton: \"action\" | \"decorative\" | \"no\" =\r\n    \"decorative\";\r\n\r\n  /**\r\n   * Specifies if a tree-view-item is expanded on click interaction. If `true`\r\n   * the tree-view-item is expanded on click interaction. If `false`, with\r\n   * mouse interaction the tree-view-item will only be expanded on double click.\r\n   */\r\n  @Prop() readonly expandOnClick: boolean = true;\r\n\r\n  /**\r\n   * This property lets you determine the expression that will be applied to the\r\n   * filter.\r\n   * Only works if `filterType = \"caption\" | \"metadata\"`.\r\n   */\r\n  @Prop() readonly filter?: string | RegExp | undefined;\r\n  @Watch(\"filter\")\r\n  filterChanged() {\r\n    if (this.filterType === \"caption\" || this.filterType === \"metadata\") {\r\n      this.#scheduleFilterProcessing();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This property lets you determine the debounce time (in ms) that the\r\n   * control waits until it processes the changes to the filter property.\r\n   * Consecutive changes to the `filter` property between this range, reset the\r\n   * timeout to process the filter.\r\n   * Only works if `filterType = \"caption\" | \"metadata\"`.\r\n   */\r\n  @Prop() readonly filterDebounce: number = 250;\r\n  @Watch(\"filterDebounce\")\r\n  filterDebounceChanged() {\r\n    if (this.filterType === \"caption\" || this.filterType === \"metadata\") {\r\n      this.#scheduleFilterProcessing();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This property lets you determine the list of items that will be filtered.\r\n   * Only works if `filterType = \"list\"`.\r\n   * If `undefined` or `null` all items will be rendered. If `[]` no items will\r\n   * be rendered.\r\n   */\r\n  @Prop() readonly filterList: string[] | undefined | null = undefined;\r\n  @Watch(\"filterList\")\r\n  filterListChanged() {\r\n    // Use a Set to efficiently check for ids\r\n    this.#filterListAsSet = new Set(this.filterList);\r\n\r\n    if (this.filterType === \"list\") {\r\n      this.#scheduleFilterProcessing();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This property lets you determine the options that will be applied to the\r\n   * filter.\r\n   */\r\n  @Prop() readonly filterOptions: TreeViewFilterOptions = {};\r\n  @Watch(\"filterOptions\")\r\n  filterOptionsChanged() {\r\n    this.#scheduleFilterProcessing();\r\n  }\r\n\r\n  /**\r\n   * This attribute lets you define what kind of filter is applied to items.\r\n   * Only items that satisfy the filter predicate will be displayed.\r\n   *\r\n   * | Value       | Details                                                                                        |\r\n   * | ----------- | ---------------------------------------------------------------------------------------------- |\r\n   * | `checked`   | Show only the items that have a checkbox and are checked.                                      |\r\n   * | `unchecked` | Show only the items that have a checkbox and are not checked.                                  |\r\n   * | `caption`   | Show only the items whose `caption` satisfies the regex determinate by the `filter` property.  |\r\n   * | `metadata`  | Show only the items whose `metadata` satisfies the regex determinate by the `filter` property. |\r\n   * | `list`      | Show only the items that are contained in the array determinate by the `filterList` property.  |\r\n   * | `none`      | Show all items.                                                                                |\r\n   */\r\n  @Prop() readonly filterType: TreeViewFilterType = \"none\";\r\n  @Watch(\"filterType\")\r\n  filterTypeChanged(newValue: TreeViewFilterType) {\r\n    if (newValue === \"list\") {\r\n      // Use a Set to efficiently check for ids\r\n      this.#filterListAsSet = new Set(this.filterList);\r\n    } else {\r\n      this.#filterListAsSet = undefined; // Free the memory\r\n    }\r\n\r\n    this.#scheduleFilterProcessing();\r\n  }\r\n\r\n  /**\r\n   * This property is a WA to implement the Tree View as a UC 2.0 in GeneXus.\r\n   */\r\n  @Prop() readonly gxImageConstructor: (name: string) => any;\r\n\r\n  /**\r\n   * This property is a WA to implement the Tree View as a UC 2.0 in GeneXus.\r\n   */\r\n  @Prop() readonly gxSettings: any;\r\n\r\n  /**\r\n   * This property specifies a callback that is executed when the path for an\r\n   * item image needs to be resolved. With this callback, there is no need to\r\n   * re-implement item rendering (`renderItem` property) just to change the\r\n   * path used for the images.\r\n   */\r\n  @Prop() readonly getImagePathCallback: TreeViewImagePathCallback;\r\n\r\n  /**\r\n   * Callback that is executed when a item request to load its subitems.\r\n   */\r\n  @Prop() readonly lazyLoadTreeItemsCallback: LazyLoadTreeItemsCallback;\r\n\r\n  /**\r\n   * Callback that is executed when a item request to modify its caption.\r\n   */\r\n  @Prop() readonly modifyItemCaptionCallback: (\r\n    treeItemId: string,\r\n    newCaption: string\r\n  ) => Promise<TreeViewOperationStatusModifyCaption>;\r\n\r\n  /**\r\n   * Set this attribute if you want to allow multi selection of the items.\r\n   */\r\n  @Prop() readonly multiSelection: boolean = false;\r\n  @Watch(\"multiSelection\")\r\n  multiSelectionChanged(newMultiSelection: boolean) {\r\n    // MultiSelection is disabled. We must select the last updated item\r\n    if (!newMultiSelection) {\r\n      this.#removeAllSelectedItemsExceptForTheLast(this.#selectedItems);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This property lets you define the model of the ch-tree-view-render control.\r\n   */\r\n  @Prop() readonly model: TreeViewModel = [];\r\n  @Watch(\"model\")\r\n  modelChanged() {\r\n    this.#flattenModel();\r\n  }\r\n\r\n  /**\r\n   * This property allows us to implement custom rendering of tree items.\r\n   */\r\n  @Prop() readonly renderItem: (\r\n    itemModel: TreeViewItemModel | any,\r\n    treeState: ChTreeViewRender,\r\n    treeHasFilter: boolean,\r\n    lastItem: boolean,\r\n    level: number,\r\n    dropBeforeAndAfterEnabled: boolean,\r\n    useGxRender?: boolean\r\n  ) => any = defaultRenderItem;\r\n\r\n  /**\r\n   * `true` to display the relation between tree items and tree lists using\r\n   * lines.\r\n   */\r\n  @Prop() readonly showLines: TreeViewLines = \"none\";\r\n\r\n  /**\r\n   * Callback that is executed when the `model` is changed to order its items.\r\n   */\r\n  @Prop() readonly sortItemsCallback: (subModel: TreeViewModel) => void =\r\n    defaultSortItemsCallback;\r\n\r\n  /**\r\n   * Set this attribute if you want all the children item's checkboxes to be\r\n   * checked when the parent item checkbox is checked, or to be unchecked when\r\n   * the parent item checkbox is unchecked.\r\n   * This attribute will be used in all items by default.\r\n   */\r\n  @Prop() readonly toggleCheckboxes: boolean = false;\r\n\r\n  /**\r\n   * This property is a WA to implement the Tree View as a UC 2.0 in GeneXus.\r\n   */\r\n  @Prop() readonly useGxRender: boolean = false;\r\n\r\n  /**\r\n   * Fired when the checked items change.\r\n   * This event does take into account the currently filtered items.\r\n   */\r\n  @Event() checkedItemsChange: EventEmitter<\r\n    Map<string, TreeViewItemModelExtended>\r\n  >;\r\n\r\n  /**\r\n   * Fired when an element displays its contextmenu.\r\n   */\r\n  @Event() itemContextmenu: EventEmitter<TreeViewItemContextMenu>;\r\n\r\n  /**\r\n   * Fired when the user interacts with an item in a way that its reference\r\n   * must be opened.\r\n   */\r\n  @Event() itemOpenReference: EventEmitter<TreeViewItemOpenReferenceInfo>;\r\n\r\n  /**\r\n   * Fired when the selected items change.\r\n   * This event can be fired by the following conditions:\r\n   *   1. A user changes the selected items interacting with the Tree View.\r\n   *\r\n   *   2. The `multiSelection` value is changed from `true` to `false`.\r\n   *\r\n   *   3. A selected item is no longer rendered because it does not satisfies a\r\n   *      filter condition.\r\n   *\r\n   *   4. TODO: The `treeModel` property is updated and contains different selected\r\n   *      items. Even if it does not contains different selected items, this\r\n   *      event is fired because the selected items can have a different path\r\n   *      than before the `treeModel` update.\r\n   *\r\n   *   5. The `updateItemsProperties` method is executed, changing the item\r\n   *      selection.\r\n   *\r\n   *   6. A selected item is removed.\r\n   *\r\n   *   7. TODO: A selected item is moved into a new parent with drag and drop.\r\n   *      In this case, since the detail of the event contains the information\r\n   *      of the parent, this event must be fired to update the information.\r\n   *\r\n   *   8. Executing `scrollIntoVisible` method and updating the selected value\r\n   *      of the scrolled item.\r\n   *\r\n   *   9. TODO: An external item is dropped into the Tree View and the item is\r\n   *      selected.\r\n   *\r\n   *  10. TODO: Lazy loading content that has selected items?\r\n   *\r\n   * Thing that does not fire this event:\r\n   *   - TODO: Renaming a selected item.\r\n   *\r\n   *   - TODO: Applying a filter that keeps all selected items rendered.\r\n   */\r\n  @Event() selectedItemsChange: EventEmitter<TreeViewItemModelExtended[]>;\r\n\r\n  /**\r\n   * Given the drop accepting, the data transfer info and the external items,\r\n   * it process the drops of the items in the tree.\r\n   */\r\n  @Method()\r\n  async dropItems(\r\n    acceptDrop: boolean,\r\n    dataTransferInfo: TreeViewDataTransferInfo,\r\n    model?: TreeViewModel\r\n  ) {\r\n    if (!acceptDrop) {\r\n      return;\r\n    }\r\n\r\n    const newParentId = dataTransferInfo.newContainer.id;\r\n    const newParentUIModel = this.#flattenedTreeModel.get(newParentId);\r\n    const dropType = dataTransferInfo.dropType;\r\n\r\n    // When the dropType is \"before\" or \"after\", the target node must be\r\n    // the parent\r\n    const actualParent =\r\n      dropType === \"above\"\r\n        ? newParentUIModel.item\r\n        : newParentUIModel.parentItem;\r\n\r\n    // Only move the items to the new parent, keeping the state\r\n    if (dataTransferInfo.dropInTheSameTree) {\r\n      let specificIndexToInsert: { index: number } = undefined;\r\n\r\n      if (dropType !== \"above\") {\r\n        specificIndexToInsert = {\r\n          index: actualParent.items.findIndex(\r\n            item => item.id === dataTransferInfo.newContainer.id\r\n          )\r\n        };\r\n\r\n        if (dropType === \"after\") {\r\n          specificIndexToInsert.index++;\r\n        }\r\n      }\r\n\r\n      // Add the UI models to the new container and remove the UI models from\r\n      // the old containers\r\n      dataTransferInfo.draggedItems.forEach(\r\n        this.#moveItemToNewParent(actualParent, specificIndexToInsert)\r\n      );\r\n\r\n      // When the selected items are moved, the tree must update its internal\r\n      // state to not have undefined references\r\n      if (dataTransferInfo.draggingSelectedItems) {\r\n        this.#scheduleSelectedItemsChange();\r\n      }\r\n    }\r\n    // Add the new items\r\n    else {\r\n      if (model == null) {\r\n        return;\r\n      }\r\n\r\n      // Add new items to the parent\r\n      actualParent.items.push(...model);\r\n\r\n      // Flatten the new UI models\r\n      model.forEach(this.#flattenItemUIModel(actualParent));\r\n    }\r\n\r\n    this.#sortItems(actualParent.items);\r\n\r\n    // Open the item to visualize the new subitems\r\n    actualParent.expanded = true;\r\n\r\n    // Re-sync checked items\r\n    this.#scheduleCheckedItemsChange();\r\n\r\n    // Update filters\r\n    this.#scheduleFilterProcessing();\r\n\r\n    // Force re-render\r\n    forceUpdate(this);\r\n  }\r\n\r\n  /**\r\n   * Returns item's path (an ordered array of the UI models that creates the path\r\n   * from the root to the ID) given the item ID, and null if there is no such item\r\n   * otherwise.\r\n   *\r\n   * This method doesn't change its behavior if the tree view has filters\r\n   * applied.\r\n   *\r\n   * @param itemId The id of the item.\r\n   */\r\n  @Method()\r\n  async getItemPath(itemId: string): Promise<TreeViewItemModel[] | null> {\r\n    return getItemPath(itemId, this.#flattenedTreeModel);\r\n  }\r\n\r\n  /**\r\n   * Given a list of ids, it returns an array of the items that exists in the\r\n   * given list.\r\n   */\r\n  @Method()\r\n  async getItemsInfo(itemsId: string[]): Promise<TreeViewItemModelExtended[]> {\r\n    return this.#getItemsInfo(itemsId);\r\n  }\r\n\r\n  #getItemsInfo = (itemsId: string[]): TreeViewItemModelExtended[] => {\r\n    const treeViewItemsInfo: TreeViewItemModelExtended[] = [];\r\n\r\n    itemsId.forEach(itemId => {\r\n      const itemUIModel = this.#flattenedTreeModel.get(itemId);\r\n\r\n      if (itemUIModel) {\r\n        treeViewItemsInfo.push(itemUIModel);\r\n      }\r\n    });\r\n\r\n    return treeViewItemsInfo;\r\n  };\r\n\r\n  /**\r\n   * Given an item id, an array of items to add, the download status and the\r\n   * lazy state, updates the item's UI Model.\r\n   */\r\n  @Method()\r\n  async loadLazyContent(\r\n    itemId: string,\r\n    model?: TreeViewModel,\r\n    downloading = false,\r\n    lazy = false\r\n  ) {\r\n    const itemToLazyLoadContent = this.#flattenedTreeModel.get(itemId).item;\r\n\r\n    // Establish that the content was lazy loaded\r\n    itemToLazyLoadContent.downloading = downloading;\r\n    itemToLazyLoadContent.lazy = lazy;\r\n\r\n    // Check if there is items to add\r\n    if (model == null) {\r\n      return;\r\n    }\r\n\r\n    // @todo What happens in the server when dropping items on a lazy node?\r\n    itemToLazyLoadContent.items = model;\r\n\r\n    this.#sortItems(itemToLazyLoadContent.items);\r\n    this.#flattenSubModel(itemToLazyLoadContent);\r\n\r\n    // Re-sync checked items\r\n    this.#scheduleCheckedItemsChange();\r\n\r\n    // Update filters\r\n    this.#scheduleFilterProcessing(\"immediate\");\r\n\r\n    // Force re-render\r\n    forceUpdate(this);\r\n  }\r\n\r\n  /**\r\n   * Given a list of ids, removes the items and their children in the tree.\r\n   */\r\n  @Method()\r\n  async removeItems(items: string[]) {\r\n    const removeItemsResult: TreeViewRemoveItemsResult = removeTreeViewItems(\r\n      items,\r\n      this.#flattenedTreeModel,\r\n      this.#flattenedCheckboxTreeModel,\r\n      this.#selectedItems\r\n    );\r\n\r\n    if (!this.#treeHasFilters()) {\r\n      // Update selected items\r\n      if (removeItemsResult.atLeastOneSelected) {\r\n        this.#updateSelectedItems();\r\n      }\r\n\r\n      // Re-sync checked items\r\n      if (removeItemsResult.atLeastOneCheckbox) {\r\n        this.#scheduleCheckedItemsChange();\r\n      }\r\n    }\r\n\r\n    // Force re-render\r\n    if (removeItemsResult.atLeastOneElement) {\r\n      forceUpdate(this);\r\n\r\n      // Update filters\r\n      this.#scheduleFilterProcessing(\"immediate\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Given an item id and the additional properties to update before and after\r\n   * reload, it reloads the items of the `itemId` node by using the\r\n   * `lazyLoadTreeItemsCallback` property.\r\n   */\r\n  @Method()\r\n  async reloadItems(\r\n    itemId: string,\r\n    beforeProperties?: Partial<TreeViewItemModel>,\r\n    afterProperties?: Partial<TreeViewItemModel>\r\n  ): Promise<boolean> {\r\n    const success = await reloadItems(\r\n      this.el,\r\n      itemId,\r\n      this.#flattenedTreeModel,\r\n      this.lazyLoadTreeItemsCallback,\r\n      (itemId, items) => this.loadLazyContent(itemId, items),\r\n      (items: string[]) => this.removeItems(items),\r\n      beforeProperties,\r\n      afterProperties\r\n    );\r\n\r\n    return success;\r\n  }\r\n\r\n  /**\r\n   * Given the path of the item (represent by a sorted array containing all ids\r\n   * from the root to the item) and the additional properties to update after,\r\n   * it displays and scrolls into the item view.\r\n   * The path can also be a string representing the id of the item to scroll\r\n   * into.\r\n   *\r\n   * When using a path, this method will fail if:\r\n   *   - The path does not start from the root element.\r\n   *   - The path contains a cycle.\r\n   *   - The path does not correspond to a valid path on the server:\r\n   *     - One of the item of the path, except for the last one, is a leaf.\r\n   *     - An item in the path does not exists on the server.\r\n   *     - The path has repeated items.\r\n   *     - And so on.\r\n   */\r\n  @Method()\r\n  async scrollIntoVisible(\r\n    path: string | string[],\r\n    afterProperties?: Partial<TreeViewItemModel>\r\n  ): Promise<boolean> {\r\n    const hasOnlyTheItemId = typeof path === \"string\";\r\n\r\n    const success = await (hasOnlyTheItemId\r\n      ? scrollIntoVisibleId(path, this.#flattenedTreeModel)\r\n      : scrollIntoVisiblePath(\r\n          this.el,\r\n          path,\r\n          this.#flattenedTreeModel,\r\n          this.#rootNode,\r\n          this.lazyLoadTreeItemsCallback\r\n        ));\r\n\r\n    if (!success) {\r\n      return false;\r\n    }\r\n    const itemId = hasOnlyTheItemId ? path : path[path.length - 1];\r\n\r\n    // Expand all parent items\r\n    let parentInfo = this.#flattenedTreeModel.get(itemId).parentItem;\r\n    while (parentInfo !== this.#rootNode) {\r\n      parentInfo.expanded = true;\r\n      parentInfo = this.#flattenedTreeModel.get(parentInfo.id).parentItem;\r\n    }\r\n\r\n    if (afterProperties) {\r\n      this.updateItemsProperties([itemId], afterProperties);\r\n    }\r\n\r\n    forceUpdate(this);\r\n\r\n    // Scroll into the itemId view, after rendering has completed\r\n    requestAnimationFrame(() => {\r\n      this.#treeRef.scrollIntoVisible(itemId);\r\n    });\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * This method is used to toggle a tree item by the tree item id/ids.\r\n   *\r\n   * @param treeItemIds An array id the tree items to be toggled.\r\n   * @param expand A boolean indicating that the tree item should be expanded or collapsed. (optional)\r\n   * @returns The modified items after the method was called.\r\n   */\r\n  @Method()\r\n  async toggleItems(\r\n    treeItemIds: string[],\r\n    expand?: boolean\r\n  ): Promise<TreeViewItemExpandedInfo[]> {\r\n    if (!treeItemIds) {\r\n      return [];\r\n    }\r\n\r\n    const modifiedTreeItems: TreeViewItemExpandedInfo[] = [];\r\n\r\n    treeItemIds.forEach(treeItemId => {\r\n      const itemInfo = this.#flattenedTreeModel.get(treeItemId).item;\r\n\r\n      if (itemInfo) {\r\n        itemInfo.expanded = expand ?? !itemInfo.expanded;\r\n\r\n        modifiedTreeItems.push({\r\n          id: itemInfo.id,\r\n          expanded: itemInfo.expanded\r\n        });\r\n      }\r\n    });\r\n    // Force re-render\r\n    forceUpdate(this);\r\n\r\n    return modifiedTreeItems;\r\n  }\r\n\r\n  /**\r\n   * Given a subset of item's properties, it updates all item UI models.\r\n   */\r\n  @Method()\r\n  async updateAllItemsProperties(properties: {\r\n    expanded?: boolean;\r\n    checked?: boolean;\r\n  }) {\r\n    [...this.#flattenedTreeModel.values()].forEach(itemUIModel => {\r\n      if (properties.expanded != null) {\r\n        itemUIModel.item.expanded = properties.expanded;\r\n      }\r\n\r\n      if (properties.checked != null) {\r\n        itemUIModel.item.checked = properties.checked;\r\n        itemUIModel.item.indeterminate = false;\r\n      }\r\n    });\r\n\r\n    // Update filters\r\n    if (properties.checked != null) {\r\n      this.#scheduleFilterProcessing();\r\n    }\r\n\r\n    forceUpdate(this);\r\n  }\r\n\r\n  /**\r\n   * Given a item list and the properties to update, it updates the properties\r\n   * of the items in the list.\r\n   */\r\n  @Method()\r\n  async updateItemsProperties(\r\n    items: string[],\r\n    properties: Partial<TreeViewItemModel>\r\n  ) {\r\n    // Set to check if there are new selected items\r\n    const newSelectedItems = new Set(this.#selectedItems);\r\n\r\n    // Map to check if there are new items with checkbox\r\n    const newCheckboxItems: Map<string, TreeViewItemModelExtended> = new Map(\r\n      this.#flattenedCheckboxTreeModel\r\n    );\r\n\r\n    items.forEach(itemId => {\r\n      updateItemProperty(\r\n        itemId,\r\n        properties,\r\n        this.#flattenedTreeModel,\r\n        newSelectedItems,\r\n        newCheckboxItems,\r\n        this.checkbox\r\n      );\r\n    });\r\n\r\n    // MultiSelection is disabled. We must select the last updated item\r\n    if (!this.multiSelection) {\r\n      this.#removeAllSelectedItemsExceptForTheLast(newSelectedItems);\r\n    }\r\n\r\n    // Update filters if necessary\r\n    if (this.#treeHasFilters()) {\r\n      this.#scheduleFilterProcessing();\r\n    } else {\r\n      this.#checkIfThereAreDifferentItemsWithCheckbox(newCheckboxItems);\r\n      this.#checkIfThereAreDifferentSelectedItems(newSelectedItems);\r\n    }\r\n\r\n    forceUpdate(this);\r\n  }\r\n\r\n  /**\r\n   * Update the information about the valid droppable zones.\r\n   * @param requestTimestamp Time where the request to the server was made. Useful to avoid having old information.\r\n   * @param newContainerId ID of the container where the drag is trying to be made.\r\n   * @param draggedItems Information about the dragged items.\r\n   * @param validDrop Current state of the droppable zone.\r\n   * @param dropType Type of drop that wants to be effected\r\n   */\r\n  @Method()\r\n  async updateValidDropZone(\r\n    requestTimestamp: number,\r\n    newContainerId: string,\r\n    draggedItems: GxDataTransferInfo[],\r\n    dropType: TreeViewDropType,\r\n    validDrop: boolean\r\n  ) {\r\n    this.#treeRef.updateValidDropZone(\r\n      requestTimestamp,\r\n      newContainerId,\r\n      draggedItems,\r\n      dropType,\r\n      validDrop\r\n    );\r\n  }\r\n\r\n  @Listen(\"checkboxChange\")\r\n  @Listen(\"checkboxToggleChange\")\r\n  onCheckboxChange(event: ChTreeViewItemCustomEvent<TreeViewItemCheckedInfo>) {\r\n    event.stopPropagation();\r\n\r\n    const detail = event.detail;\r\n    const treeItemId = detail.id;\r\n    const itemUIModel = this.#flattenedCheckboxTreeModel.get(treeItemId);\r\n\r\n    // In some cases, when the `treeModel` and `checked` properties are updated\r\n    // outside of the tree control, some events are fired with undefined references\r\n    if (!itemUIModel) {\r\n      return;\r\n    }\r\n    const itemInfo = itemUIModel.item;\r\n\r\n    itemInfo.checked = detail.checked;\r\n    itemInfo.indeterminate = detail.indeterminate;\r\n\r\n    this.#scheduleCheckedItemsChange();\r\n\r\n    // Update filters\r\n    if (this.filterType === \"checked\" || this.filterType === \"unchecked\") {\r\n      this.#scheduleFilterProcessing();\r\n    }\r\n\r\n    // Force re-render\r\n    forceUpdate(this);\r\n  }\r\n\r\n  @Listen(\"loadLazyContent\")\r\n  onLoadLazyContent(event: ChTreeViewItemCustomEvent<string>) {\r\n    if (!this.lazyLoadTreeItemsCallback) {\r\n      return;\r\n    }\r\n    event.stopPropagation();\r\n\r\n    const treeItemId = event.detail;\r\n    const promise = this.lazyLoadTreeItemsCallback(treeItemId);\r\n    event.target.downloading = true;\r\n\r\n    promise.then(result => {\r\n      this.loadLazyContent(treeItemId, result);\r\n    });\r\n  }\r\n\r\n  @Listen(\"modifyCaption\")\r\n  onModifyCaption(event: ChTreeViewItemCustomEvent<TreeViewItemNewCaption>) {\r\n    if (!this.modifyItemCaptionCallback) {\r\n      return;\r\n    }\r\n    event.stopPropagation();\r\n\r\n    const itemRef = event.target;\r\n    const itemId = event.detail.id;\r\n    const itemUIModel = this.#flattenedTreeModel.get(itemId);\r\n    const itemInfo = itemUIModel.item;\r\n    const newCaption = event.detail.caption;\r\n    const oldCaption = itemInfo.caption;\r\n\r\n    // Optimistic UI: Update the caption in the UI Model before the change is\r\n    // completed in the server\r\n    itemInfo.caption = newCaption;\r\n\r\n    // Due to performance reasons, we don't make a shallow copy of the\r\n    // treeModel to force a re-render\r\n    itemRef.caption = newCaption;\r\n\r\n    const promise = this.modifyItemCaptionCallback(itemId, newCaption);\r\n\r\n    promise.then(status => {\r\n      if (status.success) {\r\n        this.#sortItems(itemUIModel.parentItem.items);\r\n\r\n        // Update filters\r\n        this.#scheduleFilterProcessing();\r\n\r\n        // Force re-render\r\n        forceUpdate(this);\r\n      } else {\r\n        itemRef.caption = oldCaption;\r\n        itemInfo.caption = oldCaption;\r\n\r\n        // Do something with the error message\r\n      }\r\n    });\r\n  }\r\n\r\n  @Listen(\"openReference\", { capture: true })\r\n  onOpenReference(\r\n    event: ChTreeViewItemCustomEvent<TreeViewItemOpenReferenceInfo>\r\n  ) {\r\n    event.stopPropagation();\r\n    this.itemOpenReference.emit(event.detail);\r\n  }\r\n\r\n  #handleDroppableZoneEnter = (\r\n    event: ChTreeViewCustomEvent<TreeViewDropCheckInfo>\r\n  ) => {\r\n    if (!this.checkDroppableZoneCallback) {\r\n      return;\r\n    }\r\n    event.stopPropagation();\r\n\r\n    // Suppose the request is made immediately by executing the callback\r\n    const requestTimestamp = new Date().getTime();\r\n\r\n    const dropInformation = event.detail;\r\n    const promise = this.checkDroppableZoneCallback(dropInformation);\r\n\r\n    promise.then(validDrop => {\r\n      this.updateValidDropZone(\r\n        requestTimestamp,\r\n        dropInformation.newContainer.id,\r\n        dropInformation.draggedItems,\r\n        dropInformation.dropType,\r\n        validDrop\r\n      );\r\n    });\r\n  };\r\n\r\n  #handleSelectedItemsChange = (\r\n    event: ChTreeViewCustomEvent<Map<string, TreeViewItemSelectedInfo>>\r\n  ) => {\r\n    event.stopPropagation();\r\n    const itemsToProcess = new Map(event.detail);\r\n\r\n    const previousSelectedItems = this.#selectedItems;\r\n\r\n    // Remove no longer selected items\r\n    previousSelectedItems.forEach(selectedItemId => {\r\n      const itemUIModel = this.#flattenedTreeModel.get(selectedItemId).item;\r\n      const itemIsStillSelected = itemsToProcess.get(selectedItemId);\r\n\r\n      // The item does not need to be added. Remove it from the processed list\r\n      if (itemIsStillSelected) {\r\n        itemUIModel.expanded = itemIsStillSelected.expanded; // Update expanded state\r\n        itemsToProcess.delete(selectedItemId);\r\n      }\r\n      // The item must be un-selected in the UI Model\r\n      else {\r\n        itemUIModel.selected = false;\r\n        previousSelectedItems.delete(selectedItemId);\r\n      }\r\n    });\r\n\r\n    // Add new selected items\r\n    itemsToProcess.forEach((newSelectedItemInfo, itemId) => {\r\n      const newSelectedItem = this.#flattenedTreeModel.get(itemId).item;\r\n      newSelectedItem.selected = true;\r\n      newSelectedItem.expanded = newSelectedItemInfo.expanded;\r\n\r\n      previousSelectedItems.add(itemId);\r\n    });\r\n\r\n    // Queue re-render to avoid issues about synchronization the Virtual DOM\r\n    // with the real DOM\r\n    forceUpdate(this);\r\n\r\n    this.#updateSelectedItems();\r\n  };\r\n\r\n  #handleExpandedItemChange = (\r\n    event: ChTreeViewCustomEvent<TreeViewItemExpandedInfo>\r\n  ) => {\r\n    const detail = event.detail;\r\n    const itemInfo = this.#flattenedTreeModel.get(detail.id).item;\r\n    itemInfo.expanded = detail.expanded;\r\n  };\r\n\r\n  #handleItemContextmenu = (\r\n    event: ChTreeViewCustomEvent<TreeViewItemContextMenu>\r\n  ) => {\r\n    event.stopPropagation();\r\n    this.itemContextmenu.emit(event.detail);\r\n  };\r\n\r\n  #handleItemsDropped = (\r\n    event: ChTreeViewCustomEvent<TreeViewDataTransferInfo>\r\n  ) => {\r\n    const dataTransferInfo = event.detail;\r\n    const newContainer = dataTransferInfo.newContainer;\r\n    const newParentId = newContainer.id;\r\n\r\n    // Check if the parent exists in the UI Model\r\n    if (!this.#flattenedTreeModel.get(newParentId)) {\r\n      return;\r\n    }\r\n\r\n    const draggedItems: GxDataTransferInfo[] = dataTransferInfo.draggedItems;\r\n\r\n    if (draggedItems.length === 0 || !this.dropItemsCallback) {\r\n      return;\r\n    }\r\n    event.stopPropagation();\r\n\r\n    const promise = this.dropItemsCallback(dataTransferInfo);\r\n    this.waitDropProcessing = true;\r\n\r\n    promise.then(async response => {\r\n      this.dropItems(response.acceptDrop, dataTransferInfo, response.model);\r\n      this.waitDropProcessing = false;\r\n    });\r\n  };\r\n\r\n  #removeAllSelectedItemsExceptForTheLast = (\r\n    currentSelectedItems: Set<string>\r\n  ) => {\r\n    if (currentSelectedItems.size > 1) {\r\n      const selectedItemsArray = [...currentSelectedItems.values()];\r\n      const lastItemIndex = currentSelectedItems.size - 1;\r\n\r\n      // Deselect all items except the last\r\n      for (let index = 0; index < lastItemIndex; index++) {\r\n        const itemId = selectedItemsArray[index];\r\n\r\n        this.#flattenedTreeModel.get(itemId).item.selected = false;\r\n      }\r\n\r\n      // Create a new Set with only the last item\r\n      currentSelectedItems.clear();\r\n      currentSelectedItems.add(selectedItemsArray[lastItemIndex]);\r\n\r\n      this.#scheduleSelectedItemsChange();\r\n    }\r\n  };\r\n\r\n  #moveItemToNewParent =\r\n    (newParentItem: TreeViewItemModel, specificIndex?: { index: number }) =>\r\n    (dataTransferInfo: GxDataTransferInfo, index: number) => {\r\n      const itemUIModelExtended = this.#flattenedTreeModel.get(\r\n        dataTransferInfo.id\r\n      );\r\n      const item = itemUIModelExtended.item;\r\n      const oldParentItem = itemUIModelExtended.parentItem;\r\n\r\n      const oldIndex = oldParentItem.items.findIndex(el => el.id === item.id);\r\n\r\n      // Remove the UI model from the previous parent. The equality function\r\n      // must be by index, not by object reference\r\n      removeElement(oldParentItem.items, oldIndex);\r\n\r\n      // The item must be inserted in a specific position, because the dropMode\r\n      // has \"before\" and \"after\" enabled\r\n      if (specificIndex !== undefined) {\r\n        let newIndex = specificIndex.index + index;\r\n\r\n        // The item is moved in the same parent, so no new items are added\r\n        // The specificIndex must be decreased to balance the increment\r\n        if (oldParentItem.id === newParentItem.id && oldIndex < newIndex) {\r\n          newIndex--;\r\n          specificIndex.index--;\r\n        }\r\n\r\n        insertIntoIndex(newParentItem.items, item, newIndex);\r\n      }\r\n      // Add the UI Model to the new parent by pushing it at the end\r\n      else {\r\n        newParentItem.items.push(item);\r\n      }\r\n\r\n      // Reference the new parent in the item\r\n      itemUIModelExtended.parentItem = newParentItem;\r\n    };\r\n\r\n  #flattenSubModel = (model: TreeViewItemModel) => {\r\n    const items = model.items;\r\n\r\n    if (!items) {\r\n      // Make sure that subtrees don't have an undefined array\r\n      if (model.leaf !== true) {\r\n        model.items = [];\r\n      }\r\n      return;\r\n    }\r\n    this.#sortItems(items);\r\n\r\n    items.forEach(this.#flattenItemUIModel(model));\r\n  };\r\n\r\n  #flattenItemUIModel =\r\n    (parentModel: TreeViewItemModel) => (item: TreeViewItemModel) => {\r\n      this.#flattenedTreeModel.set(item.id, {\r\n        parentItem: parentModel,\r\n        item: item\r\n      });\r\n\r\n      // Add the items that have a checkbox in a separate Map\r\n      if (this.#itemHasCheckbox(item)) {\r\n        this.#flattenedCheckboxTreeModel.set(item.id, {\r\n          parentItem: parentModel,\r\n          item: item\r\n        });\r\n      }\r\n\r\n      // Make sure the properties are with their default values to avoid issues\r\n      // when reusing DOM nodes\r\n      item.expanded ??= DEFAULT_EXPANDED_VALUE;\r\n      item.indeterminate ??= DEFAULT_INDETERMINATE_VALUE;\r\n      item.lazy ??= DEFAULT_LAZY_VALUE;\r\n      item.order ??= DEFAULT_ORDER_VALUE;\r\n      item.selected ??= DEFAULT_SELECTED_VALUE;\r\n\r\n      if (item.selected) {\r\n        this.#selectedItems.add(item.id);\r\n      }\r\n\r\n      this.#flattenSubModel(item);\r\n    };\r\n\r\n  #itemHasCheckbox = (item: TreeViewItemModel) =>\r\n    itemHasCheckbox(item, this.checkbox);\r\n\r\n  #treeHasFilters = () => treeViewHasFilters(this.filterType, this.filter);\r\n\r\n  #sortItems = (model: TreeViewModel) => {\r\n    // Ensure that items are sorted if the dropMode enables it\r\n    if (this.dropMode === \"above\" && this.sortItemsCallback) {\r\n      this.sortItemsCallback(model);\r\n    }\r\n  };\r\n\r\n  #flattenModel = () => {\r\n    this.#flattenedTreeModel.clear();\r\n    this.#flattenedCheckboxTreeModel.clear();\r\n    this.#selectedItems.clear();\r\n\r\n    this.#rootNode = { id: ROOT_ID, caption: ROOT_ID, items: this.model };\r\n    this.#flattenSubModel(this.#rootNode);\r\n\r\n    // Re-sync filters\r\n    this.#scheduleFilterProcessing(\"immediate\");\r\n\r\n    // The model was updated at runtime, so we need to update the references\r\n    // Re-sync selected items\r\n    this.#scheduleSelectedItemsChange();\r\n\r\n    // Re-sync checked items\r\n    this.#scheduleCheckedItemsChange();\r\n  };\r\n\r\n  #filterSubModel = (\r\n    item: TreeViewItemModel,\r\n    filterInfo: TreeViewFilterInfo,\r\n    currentSelectedItems: Set<string>,\r\n    currentCheckboxItems: Map<string, TreeViewItemModelExtended>\r\n  ): boolean => {\r\n    let aSubItemIsRendered = false;\r\n\r\n    // Check if a subitem is rendered\r\n    if (item.leaf !== true && item.items != null) {\r\n      let lastItemId = undefined;\r\n\r\n      item.items.forEach(subItem => {\r\n        const itemSatisfiesFilter = this.#filterSubModel(\r\n          subItem,\r\n          filterInfo,\r\n          currentSelectedItems,\r\n          currentCheckboxItems\r\n        );\r\n        aSubItemIsRendered ||= itemSatisfiesFilter;\r\n\r\n        if (itemSatisfiesFilter) {\r\n          lastItemId = subItem.id;\r\n        }\r\n      });\r\n\r\n      item.lastItemId = lastItemId;\r\n    }\r\n\r\n    // The current item is rendered if it satisfies the filter condition or a\r\n    // subitem exists that needs to be rendered\r\n    const satisfiesFilter =\r\n      aSubItemIsRendered || computeFilter(this.filterType, item, filterInfo);\r\n\r\n    item.render = satisfiesFilter; // Update item render\r\n\r\n    // Update selected and checkbox items\r\n    if (satisfiesFilter && item.id !== ROOT_ID) {\r\n      if (item.selected) {\r\n        currentSelectedItems.add(item.id);\r\n      }\r\n\r\n      if (this.#itemHasCheckbox(item)) {\r\n        const itemUIModel = this.#flattenedTreeModel.get(item.id);\r\n        currentCheckboxItems.set(item.id, itemUIModel);\r\n      }\r\n    }\r\n\r\n    return satisfiesFilter;\r\n  };\r\n\r\n  #scheduleCheckedItemsChange = () => {\r\n    this.#checkedChangeScheduled = true;\r\n  };\r\n\r\n  #scheduleSelectedItemsChange = () => {\r\n    this.#selectedChangeScheduled = true;\r\n  };\r\n\r\n  #updateSelectedItems = () => {\r\n    const selectedItemsInfo = this.#getItemsInfo([\r\n      ...this.#selectedItems.keys()\r\n    ]);\r\n    this.selectedItemsChange.emit(selectedItemsInfo);\r\n  };\r\n\r\n  #updateCheckedItems = () => {\r\n    // New copy of the checked items\r\n    const allItemsWithCheckbox: Map<string, TreeViewItemModelExtended> =\r\n      new Map(this.#flattenedCheckboxTreeModel);\r\n\r\n    // Update the checked value if not defined\r\n    allItemsWithCheckbox.forEach(itemUIModel => {\r\n      itemUIModel.item.checked ??= this.checked;\r\n    });\r\n\r\n    this.checkedItemsChange.emit(allItemsWithCheckbox);\r\n  };\r\n\r\n  #scheduleFilterProcessing = (immediateFilter?: ImmediateFilter) => {\r\n    this.#applyFilters = true;\r\n\r\n    if (immediateFilter !== undefined) {\r\n      this.#immediateFilter ??= immediateFilter;\r\n    }\r\n  };\r\n\r\n  #checkIfThereAreDifferentItemsWithCheckbox = (\r\n    newCheckboxItems: Map<string, TreeViewItemModelExtended>\r\n  ) => {\r\n    if (newCheckboxItems.size !== this.#flattenedCheckboxTreeModel.size) {\r\n      this.#checkedChangeScheduled = true;\r\n    }\r\n    // Check if the items in each Map have the same id\r\n    else {\r\n      this.#flattenedCheckboxTreeModel.forEach((_, itemId) => {\r\n        // Found a value that don't belong to the checkboxItems with filters,\r\n        // schedule checkedItemsChange\r\n        if (!newCheckboxItems.has(itemId)) {\r\n          // Schedule checkedItemsChange\r\n          this.#checkedChangeScheduled = true;\r\n        }\r\n      });\r\n    }\r\n\r\n    // The previous checkbox items will now be the selected items with filter\r\n    this.#flattenedCheckboxTreeModel = newCheckboxItems;\r\n  };\r\n\r\n  #checkIfThereAreDifferentSelectedItems = (newSelectedItems: Set<string>) => {\r\n    if (newSelectedItems.size !== this.#selectedItems.size) {\r\n      this.#selectedChangeScheduled = true;\r\n    }\r\n    // Check if the items in each Set have the same id\r\n    else {\r\n      this.#selectedItems.forEach(itemId => {\r\n        // Found a value that don't belong to the selectedItems with filters,\r\n        // deselect the item\r\n        if (!newSelectedItems.has(itemId)) {\r\n          this.#flattenedTreeModel.get(itemId).item.selected = false;\r\n\r\n          // Schedule selectedItemsChange\r\n          this.#selectedChangeScheduled = true;\r\n        }\r\n      });\r\n    }\r\n\r\n    // The previous selected items will now be the selected items with filter\r\n    this.#selectedItems = newSelectedItems;\r\n  };\r\n\r\n  #updateFilters = () => {\r\n    if (this.filterType === \"none\") {\r\n      // Check if there are more items with checkbox\r\n      const itemsWithCheckbox: Map<string, TreeViewItemModelExtended> =\r\n        new Map();\r\n\r\n      this.#flattenedTreeModel.forEach((itemUIModel, itemId) => {\r\n        if (this.#itemHasCheckbox(itemUIModel.item)) {\r\n          itemsWithCheckbox.set(itemId, itemUIModel);\r\n        }\r\n      });\r\n\r\n      this.#checkIfThereAreDifferentItemsWithCheckbox(itemsWithCheckbox);\r\n      this.#validateCheckedAndSelectedItems();\r\n      // Reset immediate filters, since there are not any filters to process\r\n      this.#immediateFilter = undefined;\r\n\r\n      return;\r\n    }\r\n\r\n    // Remove queued filter processing\r\n    clearTimeout(this.#filterTimeout);\r\n\r\n    const processWithDebounce =\r\n      this.filterDebounce > 0 &&\r\n      (this.filterType === \"caption\" || this.filterType === \"metadata\");\r\n\r\n    const filterFunction = () => {\r\n      const currentSelectedItems: Set<string> = new Set();\r\n      const currentCheckedItems: Map<string, TreeViewItemModelExtended> =\r\n        new Map();\r\n\r\n      if (this.filterType === \"list\") {\r\n        this.#filterListAsSet ??= new Set();\r\n      }\r\n\r\n      this.#filterSubModel(\r\n        {\r\n          id: ROOT_ID,\r\n          caption: ROOT_ID,\r\n          items: this.model\r\n        },\r\n        {\r\n          defaultCheckbox: this.checkbox,\r\n          defaultChecked: this.checked,\r\n          filter: this.filter,\r\n          filterOptions: this.filterOptions,\r\n          filterSet: this.#filterListAsSet\r\n        },\r\n        currentSelectedItems,\r\n        currentCheckedItems\r\n      );\r\n\r\n      // It validates if there are differences between the items with checkbox\r\n      // and the selected items. If there are, emit the corresponding updates.\r\n      this.#checkIfThereAreDifferentSelectedItems(currentSelectedItems);\r\n      this.#checkIfThereAreDifferentItemsWithCheckbox(currentCheckedItems);\r\n\r\n      this.#validateCheckedAndSelectedItems();\r\n    };\r\n\r\n    // Check if should filter with debounce\r\n    if (processWithDebounce && this.#immediateFilter !== \"immediate\") {\r\n      this.#filterTimeout = setTimeout(() => {\r\n        this.#immediateFilter = undefined;\r\n        filterFunction();\r\n        forceUpdate(this); // After the filter processing is completed, force a re-render\r\n      }, this.filterDebounce);\r\n    }\r\n    // No debounce\r\n    else {\r\n      this.#immediateFilter = undefined;\r\n      filterFunction();\r\n    }\r\n  };\r\n\r\n  #validateCheckedAndSelectedItems = () => {\r\n    if (this.#checkedChangeScheduled) {\r\n      this.#updateCheckedItems();\r\n      this.#checkedChangeScheduled = false;\r\n    }\r\n\r\n    if (this.#selectedChangeScheduled) {\r\n      this.#selectedChangeScheduled = false;\r\n\r\n      // Update the selected items in the ch-tree-view control\r\n      this.#updateSelectedItems();\r\n    }\r\n  };\r\n\r\n  #getSelectedItemsCallback = () => {\r\n    const selectedItemsInfo: Map<string, TreeViewItemSelectedInfo> = new Map();\r\n\r\n    this.#selectedItems.forEach(itemId => {\r\n      const itemUIModel = this.#flattenedTreeModel.get(itemId);\r\n      const itemInfo = itemUIModel.item;\r\n\r\n      selectedItemsInfo.set(itemId, {\r\n        id: itemInfo.id,\r\n        expanded: itemInfo.expanded,\r\n        metadata: itemInfo.metadata,\r\n        parentId: itemUIModel.parentItem.id\r\n      });\r\n    });\r\n\r\n    return selectedItemsInfo;\r\n  };\r\n\r\n  connectedCallback() {\r\n    // If the getImagePathCallback was not previously registered\r\n    if (\r\n      !getControlRegisterProperty(\"getImagePathCallback\", \"ch-tree-view-render\")\r\n    ) {\r\n      registerDefaultGetImagePathCallback(this);\r\n    }\r\n\r\n    // Accessibility\r\n    this.el.setAttribute(\"role\", \"tree\");\r\n  }\r\n\r\n  componentWillLoad() {\r\n    this.#flattenModel();\r\n  }\r\n\r\n  componentWillRender() {\r\n    if (\r\n      !this.#selectedChangeScheduled &&\r\n      !this.#checkedChangeScheduled &&\r\n      !this.#applyFilters\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    // If the filters must be applied, we must let the filters decided which\r\n    // are the selected and checked items\r\n    if (this.#applyFilters) {\r\n      this.#updateFilters();\r\n      this.#applyFilters = false;\r\n      return;\r\n    }\r\n\r\n    this.#validateCheckedAndSelectedItems();\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <Host aria-multiselectable={this.multiSelection.toString()}>\r\n        <ch-tree-view\r\n          multiSelection={this.multiSelection}\r\n          selectedItemsCallback={this.#getSelectedItemsCallback}\r\n          waitDropProcessing={this.waitDropProcessing}\r\n          onDroppableZoneEnter={this.#handleDroppableZoneEnter}\r\n          onExpandedItemChange={this.#handleExpandedItemChange}\r\n          onItemContextmenu={this.#handleItemContextmenu}\r\n          onItemsDropped={this.#handleItemsDropped}\r\n          onSelectedItemsChange={this.#handleSelectedItemsChange}\r\n          ref={el => (this.#treeRef = el)}\r\n        >\r\n          {this.model.map((itemModel, index) =>\r\n            this.renderItem(\r\n              itemModel,\r\n              this,\r\n              this.#treeHasFilters(),\r\n              this.showLines !== \"none\" && index === this.model.length - 1,\r\n              0,\r\n              this.dropMode !== \"above\" && this.dropDisabled !== true,\r\n              this.useGxRender\r\n            )\r\n          )}\r\n        </ch-tree-view>\r\n      </Host>\r\n    );\r\n  }\r\n}\r\n"],"mappings":"iYAAO,MAAMA,EAAe,CAC1BC,EACAC,EACAC,EACAC,KAEA,MAAMC,EAAiBJ,EAAMK,QAAUJ,EAAUK,wBAAwBC,IAEzE,MAAMC,EAAkBP,EAAUQ,aAClC,MAAMC,EAAgBN,GAAkBD,EACxC,MAAMQ,EAAmBP,EAAiBI,EAAkBL,EAE5D,GAAIO,GAAiBC,EAAkB,CACrC,MAAMC,EAAeF,EACjBN,EAAiBD,EACjBC,GAAkBI,EAAkBL,GAGxCF,EAAUY,WAAaD,EAAeV,C,GClB1C,MAAMY,EAAc,8pBACpB,MAAAC,EAAeD,ECuCf,MAAME,EAAqB,oBAC3B,MAAMC,EAAqB,oBAC3B,MAAMC,EAAgB,eAGtB,MAAMC,EAAuC,WAC7C,MAAMC,EAAsC,UAC5C,MAAMC,EAA+C,mBACrD,MAAMC,EAAoC,QAI1C,MAAMC,EAAiBC,GACrB,GAAGR,SAA0BQ,MAE/B,MAAMC,EAAc,aAEpB,MAAMC,EAAiB,YACvB,MAAMC,EAAe,UACrB,MAAMC,EAAW,KAIjB,MAAMC,EAAcC,GAClBA,EAAQC,QAAQC,gBAAkBf,EAEpC,MAAMgB,EAAcH,GAClBA,EAAQC,QAAQC,gBAAkBhB,EAEpC,MAAMkB,EAAwBC,GAC5BA,IAAmBnB,GACnBmB,IAAmBlB,EAErB,MAAMmB,EAAqB,IACzBC,IAAoBC,KAAKL,GAE3B,MAAMM,EAAwBC,GAC5BA,IAAaA,EAASC,QAExB,MAAMC,EAAsB,CAC1BC,EACAC,EACAC,IAEA,qBAAqBF,kBAA+BG,KAAKC,UACvDH,mBACgBC,KAEpB,MAAMG,EAA6B,iCACnC,MAAMC,EAA6B,iCAEnC,IAAIC,EAAS,E,MAUAC,EAAU,M,uTAwEY,M,oBAEP,M,kBAEF,M,oBAKmB,M,0BAMK,I,6DAcD,K,wBAMA,K,CAzG/CC,GAEI,CACF1B,CAACA,GAAiB1B,IAChB,MAAMwC,EAAWJ,IAEjB,IAAKG,EAAqBC,GAAW,CACnC,M,CAEFxC,EAAMqD,iBACNb,EAASc,cAAcC,EAAsBvD,GAAO,EAGtD2B,CAACA,GAAe3B,IACd,MAAMwC,EAAWJ,IAEjB,IAAKG,EAAqBC,GAAW,CACnC,M,CAEFxC,EAAMqD,iBACNb,EAASgB,kBAAkBD,EAAsBvD,GAAO,EAG1D4B,CAACA,GAAW5B,IACV,MAAMwC,EAAWJ,IAEjB,IAAKI,IAAaA,EAASiB,SAAU,CACnC,M,CAGFzD,EAAMqD,iBACNb,EAASC,QAAU,IAAI,GAI3BiB,GAAyB,MACzBC,GAAc,KACdC,GAEAC,GAOAC,GAAoE,IAAIC,IACxEC,GACApB,GAMAqB,GAGAC,GACAC,GAMAC,GACAC,GAAwB,GACxBC,GAA8B,G,wBA6CrBC,mBAKAC,mBAKAC,gBAKAC,aAKAC,oBAKT,aAAAC,CAAc5E,GACZ,MAAMwC,EAAYxC,EAAM6E,OAAuBC,QAAQ9D,GAEvD,IAAKwB,EAAU,CACb,M,CAEFxC,EAAMqD,iBAEN0B,KAAKN,gBAAgBO,KAAK,CACxBC,GAAIzC,EAASyC,GACbC,QAAS1C,EACT2C,SAAU3C,EAAS2C,SACnBC,iBAAkBpF,G,CAMtB,SAAAqF,CAAUrF,GACR,MAAMsF,EAAaP,MAAK3B,EAAepD,EAAMuF,KAE7C,GAAID,EAAY,CACdA,EAAWtF,E,EAQf,WAAAwF,CAAYxF,GAEV+E,MAAKjB,EAAyB2B,QAG9B,MAAMC,EAAO1F,EAAM2F,aAAaC,QAAQnE,GACxC,GAAIiE,IAAS,GAAI,CACf,M,CAGF,IAEE,MAAMG,EAAY/C,KAAKgD,MAAMJ,GAE7BX,MAAKnC,EAAgBiD,EACrBd,KAAKgB,sBAAwB,KAC7BhB,MAAKf,GAAsB,IAAIgC,MAAOC,S,CACtC,M,EAMJ,SAAAC,GACEnB,KAAKgB,sBAAwB,K,CAI/B,WAAAI,CAAYnG,GACV+E,MAAKqB,EAAsB,KAAM,MACjCpG,EAAMqG,kBAGN,MAAMC,EAActG,EAAM6E,OAG1B,MAAM0B,EAAyBD,EAAYvE,QAAQC,cAGnD,IAAKE,EAAqBqE,GAAyB,CACjD,M,CAGF,MAAMC,EAAmBD,IAA2BvF,EACpD,MAAMyF,EAAuB1B,MAAK2B,EAChCJ,EACAE,GAEF,MAAMG,EAAiBF,EAAqBjE,SAC5C,MAAMK,EAAW4D,EAAqB5D,SAEtCkC,MAAKZ,EAAuBmC,EAG5B,GAAIE,EAAkB,CACpBzB,MAAK6B,EAA2BD,E,CAGlC,GAAI5B,MAAK8B,EAAoB7G,EAAO2G,EAAgB9D,KAAcvB,EAAO,CACvEgF,EAAYQ,UAAY,O,EAK5B,WAAAC,CAAY/G,GACV,MAAMgH,EAAgBhH,EAAM6E,OAI5B,IAAK3C,EAAqB8E,EAAcjF,QAAQC,eAAgB,CAC9D,M,CAGFgF,EAAcF,UAAY,OAE1B,GAAI7E,EAAW+E,GAAgB,CAC7BjC,MAAKqB,EAAsBY,E,EAI/BN,GAAgC,CAC9BJ,EACAE,KAMA,GAAIA,EAAkB,CACpB,MAAO,CACLhE,SAAU8D,EACVzD,SAAU,Q,CAKd,MAAMA,EACJyD,EACAW,KAEF,MAAO,CAELzE,SAAWK,IAAa,SACpByD,EAAYY,mBACZZ,EAAYa,uBAChBtE,SAAWyD,EAA0CW,KACtD,EAGHb,GAAwB,CACtBgB,EACAC,EAAa,SAEb,GAAItC,MAAKZ,IAAyBiD,GAAsBC,EAAY,CAClEC,aAAavC,MAAKlB,GAClBkB,MAAKZ,EAAuB,I,GAKhC,MAAAoD,CAAOvH,GACLA,EAAMqG,kBAENtB,MAAKqB,EAAsB,KAAM,MACjC,MAAME,EAActG,EAAM6E,OAG1B,MAAM0B,EAAyBD,EAAYvE,QAAQC,cAGnD,IAAKE,EAAqBqE,GAAyB,CACjD,M,CAIFD,EAAYQ,UAAY,OAExB,MAAMN,EAAmBD,IAA2BvF,EACpD,MAAMyF,EAAuB1B,MAAK2B,EAChCJ,EACAE,GAEF,MAAMG,EAAiBF,EAAqBjE,SAC5C,MAAMK,EAAW4D,EAAqB5D,SAItC,GAAIkC,MAAK8B,EAAoB7G,EAAO2G,EAAgB9D,KAAcvB,EAAO,CACvE,M,CAIF,MAAMsB,EAAqCE,KAAKgD,MAC9C9F,EAAM2F,aAAaC,QAAQnE,IAG7BsD,KAAKL,aAAaM,KAAK,CACrBwC,aAAc,CACZvC,GAAI0B,EAAe1B,GACnBE,SAAUwB,EAAexB,UAE3BzB,sBAAuBqB,MAAKrB,EAC5Bd,aAAcA,EACd6E,kBAAmB1C,KAAK2C,eACxB7E,SAAUA,G,CAKd,eAAA8E,CAAgB3H,GAEdA,EAAMqG,kBAENuB,SAASC,iBAAiB,WAAY9C,MAAK+C,EAAgB,CACzDC,QAAS,OAGXhD,MAAKb,EAAsBlE,EAAM6E,OACjC,MAAMmD,EAAuBjD,MAAKkD,EAChCjI,EAAMkI,QAGR,IAAKF,EAAsB,CAGzBhI,EAAMkI,OAAOC,UAAUxC,aAAayC,cAAgB,OACpD,M,CAGFrD,KAAK2C,eAAiB,KAEtB,GAAI3C,KAAKsD,mBAAoB,CAC3BtD,MAAKuD,G,EAKT,aAAAC,GACExD,KAAK2C,eAAiB,MAEtBE,SAASY,oBAAoB,WAAYzD,MAAK+C,EAAgB,CAC5DC,QAAS,OAIXhD,MAAK0D,G,CAIP,oBAAAC,CAAqB1I,GACnBA,EAAMqG,kBACN,MAAMsC,EAAmB3I,EAAMkI,OAC/B,MAAMU,EAAoB7D,KAAK8D,wBAI/B,IAAKF,EAAiBG,iBAAmB/D,KAAKgE,eAAgB,CAE5DH,EAAkBnD,O,CAIpB,GAAIkD,EAAiBK,SAAU,CAC7BJ,EAAkBK,IAAIN,EAAiB1D,GAAI0D,E,KACtC,CACLC,EAAkBM,OAAOP,EAAiB1D,G,CAI5CF,KAAKJ,oBAAoBK,KAAK4D,E,CAOhC,uBAAMO,CAAkB3H,GACtB4H,GAAS,KACP,MAAMlE,EAAUH,KAAKsE,GAAGC,cAAc/H,EAAcC,IACpD,IAAK0D,EAAS,CACZ,M,CAGFqE,GAAU,KACRrE,EAAQsE,gBAAgB,GACxB,G,CAYN,yBAAMC,CACJC,EACA/G,EACAC,EACAC,EACA8G,GAEA,IACG5E,KAAKgB,uBACN2D,GAAoB3E,MAAKf,EACzB,CACA,M,CAGF,MAAM4F,EAAmBlH,EACvBC,EACAC,EACAC,GAEFkC,MAAKjB,EAAyBmF,IAC5BW,EACAD,EAAYrI,EAAQF,GAKtB,IAAKuI,IAAc5E,MAAKZ,EAAsB,CAC5C,M,CAGF,MAAM3C,EAAaK,EAAWkD,MAAKZ,GAC9BY,MAAKZ,EAAmD3C,WACzDuD,MAAKZ,EAAqBc,GAE9B,MAAM4E,EACJrI,IAAemB,EAEjB,GAAIkH,EAAyC,CAC3C9E,MAAKZ,EAAqB2C,UAAY,O,EAI1CgD,GAAsBC,GACpBhF,KAAKsE,GAAGC,cAAc/H,EAAcwI,IAEtClD,GAAsB,CACpB7G,EACA2G,EACA9D,KAEA,MAAMmH,EAAWtH,EACfiE,EAAe1B,GACfF,MAAKnC,EACLC,GAEF,IAAIoH,EAAqBlF,MAAKjB,EAAyBoG,IAAIF,GAI3D,GACEC,IAAuB5I,IACtBsF,EAAewD,WACfxD,EAAeyD,YAChB,CACAH,EAAqB,I,CAIvB,GAAIA,GAAsB,KAAM,CAC9B,OAAOA,C,CAaT,GACEjK,EAAM2F,aAAayC,gBAAkB,QACpCvF,IAAa,SAAW8D,EAAe0D,cACvCtF,KAAK2C,iBACH3C,MAAKV,EAAYiG,SAAS3D,EAAe1B,KACxCF,MAAKT,EAAkBgG,SAAS3D,EAAe1B,KACnD,CACAF,MAAKjB,EAAyBmF,IAAIe,EAAU5I,GAC5C,OAAOA,C,CAIT,GACEyB,IAAa,UACZ8D,EAAewD,UAAYxD,EAAeyD,aAC3C,CACArF,MAAKjB,EAAyBmF,IAAIe,EAAU3I,GAC5C,OAAOA,C,CAIT0D,MAAKjB,EAAyBmF,IAAIe,EAAU7I,GAC5C4D,KAAKR,mBAAmBS,KAAK,CAC3BwC,aAAc,CACZvC,GAAI0B,EAAe1B,GACnBE,SAAUwB,EAAexB,UAE3BvC,aAAcmC,MAAKnC,EACnBC,SAAUA,IAEZ,OAAO1B,CAAQ,EAGjByF,GAA8BI,IAC5B,GAAIA,EAAcuD,MAAQvD,EAAcwD,SAAU,CAChD,M,CAGFzF,MAAKlB,EAAsB4G,YAAW,KACpCzD,EAAcwD,SAAW,KACzBzF,KAAKP,mBAAmBQ,KAAK,CAAEC,GAAI+B,EAAc/B,GAAIuF,SAAU,MAAO,GACrEzF,KAAK2F,qBAAqB,EAG/B5C,GAAkB9H,IAChB,MAAM2K,EACH3K,EAAM6E,OAAuBC,QAAQ5D,KAAmB,KAK3D,GAAIyJ,EAAiB,CACnB3K,EAAM4K,0B,CAGR5K,EAAMqD,iBACN0B,MAAKnB,EAAiB5D,EAEtB+E,MAAK8F,EAAkB7K,GAEvB,IAAK+E,MAAKpB,EAAa,CACrB,M,CAEFoB,MAAKpB,EAAc,MAEnBmH,uBAAsB,KACpB/F,MAAKpB,EAAc,KAEnBoB,KAAKsE,GAAG0B,MAAMC,YACZhI,EACA,GAAG+B,MAAKnB,EAAeqH,aAEzBlG,KAAKsE,GAAG0B,MAAMC,YACZ/H,EACA,GAAG8B,MAAKnB,EAAevD,YACxB,GACD,EAGJwK,GAAqB7K,IAEnB,IAAKA,EAAMkL,eAAeZ,SAASvF,KAAKsE,IAAK,CAC3C,M,CAKF,MAAM8B,EAAanL,EAAMkL,eAAe5I,MAAMR,IAC5C,IAAKA,EAAQC,QAAS,CACpB,OAAO,K,CAGT,OACEG,EAAqBJ,EAAQC,QAAQC,gBACrCF,EAAQgD,QAAQ5D,KAAmB6D,KAAKsE,EAAE,IAI9C,MAAM7C,EACJ2E,EAAWpJ,QAAQC,gBAAkBhB,EACvC,MAAMyF,EAAuB1B,MAAK2B,EAChCyE,EACA3E,GAEF,MAAMG,EAAiBF,EAAqBjE,SAC5C,MAAMK,EAAW4D,EAAqB5D,SAEtC,MAAMoH,EAAqBlF,MAAK8B,EAC9B7G,EACA2G,EACA9D,GAGF,GACEoH,IAAuB7I,GACvB6I,IAAuB5I,EACvB,CACArB,EAAM2F,aAAayF,WAAa,M,GAIpC3C,GAAkB,KAChB1D,MAAKV,EAAc,GACnBU,MAAKT,EAAoB,EAAE,EAW7B2D,GACE7D,IAEA,MAAMiH,EAAiBjH,EAASkH,KAEhC,MAAM1C,EAAoB7D,KAAK8D,wBAC/B,MAAM0C,EAA0B3C,EAAkB4C,IAAIH,EAAepG,IACrEF,MAAKrB,EAAyB6H,EAE9B,IAAIE,EAAyC,GAC7C,IAAIC,EAEJ,GAAIH,EAAyB,CAC3B,MAAMI,EAAmB,IAAI/C,EAAkBgD,QAC/C,MAAMC,EAAqB,IAAIjD,EAAkBkD,UACjD,MAAMC,EAAoBJ,EAAiBK,OAE3CN,EAA2BG,EAAmBI,OAC5C5C,IAAOtE,MAAK+E,EAAoBT,EAAGpE,IAAIiH,eAGzCnH,MAAKV,EAAcsH,EACnBF,EAAmBI,EAAmBM,KAAI9C,IAAE,CAC1CpE,GAAIoE,EAAGpE,GACPE,SAAUkE,EAAGlE,aAGfJ,MAAKX,EACH2H,IAAsB,EAClBV,EAAee,QACfL,EAAkBM,U,KACnB,CACLX,GAA4BL,EAAea,aAC3CT,EAAmB,CACjB,CAAExG,GAAIoG,EAAepG,GAAIE,SAAUkG,EAAelG,WAEpDJ,MAAKV,EAAc,CAACgH,EAAepG,IACnCF,MAAKX,EAAYiH,EAAee,O,CAGlCrH,MAAKuH,EAAkCf,GAGvC,MAAM7F,EAAO5C,KAAKC,UAAU0I,GAC5BrH,EAAS+D,UAAUxC,aAAa4G,QAAQ9K,EAAaiE,GAKrD,OAAOgG,CAAwB,EAGjCpD,GAA2B,KACzB,IAAKvD,KAAK2C,iBAAmB3C,MAAKnB,EAAgB,CAChD,M,CAGFkH,uBAAsB,KACpB/K,EAAagF,MAAKnB,EAAgBmB,KAAKsE,GAAI,GAAI,IAE/CyB,sBAAsB/F,MAAKuD,EAAyB,GACpD,EAGJgE,GAAqC5I,IACnC,IAAKA,EAAuB,CAC1B,MAAM8I,EAAqBzH,MAAKb,EAAoBuI,cAEpD,GAAID,EAAmBzK,QAAQC,gBAAkBhB,EAAoB,CACnE+D,MAAKT,EAAkBoI,KAAKF,EAAmBvH,G,CAGjD,M,CAIF,MAAM2D,EAAoB7D,KAAK8D,wBAC/BD,EAAkB+D,SAAQC,IACxB,MAAMC,EAAWD,EAAaC,SAG9B,GAAIA,IAAa,GAAI,CACnB9H,MAAKT,EAAkBoI,KAAKG,E,IAE9B,EAGJ,iBAAAC,GACE/H,MAAKd,EAAc,mBAAmBf,MAEtC6J,EAAsBhI,MAAKd,GAAc+I,IACvCjI,KAAKkI,aAAeD,CAAG,IAIzBjI,KAAKkI,aAAeC,G,CAGtB,oBAAAC,GACEC,EAAwBrI,MAAKd,GAE7Bc,MAAK0D,IAGL1D,KAAKwD,e,CAGP,MAAA8E,GACE,OACEC,EAACC,EAAI,CAAAhI,IAAA,2CACHiI,MAAO,CACL,gBAAiBzI,KAAKgB,sBACtB,qBAAsBhB,KAAKgB,sBAC3B,0BACEhB,KAAK2C,gBAAkB3C,MAAKrB,EAC9B,gBAAiBqB,KAAKkI,aACtB,0BAA2BlI,KAAK0I,oBAElCC,YAAaC,EAA2BC,cAExCN,EAAA,QAAA/H,IAAA,6CAECR,KAAK2C,gBACJ4F,EAAA,QAAA/H,IAAA,yDACc,OACZiI,MAAM,YACNK,KAAMF,EAA2BC,cAEhC7I,MAAKX,G,aC71BX,MAAM0J,EAAgB,EACtB,MAAMC,EAAgB,KAGtB,MAAMC,EAAwBC,GACnCA,EACIC,EAAgCC,WAChCD,EAAgCE,UAE/B,MAAMC,GAA2B7D,GACtCA,EACI0D,EAAgCI,SAChCJ,EAAgCK,UAE/B,MAAMC,GAAsB,CACjCC,EACAC,EACAC,EACAC,KAEA,IAAIC,EAAoB,MACxB,IAAIC,EAAqB,MACzB,IAAIC,EAAqB,MAEzBN,EAAM9B,SAAQ5C,IACZ,MAAMiF,EAAcN,EAAmBxE,IAAIH,GAE3C,GAAIiF,EAAa,CACf,MAAMC,EAAWD,EAAYE,KAC7B,MAAMC,EAAcH,EAAYI,WAAWX,MAG3C,GAAIQ,EAAS1E,OAAS,MAAQ0E,EAASR,OAAOzC,OAAS,EAAG,CACxD,MAAMqD,EAAaJ,EAASR,MAAMtC,KAAI+C,GAAQA,EAAKjK,KAEnDuJ,GACEa,EACAX,EACAC,EACAC,E,CAKJC,IAAsBH,EAAmBxF,OAAOa,GAChD+E,IAAuBH,EAA2BzF,OAAOa,GACzDgF,IAAuBH,EAAc1F,OAAOa,GAC5CuF,EACEH,EACAA,EAAYI,WAAUzN,GAAWA,EAAQmD,KAAO8E,I,KAKtD,MAAO,CACL8E,kBAAmBA,EACnBC,mBAAoBA,EACpBC,mBAAoBA,EACrB,EAGH,MAAMS,GAAwBC,GAC5B,IAAIC,SAAQC,GAAWA,EAAQF,KAO1B,MAAMG,GAAsB,CACjCC,EACAnB,KAEA,MAAMM,EAAcN,EAAmBxE,IAAI2F,GAE3C,IAAKb,EAAa,CAChB,OAAOQ,GAAkB,M,CAG3B,IAAIM,EAAcd,EAAYI,WAG9B,MAAOU,GAAeA,EAAY7K,IAAM,KAAM,CAE5C6K,EAAYtF,SAAW,KAEvB,MAAMuF,EAAqBrB,EAAmBxE,IAAI4F,EAAY7K,IAC9D6K,EAAcC,EAAmBX,U,CAGnC,OAAOI,GAAkB,KAAK,EASzB,MAAMQ,GAAwBC,MACnCC,EACAL,EACAnB,EACAyB,EACAC,KAIA,MAAMC,EAA0B,IAAIC,IAAIT,GAAMU,OAASV,EAAK7D,OAE5D,GAAIqE,EAAyB,CAC3B,OAAO,K,CAGT,MAAMG,EAAwBX,EAAK7D,OAAS,EAC5C,IAAIyE,EAAyBD,EAG7B,IAAIxB,EAAcN,EAAmBxE,IAAI2F,EAAKY,IAG9C,MAAOzB,IAAgB0B,WAAaD,EAAyB,EAAG,CAC9DA,IACAzB,EAAcN,EAAmBxE,IAAI2F,EAAKY,G,CAG5C,IAAKzB,EAAa,CAChB,OAAO,K,CAGT,MAAM2B,EAAwBF,EAI9B,MAAOA,GAA0B,EAAG,CAClC,GAAI/B,EAAmBxE,IAAI2F,EAAKY,MAA6BC,UAAW,CACtE,OAAO,K,CAGTD,G,CAKF,GAAI/B,EAAmBxE,IAAI2F,EAAK,IAAIT,aAAee,EAAU,CAC3D,OAAO,K,CAQT,MAAMS,EACJD,IAA0BH,EAC5B,MAAMK,EACJD,IAAgCR,EAElC,GAAIS,EAA6B,CAC/B,OAAO,K,CAIT,IAAIC,EAAgBpC,EAAmBxE,IACrC2F,EAAKc,IACLvB,WAEF,MAAO0B,IAAkBX,EAAU,CACjCW,EAActG,SAAW,KACzBsG,EAAgBpC,EAAmBxE,IAAI4G,EAAc7L,IAAImK,U,CAG3D2B,EAAYb,GAIZ,IAAIc,EAAsBL,EAG1B,MAAOK,EAAsBR,EAAuB,CAClD,MAAMzG,EAAS8F,EAAKmB,GAEpB,MAAMhC,EAAcN,EAAmBxE,IAAIH,GAI3C,IAAKiF,EAAa,CAChB,OAAO,K,CAGT,MAAMC,EAAWD,EAAYE,KAG7B,GAAID,EAAS1E,OAAS,KAAM,CAC1B,OAAO,K,CAIT0E,EAAS7E,YAAc,KACvB6E,EAASzE,SAAW,KACpByE,EAASgC,KAAO,MAChBF,EAAYb,GAEZ,MAAMgB,QAAed,EAA0BrG,SACzCmG,EAAWiB,gBAAgBpH,EAAQmH,GAEzCF,G,CAGF,OAAO,IAAI,EC1Nb,MAAMI,GAAkB,irBACxB,MAAAC,GAAeD,GCIf,MAAMnQ,GAAqB,oB,MAOdqQ,GAAc,M,wCAKe,O,WAKPxD,E,oCAU2B,Q,CAE5D,MAAAT,GACE,MAAMkE,EAAexM,KAAKyM,QAAU1D,EACpC,MAAM2D,EAAYzD,EAAqBjJ,KAAKyM,MAAQ,IAAM,GAE1D,OACElE,EAACC,EAAI,CAAAhI,IAAA,2CACHiI,MAAO,CACL,CAAC,MAAQiE,GAAYF,EACrB,CAACtQ,GAAqB,gBAAiB8D,KAAK+B,YAAc,SAE5DiE,MAAO,CAAE,UAAW,GAAGhG,KAAKyM,U,eC5CpC,MAAME,GAAkB,y9LACxB,MAAAC,GAAeD,GCyDf,IAAIE,GAEJ,MAAMC,GACJ,2CAGF,MAAM7Q,GAAqB,oBAE3B,MAAM8Q,GAA4B,UAAU9Q,KAC5C,MAAM+Q,GAAyB,GAAG/Q,qBAClC,MAAMgR,GAAgB,UAAUhR,gBAGhC,MAAMiR,GAAkB,iBAGxB,MAAMC,GACJ,GAAGhE,EAAgCiE,SAASjE,EAAgCkE,cAC9E,MAAMC,GACJ,GAAGnE,EAAgCiE,SAASjE,EAAgCoE,YAG9E,MAAMC,GAAgB,aACtB,MAAMC,GAAY,QAClB,MAAMC,GAAa,S,MA0DNC,GAAc,M,gcA4BY,M,aAMa,M,kBAqBT,M,cAOa,M,kBAMb,M,kBAMA,M,eAMO,O,iBAMT,M,qCAWJ,M,yCAoCQ,a,sBAWzC,a,mBAMwC,K,cAMN,M,kDAwBC,M,cAiBD,M,UAMH,M,WAKA5E,E,mBAKQ,M,gFAyBU,M,4BAMA,K,eAMP,O,6CAyBC,a,sBAOA,K,CAzR7C6E,GAMAC,GAAwB,MAExBC,GACAC,GACAC,GACAC,GAGAC,GACAC,G,wBAoBA,0BAAAC,CAA2BC,GACzB,IAAKrO,KAAKsO,kBAAoBtO,KAAKwF,MAAQxF,MAAK6N,EAAuB,CACrE7N,MAAK6N,EAAwB,MAC7B,M,CAGF,MAAMU,EAAYvO,MAAKwO,IAEvBD,EAAU3G,SAAQnK,IAChB,GAAIA,EAASgR,UAAYJ,GAAY5Q,EAASiR,gBAAkB,MAAO,CACrEjR,EAASkR,cAAcN,EAAU,M,KAqDvC,cAAAO,CAAeC,GACb,IAAKA,EAAW,CACd,M,CAGFhM,SAASC,iBAAiB,QAAS9C,MAAK8O,EAAwB,CAC9D9L,QAAS,OAIXwB,GAAU,KACRuB,uBAAsB,KACpB,GAAI/F,MAAKmO,EAAW,CAClBnO,MAAKmO,EAAUY,O,IAEjB,G,CASN,gBAAAC,CAAiBC,GAGfjP,KAAKkP,MAAMC,UAAYF,EACvBjP,MAAKoP,EAAc,M,CA+BrB,eAAAC,CAAgBC,GAGd5J,YAAW,KACT1F,MAAKuP,EAAeD,EAAW,G,CAUnC,2BAAAE,GACExP,MAAKoP,EAAc,SACnBpP,MAAKoP,EAAc,M,CAQrB,eAAAK,CAAgBC,GACd,GAAIA,GAAc1P,KAAK2P,UAAW,CAEhC5J,uBAAsB,KACpB/F,MAAK4P,GAAoB,G,KAEtB,CACL5P,MAAK6P,G,EA0CT,YAAAC,CAAaC,GACX/P,MAAKgQ,EAAgBD,E,CAoBvB,gBAAAE,CAAiBC,GACf,GAAIA,GAAgBlQ,KAAKmQ,SAAU,CACjCnQ,MAAK4P,G,KACA,CACL5P,MAAK6P,G,EAST,kBAAAO,CAAmBnB,GAGjBjP,KAAKkP,MAAMmB,YAAcpB,EACzBjP,MAAKoP,EAAc,Q,CAerB,4BAAAkB,CAA6BC,GAC3B,GAAIA,EAA0B,CAC5BvQ,KAAKsE,GAAGxB,iBACN,iBACA9C,MAAKwQ,E,KAEF,CACLxQ,KAAKsE,GAAGb,oBACN,iBACAzD,MAAKwQ,E,EAQFC,eAMAC,qBAKAC,cAKAC,YAKAxE,gBAKAyE,cAMAC,cAMAC,mBAOT,mBAAMxS,CAAcwF,GAElB,IAAK/D,KAAKwF,MAAQxF,KAAKyF,SAAU,CAC/B,MAAMuL,EAAUhR,KAAKsE,GAAGC,cACtByI,IAKF,GAAIgE,EAAS,CACXA,EAAQC,SAASlN,GACjB,M,EAKJ/D,KAAKkR,iBAAiBnN,E,CAOxB,sBAAMmN,CAAiBnN,GACrB,MAAMoN,EAAkBnR,KAAKsE,GAC1BnC,mBAGH,GAAIgP,EAAiB,CAEnB,GAAIA,EAAgBC,SAAU,CAC5BD,EAAgB5S,cAAcwF,E,KACzB,CACLoN,EAAgBF,SAASlN,E,CAE3B,M,CAIF,GAAI/D,KAAKyM,QAAU1D,EAAe,CAChC,M,CAIF,MAAMsB,EAAarK,KAAKsE,GAAGoD,cAC3B2C,EAAW6G,iBAAiBnN,E,CAQ9B,uBAAMtF,CAAkBsF,GACtB,MAAMsN,EAAsBrR,KAAKsE,GAC9BlC,uBAGH,GAAIiP,EAAqB,CACvBA,EAAoBC,cAAcvN,GAClC,M,CAIF,GAAI/D,KAAKyM,QAAU1D,EAAe,CAChC,M,CAIF,MAAMsB,EAAarK,KAAKsE,GAAGoD,cAG3B,GAAI2C,EAAW+G,SAAU,CACvB/G,EAAW5L,kBAAkBsF,GAC7B,M,CAGFsG,EAAW4G,SAASlN,E,CAQtB,mBAAMuN,CAAcvN,GAElB,IAAK/D,KAAKwF,MAAQxF,KAAKyF,SAAU,CAC/B,MAAM8L,EAAcvR,KAAKsE,GAAGC,cAC1B0I,IAKF,GAAIsE,EAAa,CACfA,EAAYD,cAAcvN,GAC1B,M,EAKJ,GAAI/D,KAAKoR,SAAU,CACjBpR,KAAKvB,kBAAkBsF,GACvB,M,CAIF/D,KAAKiR,SAASlN,E,CAOhB,cAAMkN,CAASlN,GACb/D,MAAKkO,EAAWa,QAGhB,IAAKhL,EAAgB,CACnB/D,MAAKwR,G,EAQT,mBAAM7C,CAAc8C,EAAqBC,GACvC1R,KAAKyO,QAAUgD,EACfzR,KAAK0O,cAAgBgD,EAIrB1R,KAAK0Q,qBAAqBzQ,KAAK,CAC7BC,GAAIF,KAAKsE,GAAGpE,GACZuO,QAASgD,EACT/C,cAAegD,G,CAInBtC,GAAiBuC,IACf,GACGA,IAAc,UAAY3R,KAAKqQ,aAC/BsB,IAAc,QAAU3R,KAAKmP,UAC9B,CACA,M,CAGF,MAAMyC,EACJ5R,KAAK4R,sBAAwB/E,GAE/B,MAAMgF,EAAMD,EAAqB5R,KAAKkP,MAAOyC,GAC7C,MAAMG,SAAuBD,IAAQ,SACrC,MAAME,EAA+BD,EACjC,CAAEE,KAAMH,GACRA,GAAKI,QAET,GAAIN,IAAc,QAAS,CACzB,IAAKE,EAAK,CACR7R,MAAK8N,EAAc,KACnB9N,MAAK+N,EAAsB,KAC3B,M,CAKF,GAAI+D,GAAiB9R,KAAKkS,eAAiB,MAAO,CAChDH,EAAUC,KAAO,QAAQD,EAAUC,Q,KAGhC,CACHhS,MAAK+N,EAAsB/N,KAAKqQ,YAC3B8B,EACEN,EAAoCpM,SACrC,QACAzF,KAAKkS,cAEPvG,S,CAGN3L,MAAK8N,EAAc9N,KAAKqQ,YACnB8B,EACCJ,EACA,QACA/R,KAAKkS,cAEPvG,S,KAGD,CACH,IAAKkG,EAAK,CACR7R,MAAKgO,EAAY,KACjBhO,MAAKiO,EAAoB,KACzB,M,CAKF,GAAI6D,GAAiB9R,KAAKoS,aAAe,MAAO,CAC9CL,EAAUC,KAAO,QAAQD,EAAUC,Q,KAGhC,CACHhS,MAAKiO,EAAoBjO,KAAKmP,UACzBgD,EACEN,EAAoCpM,SACrC,MACAzF,KAAKoS,YAEPzG,S,CAGN3L,MAAKgO,EAAYhO,KAAKmP,UACjBgD,EACCJ,EACA,MACA/R,KAAKoS,YAEPzG,S,GAIR0G,GAA6B,CAG3BL,EACAvM,IACOzF,KAAKyF,SAAWA,GAAYuM,EAAOA,EAE5CxD,GAAsB,IACpB8D,MAAMC,KACJvS,KAAKsE,GAAGkO,iBAAiBzF,KAG7B6C,GAAqB,KACnB5P,MAAK4N,EAAW,IAAI6E,gBAAe,KACjC,MAAMC,EACJ1S,KAAKsE,GAAG/I,wBAAwBoX,OAChC3S,MAAKkO,EAAW3S,wBAAwBoX,OAAS,EAEnD3S,KAAKsE,GAAG0B,MAAMC,YACZ6G,GACA4F,EAAqB,KACtB,IAGH1S,MAAK4N,EAASgF,QAAQ5S,KAAKsE,IAC3BtE,MAAK4N,EAASgF,QAAQ5S,MAAKkO,EAAW,EAGxC2B,GAAsB,KACpB,IAAK7P,MAAK4N,EAAU,CAClB,M,CAEF5N,MAAK4N,EAASiF,aACd7S,MAAK4N,EAAW,IAAI,EAGtBkF,GAAgC7X,IAC9BA,EAAMqG,kBAEN,GAAIrG,EAAM8X,OAAStF,IAAaxS,EAAM8X,OAASrF,GAAY,CACzD,M,CAGFzS,EAAMqD,iBACN,MAAM0U,EAAgB/X,EAAM8X,OAAStF,GACrCzN,MAAKiT,EAAgB,KAAMD,EAA3BhT,EAA2C,EAG7C8O,GAA0B7T,IAGxB,IAAKA,EAAMkL,eAAeZ,SAASvF,MAAKmO,IAAclT,EAAMiY,YAAa,CACvElT,MAAKiT,EAAgB,MAArBjT,E,GAIJiT,GACE,CAACE,EAA4BH,EAAgB,QAC7C,KAIE,IAAKhT,KAAKtC,QAAS,CACjB,M,CAEFsC,KAAKtC,QAAU,MAEfmF,SAASY,oBAAoB,QAASzD,MAAK8O,EAAwB,CACjE9L,QAAS,OAGX,MAAMoQ,EAAapT,MAAKmO,EAAUzD,MAElC,GAAIsI,GAAiBI,EAAWC,SAAW,GAAI,CAC7CrT,KAAK6Q,cAAc5Q,KAAK,CACtBC,GAAIF,KAAKsE,GAAGpE,GACZmH,QAAS+L,G,CAIb,GAAID,EAAmB,CACrBnT,MAAKkO,EAAWa,O,GAItBuE,GAAiBrY,IACfA,EAAMqG,kBAEN,IAAKtB,KAAKwF,KAAM,CACdxF,KAAKyF,UAAYzF,KAAKyF,Q,CAGxBzF,KAAKiE,SAAW,KAChBjE,KAAK+Q,mBAAmB9Q,KACtBD,MAAKuT,EAAiB/U,EAAsBvD,GAAQ,MACrD,EAGHsU,GAAkB9J,IAChB,IAAKzF,KAAKoF,WAAaK,EAAU,CAC/B,M,CAIFzF,KAAKoF,SAAW,MAChBpF,KAAKqF,YAAc,KAEnBrF,KAAKoM,gBAAgBnM,KAAKD,KAAKsE,GAAGpE,GAAG,EAGvCsT,GAAkB,KAChB,MAAMvP,GAAYjE,KAAKiE,SACvBjE,KAAKiE,SAAWA,EAEhBjE,KAAK+Q,mBAAmB9Q,KAAKD,MAAKuT,EAAiB,KAAMtP,GAAU,EAGrEuN,GAAe,KACbxR,KAAKiE,SAAW,KAChBjE,KAAK+Q,mBAAmB9Q,KAAKD,MAAKuT,EAAiB,MAAO,MAAM,EAGlEE,GAAmBxY,IAEjB,GAAIuD,EAAsBvD,GAAQ,CAChC+E,MAAKwT,IACL,M,CAIF,GAAIvY,EAAMkI,QAAU,EAAG,CACrB,M,CAIF,GAAInD,KAAK0T,cAAe,CACtB1T,MAAKsT,EAAcrY,E,KAGhB,CACH+E,MAAKwR,G,GAIT+B,GAAmB,CACjBxP,EACAE,KAAiB,CAEjBF,eAAgBA,EAChB0B,SAAUzF,KAAKyF,SACfvF,GAAIF,KAAKsE,GAAGpE,GACZE,SAAUJ,KAAKI,SACf0H,SAAU9H,KAAKsE,GAAGoD,eAAexH,GACjC+D,SAAUA,IAGZ0P,GAAyB1Y,IACvBA,EAAMqG,kBAEN,GAAI9C,EAAsBvD,GAAQ,CAChC+E,MAAKwT,IACL,M,CAGFxT,MAAK4T,IAIL,IAAK5T,KAAKwF,OAASxF,KAAK0T,cAAe,CACrC1T,MAAKsT,EAAcrY,E,GAWvB4Y,GAAsB5Y,IACpBA,EAAMqG,kBAGN,GAAItB,KAAKtC,QAAS,CAChB,M,CAGFzC,EAAMqD,iBAGN,GAAIrD,EAAMiY,YAAa,CACrBlT,MAAKyT,EAAgBxY,GACrB,M,CAIF+E,MAAK4T,IAGL5T,MAAKsT,EAAcrY,EAAM,EAO3B6Y,GAAwB7Y,IAEtB,GAAIuD,EAAsBvD,IAAUA,EAAM8X,OAAStF,GAAW,CAC5DxS,EAAMqG,kBACNtB,MAAKwT,G,GAITI,GAAqB,KACnB5T,KAAK8Q,cAAc7Q,KAAK,CACtBC,GAAIF,KAAKsE,GAAGpE,GACZsF,KAAMxF,KAAKwF,KACXpF,SAAUJ,KAAKI,UACf,EAGJ2T,GAAwB9Y,IACtBA,EAAMqG,kBACN,MAAM0S,EAAgB/Y,EAAM6E,OAE5B,MAAM2O,EAAUuF,EAAcC,eAAiBD,EAActJ,MAC7D1K,KAAKyO,QAAUA,EACfzO,KAAK0O,cAAgB,MAErB1O,KAAKyQ,eAAexQ,KAAK,CACvBC,GAAIF,KAAKsE,GAAGpE,GACZuO,QAASzO,KAAKyO,QACdC,cAAe,OACf,EAGJ8B,GACEvV,IAGA,GAAI+E,KAAKsE,KAAOrJ,EAAM6E,OAAQ,CAC5B,M,CAGF,MAAMoU,EAAejZ,EAAMkI,OAAOsL,QAClC,MAAMF,EAAYvO,MAAKwO,IAGvB,MAAM2F,EAAkC5F,EAAUrH,OAChDzJ,GAAYA,EAASgR,UAAYyF,IAGnC,MAAME,EACJpU,KAAKyO,UAAYyF,GACjBlU,KAAK0O,iBAAmByF,EAE1BnU,MAAK6N,EAAwB7N,KAAKyO,UAAYyF,EAC9ClU,KAAKyO,QAAUyF,EACflU,KAAK0O,eAAiByF,EAGtB,GAAIC,EAAoB,CACtBpU,KAAK0Q,qBAAqBzQ,KAAK,CAC7BC,GAAIF,KAAKsE,GAAGpE,GACZuO,QAASyF,EACTxF,eAAgByF,G,GAKtBE,IAAa,CAACC,EAAkBC,EAAaC,IAC3CA,IAAc,OACZjM,EAAA,qBACc,OACZE,MAAO,OAAO6L,IACdxL,KAAMwL,EACNG,IAAI,GACJF,IAAKA,EACLG,QAAQ,SAIdC,IAAoB1Z,IAElB,GAAI+E,KAAKtC,QAAS,CAChBzC,EAAMqD,iBACNrD,EAAMqG,kBACN,M,CAGFsT,EAAgB3Z,GAChBA,EAAM2F,aAAayC,cAAgB,OAEnCrD,KAAK+B,UAAY,QACjB/B,KAAK2Q,cAAc1Q,KAAK,CACtBsG,KAAMvG,KAAKsE,GACXlB,UAAWnI,GACX,EAGJ4Z,IAAiB,KAIf7U,KAAK+B,UAAY,OACjB/B,KAAK4Q,YAAY3Q,MAAM,EAGzB+P,GAAmBrH,IACjB,GAAIA,EAAa,CACf3I,KAAKsE,GAAGwQ,aACN,cAGA,GAAGC,KAA+BpM,EAAYqM,QAAQ,OAAQ,O,KAE3D,CACLhV,KAAKsE,GAAGwQ,aAAa,cAAeC,E,GAIxC,iBAAAhN,GAEE8E,KAAqCoI,EACnC,uBACA,uBAGF,GAAIjV,KAAKsO,iBAAkB,CACzBtO,KAAKsE,GAAGxB,iBACN,iBACA9C,MAAKwQ,E,CAITxQ,MAAKoP,EAAc,SACnBpP,MAAKoP,EAAc,OAInBpP,KAAKsE,GAAGwQ,aAAa,OAAQ,YAC7B9U,KAAKsE,GAAGwQ,aAAa,aAAc,GAAG9U,KAAKyM,MAAQ,KACnDzM,KAAKsE,GAAG0B,MAAMC,YAAY,UAAW,GAAGjG,KAAKyM,SAC7CzM,MAAKgQ,EAAgBhQ,KAAKkV,M,CAG5B,iBAAAC,GAEEnV,MAAKuP,EAAevP,KAAKyF,S,CAG3B,gBAAA2P,GACE,GAAIpV,KAAKmQ,UAAYnQ,KAAK2P,UAAW,CACnC3P,MAAK4P,G,EAIT,oBAAAxH,GAEE,GAAIpI,KAAKtC,QAAS,CAChBsC,MAAKiT,EAAgB,M,CAGvBjT,MAAK6P,IAEL7P,KAAKsE,GAAGb,oBACN,iBACAzD,MAAKwQ,E,CAIT,MAAAlI,GACE,MAAMY,EAAYlJ,KAAKyM,MAAQ,IAAM,EAErC,MAAM4I,GAAcrV,KAAKwF,OAASxF,KAAKoF,SAEvC,MAAMoH,EAAexM,KAAKyM,QAAU1D,EACpC,MAAMuM,EAAetV,KAAK2P,YAAc,OAASnD,EACjD,MAAM+I,EACJvV,KAAK2P,YAAc,QAAUnD,GAAgBxM,KAAKmQ,SAEpD,MAAMzD,EAAYzD,EAAqBC,GACvC,MAAMsM,EAAelM,GAAwBtJ,KAAKyF,UAElD,MAAMgQ,EAAmBC,EACvB1V,KAAKqQ,YACLrQ,KAAKkS,cAEP,MAAMyD,EAAiBD,EAAmB1V,KAAKmP,UAAWnP,KAAKoS,YAE/D,MAAMwD,IAAa5V,KAAKkV,MAExB,OACE3M,EAACC,EAAI,CAAAhI,IAAA,2DACYR,KAAKiE,SAAW,OAAS,KACxCwE,MAAOzI,KAAKwF,KAAO0H,GAAkB,KACrCpE,KAAM+M,EAAS,CACb,CAACjN,EAA2BkN,MAAO,KACnC,CAAClN,EAA2BmN,YAAa/V,KAAK+B,YAAc,QAC5D,CAAC/B,KAAKkV,OAAQU,KAGhBrN,EAAA,UAAA/H,IAAA,2DACiB6U,EAAa7H,GAAgB,KAAI,gBACjC6H,EAAarV,KAAKyF,SAAS6B,WAAa,KACvDmB,MAAO,CACLuN,OAAQ,KACR,mBAAoBhW,KAAKiE,SACzB,mBAAoBjE,KAAKoR,SAEzB,gCACGpR,KAAKwF,MAAQxF,KAAKiW,mBAAqB,aAC1C,2CACGjW,KAAKwF,MACNxF,KAAKiW,mBAAqB,eACzBjW,KAAKyF,UAEVqD,KAAM+M,EAAS,CACb,CAAC1M,EAAgC+M,QAAS,KAC1C,CAAC/M,EAAgCgN,UAAWnW,KAAKoR,SACjD,CAACjI,EAAgC4M,YAC/B/V,KAAK+B,YAAc,QACrB,CAACoH,EAAgCiN,UAAWpW,KAAKiE,SACjD,CAACkF,EAAgCkN,eAAgBrW,KAAKiE,SACtD,CAACkF,EAAgCmN,eAC/B9J,IAAiBxM,KAAKwF,MAAQxF,KAAKiW,mBAAqB,KAC1D,CAACjW,KAAKtC,QACFyL,EAAgCoN,QAChCpN,EAAgCqN,aAAc,KAClD9J,CAACA,GAAYF,EAIb,CAACrD,EAAgCsN,eAC9BjK,GAAgBxM,KAAKwF,MAAQxF,KAAKiW,mBAAqB,KAC1D,CAACjW,KAAKkV,OAAQU,IAEhB5P,MACEyP,IAAqBzV,MAAK8N,GAAe9N,MAAK+N,GAC1C/N,MAAKqS,EACHrS,MAAK8N,EACL9N,MAAK+N,GACL2I,OACF/K,UAENzJ,KAAK,SACLkP,SAAUpR,KAAKoR,SACfuF,QAAS3W,MAAK6T,EACdvT,WAAYN,KAAKtC,QAAUsC,MAAK8T,EAAuB,KAEvD8C,WAAY5W,KAAKmH,aACjB1G,YAAaT,MAAK2U,GAClBxT,WACGnB,KAAKmH,cAAgBnH,KAAK+B,YAAc,QACrC/B,MAAK6U,GACL,KAENgC,IAAKvS,GAAOtE,MAAKkO,EAAa5J,IAE5BtE,KAAKwF,MAAQxF,KAAKiW,mBAAqB,UACvC1N,EAAA,UACE/H,IAAI,oBACJ0B,KAAK,SACLuG,MAAO,CACL,oBAAqB,KACrB,8BAA+BzI,KAAKyF,SACpC,gCAAiCzF,KAAKyF,UAExCqD,KAAM+M,EAAS,CACb,CAAC1M,EAAgC2N,mBAAoB,KACrD,CAAC3N,EAAgCgN,UAAWnW,KAAKoR,SACjDoE,CAACA,GAAe,KAChB,CAACxV,KAAKkV,OAAQU,IAEhBxE,SAAUpR,KAAKoR,SACfuF,QAAS3W,MAAKsT,IAIjBtT,KAAK+W,UACJxO,EAAA,eACE/H,IAAI,WACJwW,eAAgBhX,KAAKqH,QACrBoB,MAAM,WACNE,YAAasO,EACbnO,KACE8M,EACI,GAAGzM,EAAgC+N,YAAYlX,KAAKkV,QACpD/L,EAAgC+N,SAEtCjD,aAAa,OACb7C,SAAUpR,KAAKoR,SACf1C,cAAe1O,KAAK0O,cACpByI,eAAe,QACfzM,MAAO,GAAG1K,KAAKyO,UACf2I,QAASpX,MAAK+T,IAIjB/T,KAAKqX,aACJ9O,EAAA,QAAM+O,KAAK,mBAAmB,CAG5B/O,EAAA,OACEE,MAAO,CACL8O,OAAQ,KACR,oBAAqBvX,KAAKmP,UAE1B,CAAC,mBAAmBnP,KAAKkS,kCACvBuD,EACF,CAAC,iBAAiBzV,KAAKoS,8BACrBuD,GAEJ7M,KAAM+M,EAAS,CACb,CAAC1M,EAAgCqO,QAAS,KAC1C,CAACxX,KAAKtC,QACFyL,EAAgCoN,QAChCpN,EAAgCqN,aAAc,KAClDhB,CAACA,IAAgBxV,KAAKwF,KACtB,CAACxF,KAAKkV,OAAQU,IAEhB5P,MACE2P,IAAmB3V,MAAKgO,GAAahO,MAAKiO,GACtCjO,MAAKqS,EACHrS,MAAKgO,EACLhO,MAAKiO,GACLyI,OACF/K,UAEN8L,YAAazX,KAAKtC,QAAUsC,MAAK2T,EAAwB,MAExD3T,KAAKqQ,aACJrQ,MAAK8N,GACL9N,MAAKqU,GACHuB,EACI,GAAGzI,MAAqBnN,KAAKkV,QAC7B/H,GACJnN,MAAK8N,EAAY4I,OAAO,wBACxB1W,KAAKkS,cAGRlS,KAAKtB,UAAYsB,KAAKtC,QACrB6K,EAAA,SACE/H,IAAI,eACJiI,MAAM,eACNK,KACE8M,EACI,GAAGzM,EAAgCuO,gBAAgB1X,KAAKkV,QACxD/L,EAAgCuO,aAEtCtG,SAAUpR,KAAKoR,SACflP,KAAK,OACLwI,MAAO1K,KAAKqH,QACZsQ,OAAQ3X,MAAKiT,EAAgB,OAC7B3S,UAAWN,MAAK8S,EAChB+D,IAAKvS,GAAOtE,MAAKmO,EAAY7J,IAG/BtE,KAAY,QAGbA,KAAKmP,WACJnP,MAAKgO,GACLhO,MAAKqU,GACHuB,EACI,GAAGtI,MAAmBtN,KAAKkV,QAC3B5H,GACJtN,MAAKgO,EAAU0I,OAAO,sBACtB1W,KAAKoS,aAIXpS,KAAK4X,yBAA2B5X,KAAKwF,MAAQxF,KAAKqF,aAChDkD,EAAA,OACEE,MAAM,cACNK,KACE8M,EACI,GAAGzM,EAAgC0O,eAAe7X,KAAKkV,QACvD/L,EAAgC0O,gBAO5CvC,GAAgBC,IAChBhN,EAAA,OACE/H,IAAI,OACJiI,MAAO,CACLqP,KAAM,KACN,gBAAiBxC,GAAgBtV,KAAKmQ,SACtC,YAAaoF,GAEfzM,KAAM+M,EAAS,CACb,CAAC1M,EAAgC4O,MAAO,KACxC,CAAC5O,EAAgC6O,WAAYhY,KAAKmQ,SAClD,CAACnQ,KAAKkV,OAAQU,OAMrBP,GACC9M,EAAA,OAAA/H,IAAA,2CACEyX,KAAK,QAAO,eACEjY,KAAKqF,aAAaiC,WAAU,YAC/BtH,KAAKqF,YAAc,SAAW,KACzCnF,GAAIsN,GACJ/E,MAAO,CACLyP,WAAY,KACZ,yBAA0BlY,KAAKyF,SAC/B,2BAA4BzF,KAAKqF,YAEjC,mBAAoBmH,GAAgBtD,EACpC,kBAAmBsD,IAAiBtD,GAEtCJ,KAAM+M,EAAS,CACb,CAAC1M,EAAgCgP,OAAQ,KACzC,CAAChP,EAAgCiP,cAAepY,KAAKqF,YACrDmQ,CAACA,GAAe,KAChB9I,CAACA,GAAYF,EACb,CAACxM,KAAKkV,OAAQU,KAGhBrN,EAAA,QAAA/H,IAAA,8C,wYC/yCL,MAAM6X,GAAkB,CAC7BlO,EACAmO,IACGnO,EAAK4M,UAAYuB,EAEtB,MAAMC,GAAiB,CACrBC,EACAC,EACAC,IAEAA,EACIF,EAAejT,SAASkT,GACxBD,EAAevb,cAAcsI,SAASkT,EAAOxb,eAEnD,MAAM0b,GAAmB,CACvBH,EACAC,EACAG,WAEOH,IAAW,SACdD,EAAeK,MAAMJ,KAAY,KACjCF,GAAeC,EAAgBC,EAAQG,GAAeF,WAE5D,MAAMI,GAKF,CACFzR,QAAS,CAAC8C,EAAM4O,IACdA,EAAWN,OACPE,GACExO,EAAK9C,SAAW,GAChB0R,EAAWN,OACXM,EAAWH,eAEb,KAENnK,QAAS,CAACtE,EAAM4O,IACdV,GAAgBlO,EAAM4O,EAAWT,mBAChCnO,EAAKuE,gBACLvE,EAAKsE,SAAWsK,EAAWC,gBAE9BC,KAAM,CAAC9O,EAAM4O,IAAeA,EAAWG,UAAUzS,IAAI0D,EAAKjK,IAE1DE,SAAU,CAAC+J,EAAM4O,IACfA,EAAWN,OACPE,GACExO,EAAK/J,UAAY,GACjB2Y,EAAWN,OACXM,EAAWH,eAEb,KAENO,KAAM,IAAM,KAEZC,UAAW,CAACjP,EAAM4O,IAChBV,GAAgBlO,EAAM4O,EAAWT,mBAChCnO,EAAKuE,iBACJvE,EAAKsE,SAAWsK,EAAWC,iBAG1B,MAAMK,GAAgB,CAC3BC,EACAnP,EACA4O,IAEAA,EAAWH,eAAeW,+BAAiC,MACtDT,GAAiBQ,GAAYnP,EAAM4O,GACpCD,GAAiBQ,GAAYnP,EAAM4O,GCtElC,MAAMS,GAActO,MACzBC,EACAnG,EACA2E,EACA0B,EACAe,EAIAqN,EACAC,EACAC,KAEA,MAAMC,EAAsBjQ,EAAmBxE,IAAIH,GAEnD,IACGqG,IACAuO,GACDA,EAAoBzP,KAAK3E,OAAS,KAClC,CACA,OAAO,K,CAGT,MAAMqU,GAAgBH,IAAqBC,EAC3C,GAAIE,EAAc,CAChBH,EAAmB,CAAErU,YAAa,MAClCsU,EAAkB,CAAEtU,YAAa,M,CAGnC,GAAIqU,EAAkB,CACpBvO,EAAW2O,sBAAsB,CAAC9U,GAAS0U,E,CAG7C,MAAMK,QAAiB1O,EAA0BrG,GAGjD,MAAMgV,EAAc,IAAIzO,IACtBqO,EAAoBzP,KAAKT,MAAMtC,KAAI+C,GAAQA,EAAKjK,MAGlD,MAAM+Z,EAAgC,GAGtCF,EAASnS,SAAQsS,IACf,MAAMC,EAAoBxQ,EAAmBxE,IAAI+U,EAAQha,IAGzD,GAAIia,GAAqBH,EAAYvT,IAAIyT,EAAQha,IAAK,CACpD,MAAMka,EAAiBD,EAAkBhQ,KAGzC+P,EAAQzL,QAAU2L,EAAe3L,QACjCyL,EAAQzU,SAAW2U,EAAe3U,SAClCyU,EAAQxL,cAAgB0L,EAAe1L,cACvCwL,EAAQjW,SAAWmW,EAAenW,SAElC,MAAMoW,EACJH,EAAQhO,MAAQkO,EAAelO,OAAS,MAE1C,GAAImO,EAAsB,CACxBH,EAAQhO,KAAO,MAGfgO,EAAQxQ,MAAQ0Q,EAAe1Q,MAG/BuQ,EAAoBtS,KAAKuS,EAAQha,G,CAKnC8Z,EAAY7V,OAAO+V,EAAQha,G,KAK/B,GAAI8Z,EAAYxO,KAAO,EAAG,CACxBiO,EAAY,IAAIO,EAAYnT,Q,OAIxBuF,EAAgBpH,EAAQ+U,GAE9B,GAAIJ,EAAiB,CACnBxO,EAAW2O,sBAAsB,CAAC9U,GAAS2U,E,OAIvChP,QAAQ2P,WACZL,EAAoB7S,KAAImT,GACtBf,GACErO,EACAoP,EACA5Q,EACA0B,EACAe,EACAqN,MAKN,OAAO,IAAI,ECxGN,MAAMe,GAAqB,CAChCxV,EACAyV,EACA9Q,EACA+Q,EACAC,EACArC,KAEA,MAAMrO,EAAcN,EAAmBxE,IAAIH,GAC3C,IAAKiF,EAAa,CAChB,M,CAGF,MAAMC,EAAWD,EAAYE,KAE7ByQ,OAAO/T,KAAK4T,GAAY7S,SAAQiT,IAC9B,GAAIJ,EAAWI,KAAkBlP,UAAW,CAC1CzB,EAAS2Q,GAAgBJ,EAAWI,E,KAKxC,GAAIJ,EAAWxW,SAAU,CACvByW,EAAiBI,IAAI9V,E,MAChB,GAAIyV,EAAWxW,WAAa,MAAO,CACxCyW,EAAiBvW,OAAOa,E,CAI1B,GAAIqT,GAAgBnO,EAAUoO,GAAkB,CAC9CqC,EAAiBzW,IAAIc,EAAQiF,E,KACxB,CACL0Q,EAAiBxW,OAAOa,E,GChCrB,MAAM+V,GAAc,CACzB/V,EACA2E,KAEA,MAAMM,EAAcN,EAAmBxE,IAAIH,GAE3C,IAAKiF,EAAa,CAChB,OAAO,I,CAGT,MAAM+Q,EAAgC,CAAC/Q,EAAYE,MACnD,IAAI8Q,EAAqBhR,EAEzB,MAAOgR,EAAmB5Q,WAAWnK,KAAO8I,EAAS,CACnDgS,EAASrT,KAAKsT,EAAmB5Q,YACjC4Q,EAAqBtR,EAAmBxE,IACtC8V,EAAmB5Q,WAAWnK,G,CAIlC,OAAO8a,EAASE,SAAS,ECvB3B,MAAMC,GAAoB,i0FAC1B,MAAAC,GAAeD,GCqEf,MAAME,GAAuCC,GAC3CC,EACE,uBACA,uBACA,CAACpR,EAAyBqR,EAAiC,WACzD,MAAM3J,EAAM2J,IAAkB,QAAUrR,EAAKkG,YAAclG,EAAKgF,UAEhE,OAAOmM,EAAUG,YACbC,EACE7J,EACAyJ,EAAUK,WACVL,EAAUM,oBAEZ/J,CAAG,IAQb,MAAMgK,GAAyB,MAC/B,MAAMC,GAA8B,MACpC,MAAMC,GAAqB,MAC3B,MAAMC,GAAsB,EAC5B,MAAMC,GAAyB,MAI/B,MAAMC,GAAqB,CACzB5C,EACAb,KAEA,GAAIa,IAAe,OAAQ,CACzB,OAAO,K,CAGT,GAAIA,IAAe,WAAaA,IAAe,WAAY,CACzD,OAAO,I,CAGT,IAAKb,EAAQ,CACX,OAAO,K,CAKT,cAAcA,IAAW,UAAYA,EAAOpF,SAAW,EAAE,EAI3D,MAAM8I,GAAiB,CACrBC,EACAd,IAEAc,EAAUC,aAAe,MACpBD,EAAUC,YACXf,EAAUnU,aAGhB,MAAMmV,GAAiB,CACrBF,EACAd,IAEAc,EAAUG,aAAe,MACpBH,EAAUG,YACXjB,EAAUhW,aAEhB,MAAMkX,GAAiB,CACrBJ,EACAd,EACAG,IAEAA,EACIa,GAAeF,EAAWd,GACzBc,EAA8B9W,cAAgBgW,EAAUhW,aAE/D,MAAMmX,GAAchgB,GAAuB,sBAAsBA,IAEjE,MAAMigB,GAAoB,CACxBN,EACAd,EACAqB,EACAxM,EACA1D,EACAmQ,EACAnB,EAAc,SAEbH,EAAUhC,aAAe,QACxB8C,EAAU9T,SAAW,OACpBgT,EAAUhC,aAAe,SACvBgC,EAAUuB,aAAelR,WACxB2P,EAAUuB,aAAe,QAAW,CACxCD,GACErU,EAAA,qBACErI,GAAIuc,GAAWL,EAAUlc,IACzBuM,MAAOA,EACPhQ,WAAY2f,EAAUlc,GACtBgC,KAAK,WAITqG,EAAA,qBACE/H,IAAK4b,EAAUlc,GACfA,GAAIkc,EAAUlc,GACdmH,QAAS+U,EAAU/U,QACnB0P,SAAUqF,EAAUrF,UAAYuE,EAAUvE,SAC1CtI,QAAS2N,EAAU3N,SAAW6M,EAAU7M,QACxC2C,SACEqK,EACKW,EAA6BU,UAAY,MACzCV,EAA8BhL,SAErC/L,YAAa+W,EAAU/W,YACvB8B,aACEsU,EACIU,GAAeC,EAAWd,GACzBc,EAA8BjV,cAC/BmU,EAAUnU,aAEhB7B,aAAckX,GAAeJ,EAAWd,EAAWG,GACnD/c,SAAU0d,EAAU1d,UAAY4c,EAAUyB,cAC1C5N,UAAWiN,EAAUjN,UACrBiD,WAAYgK,EAAUhK,YAAc,aACpC3M,SAAU2W,EAAU3W,SACpBwQ,iBAAkBqF,EAAUrF,iBAC5BvC,cAAe4H,EAAU5H,cACzB9B,qBAAsB0J,EAAU1J,qBAChClD,cAAe0N,EAAU1N,cACzByB,SAAUA,EACV/K,SAAUgX,EAAUlQ,KACpB1G,KAAM4W,EAAU5W,KAChBiH,MAAOA,EACPrM,SAAUgc,EAAUhc,SACpB8O,MAAOkN,EACPlH,MAAOkH,EAAUlH,MACjBjR,SAAUmY,EAAUnY,SACpB0L,UAAW2L,EAAU3L,UACrBrB,iBACE8N,EAAU9N,kBAAoBgN,EAAUhN,iBAE1C+B,YAAa+L,EAAU/L,YACvB6B,aAAckK,EAAUlK,cAAgB,eAEtCkK,EAAU5W,MACV4W,EAAU1S,OAAS,MACnB0S,EAAU1S,MAAMtC,KAAI,CAAC4V,EAAUC,IAC7B3B,EAAU4B,WACRF,EACA1B,EACAqB,EACArB,EAAU3L,YAAc,SAGrBgN,GAAiBP,EAAUe,aAAexR,UACvCqR,EAAS9c,KAAOkc,EAAUe,WAC1BF,IAAUb,EAAU1S,MAAMzC,OAAS,GACzCwF,EAAQ,EAIR6O,EAAU8B,WAAa,SACrBZ,GAAeJ,EAAWd,EAAWG,KAAiB,KACxDA,MAKRmB,GAA6BzM,GAC3B5H,EAAA,qBACErI,GAAIuc,GAAWL,EAAUlc,IAAM,SAC/BuM,MAAOA,EACPhQ,WAAY2f,EAAUlc,GACtBgC,KAAK,WAKb,MAAMmb,GAA4BL,IAChCA,EAASM,MAAK,CAACC,EAAGC,KAChB,GAAID,EAAEE,MAAQD,EAAEC,MAAO,CACrB,OAAQ,C,CAGV,GAAIF,EAAEE,MAAQD,EAAEC,MAAO,CACrB,OAAO,C,CAGT,OAAOF,EAAElW,SAAWmW,EAAEnW,SAAW,EAAI,CAAC,GACtC,E,MAiESqW,GAAgB,M,uQA4BG,M,cAKO,M,aAOD,M,4DAcK,K,kBAMA,K,+CAcyB,Q,mBAMxB,M,sBAWxC,a,mBAOwC,K,0CAsBA,I,gBAciB/R,U,mBAeH,G,gBAmBN,O,sMA+CP,M,WAYH,G,gBAiB7B+Q,G,eAMiC,O,uBAM1CW,G,sBAQ2C,M,iBAKL,K,CA3QxC1T,IAA8D,IAAI3K,IAClE4K,IACE,IAAI5K,IACN6K,IAA8B,IAAI0B,IAElCoS,IAA2B,MAE3BC,IAA0B,MAE1BxS,IAGAyS,IAAgB,MAChBC,IACAC,IACAC,IAGAC,I,wBAuFA,aAAAC,GACE,GAAIle,KAAKsZ,aAAe,WAAatZ,KAAKsZ,aAAe,WAAY,CACnEtZ,MAAKme,I,EAaT,qBAAAC,GACE,GAAIpe,KAAKsZ,aAAe,WAAatZ,KAAKsZ,aAAe,WAAY,CACnEtZ,MAAKme,I,EAYT,iBAAAE,GAEEre,MAAKge,GAAmB,IAAIzS,IAAIvL,KAAK6c,YAErC,GAAI7c,KAAKsZ,aAAe,OAAQ,CAC9BtZ,MAAKme,I,EAUT,oBAAAG,GACEte,MAAKme,I,CAkBP,iBAAAI,CAAkBlQ,GAChB,GAAIA,IAAa,OAAQ,CAEvBrO,MAAKge,GAAmB,IAAIzS,IAAIvL,KAAK6c,W,KAChC,CACL7c,MAAKge,GAAmBrS,S,CAG1B3L,MAAKme,I,CAuCP,qBAAAK,CAAsBC,GAEpB,IAAKA,EAAmB,CACtBze,MAAK0e,GAAwC1e,MAAK6J,G,EAStD,YAAA8U,GACE3e,MAAK4e,I,CA6CEC,mBAOAnf,gBAMAof,kBAuCAlf,oBAOT,eAAMmf,CACJC,EACAtY,EACAwI,GAEA,IAAK8P,EAAY,CACf,M,CAGF,MAAMC,EAAcvY,EAAiBjE,aAAavC,GAClD,MAAMgf,EAAmBlf,MAAK2J,GAAoBxE,IAAI8Z,GACtD,MAAMnhB,EAAW4I,EAAiB5I,SAIlC,MAAMqhB,EACJrhB,IAAa,QACTohB,EAAiB/U,KACjB+U,EAAiB7U,WAGvB,GAAI3D,EAAiBhE,kBAAmB,CACtC,IAAI0c,EAA2CzT,UAE/C,GAAI7N,IAAa,QAAS,CACxBshB,EAAwB,CACtBnC,MAAOkC,EAAazV,MAAMc,WACxBL,GAAQA,EAAKjK,KAAOwG,EAAiBjE,aAAavC,MAItD,GAAIpC,IAAa,QAAS,CACxBshB,EAAsBnC,O,EAM1BvW,EAAiB7I,aAAa+J,QAC5B5H,MAAKqf,GAAqBF,EAAcC,IAK1C,GAAI1Y,EAAiB/H,sBAAuB,CAC1CqB,MAAKsf,I,MAIJ,CACH,GAAIpQ,GAAS,KAAM,CACjB,M,CAIFiQ,EAAazV,MAAM/B,QAAQuH,GAG3BA,EAAMtH,QAAQ5H,MAAKuf,GAAoBJ,G,CAGzCnf,MAAKwf,GAAWL,EAAazV,OAG7ByV,EAAa1Z,SAAW,KAGxBzF,MAAKyf,KAGLzf,MAAKme,KAGLnS,EAAYhM,K,CAcd,iBAAM+a,CAAY/V,GAChB,OAAO+V,GAAY/V,EAAQhF,MAAK2J,G,CAQlC,kBAAM+V,CAAaC,GACjB,OAAO3f,MAAK0f,GAAcC,E,CAG5BD,IAAiBC,IACf,MAAMC,EAAiD,GAEvDD,EAAQ/X,SAAQ5C,IACd,MAAMiF,EAAcjK,MAAK2J,GAAoBxE,IAAIH,GAEjD,GAAIiF,EAAa,CACf2V,EAAkBjY,KAAKsC,E,KAI3B,OAAO2V,CAAiB,EAQ1B,qBAAMxT,CACJpH,EACAkK,EACA7J,EAAc,MACd6G,EAAO,OAEP,MAAM2T,EAAwB7f,MAAK2J,GAAoBxE,IAAIH,GAAQmF,KAGnE0V,EAAsBxa,YAAcA,EACpCwa,EAAsB3T,KAAOA,EAG7B,GAAIgD,GAAS,KAAM,CACjB,M,CAIF2Q,EAAsBnW,MAAQwF,EAE9BlP,MAAKwf,GAAWK,EAAsBnW,OACtC1J,MAAK8f,GAAiBD,GAGtB7f,MAAKyf,KAGLzf,MAAKme,GAA0B,aAG/BnS,EAAYhM,K,CAOd,iBAAMyZ,CAAY/P,GAChB,MAAMqW,EAA+CtW,GACnDC,EACA1J,MAAK2J,GACL3J,MAAK4J,GACL5J,MAAK6J,IAGP,IAAK7J,MAAKggB,KAAmB,CAE3B,GAAID,EAAkB/V,mBAAoB,CACxChK,MAAKigB,I,CAIP,GAAIF,EAAkBhW,mBAAoB,CACxC/J,MAAKyf,I,EAKT,GAAIM,EAAkBjW,kBAAmB,CACvCkC,EAAYhM,MAGZA,MAAKme,GAA0B,Y,EAUnC,iBAAM3E,CACJxU,EACA0U,EACAC,GAEA,MAAMuG,QAAgB1G,GACpBxZ,KAAKsE,GACLU,EACAhF,MAAK2J,GACL3J,KAAKqL,2BACL,CAACrG,EAAQ0E,IAAU1J,KAAKoM,gBAAgBpH,EAAQ0E,KAC/CA,GAAoB1J,KAAKyZ,YAAY/P,IACtCgQ,EACAC,GAGF,OAAOuG,C,CAoBT,uBAAM9b,CACJ0G,EACA6O,GAEA,MAAMwG,SAA0BrV,IAAS,SAEzC,MAAMoV,QAAiBC,EACnBtV,GAAoBC,EAAM9K,MAAK2J,IAC/BsB,GACEjL,KAAKsE,GACLwG,EACA9K,MAAK2J,GACL3J,MAAKoL,GACLpL,KAAKqL,4BAGX,IAAK6U,EAAS,CACZ,OAAO,K,CAET,MAAMlb,EAASmb,EAAmBrV,EAAOA,EAAKA,EAAK7D,OAAS,GAG5D,IAAImZ,EAAapgB,MAAK2J,GAAoBxE,IAAIH,GAAQqF,WACtD,MAAO+V,IAAepgB,MAAKoL,GAAW,CACpCgV,EAAW3a,SAAW,KACtB2a,EAAapgB,MAAK2J,GAAoBxE,IAAIib,EAAWlgB,IAAImK,U,CAG3D,GAAIsP,EAAiB,CACnB3Z,KAAK8Z,sBAAsB,CAAC9U,GAAS2U,E,CAGvC3N,EAAYhM,MAGZ+F,uBAAsB,KACpB/F,MAAKie,GAAS7Z,kBAAkBY,EAAO,IAGzC,OAAO,I,CAWT,iBAAMqb,CACJC,EACAC,GAEA,IAAKD,EAAa,CAChB,MAAO,E,CAGT,MAAME,EAAgD,GAEtDF,EAAY1Y,SAAQnL,IAClB,MAAMyN,EAAWlK,MAAK2J,GAAoBxE,IAAI1I,GAAY0N,KAE1D,GAAID,EAAU,CACZA,EAASzE,SAAW8a,IAAWrW,EAASzE,SAExC+a,EAAkB7Y,KAAK,CACrBzH,GAAIgK,EAAShK,GACbuF,SAAUyE,EAASzE,U,KAKzBuG,EAAYhM,MAEZ,OAAOwgB,C,CAOT,8BAAMC,CAAyBhG,GAI7B,IAAIza,MAAK2J,GAAoB5C,UAAUa,SAAQqC,IAC7C,GAAIwQ,EAAWhV,UAAY,KAAM,CAC/BwE,EAAYE,KAAK1E,SAAWgV,EAAWhV,Q,CAGzC,GAAIgV,EAAWhM,SAAW,KAAM,CAC9BxE,EAAYE,KAAKsE,QAAUgM,EAAWhM,QACtCxE,EAAYE,KAAKuE,cAAgB,K,KAKrC,GAAI+L,EAAWhM,SAAW,KAAM,CAC9BzO,MAAKme,I,CAGPnS,EAAYhM,K,CAQd,2BAAM8Z,CACJpQ,EACA+Q,GAGA,MAAMC,EAAmB,IAAInP,IAAIvL,MAAK6J,IAGtC,MAAM8Q,EAA2D,IAAI3b,IACnEgB,MAAK4J,IAGPF,EAAM9B,SAAQ5C,IACZwV,GACExV,EACAyV,EACAza,MAAK2J,GACL+Q,EACAC,EACA3a,KAAK+W,SACN,IAIH,IAAK/W,KAAKgE,eAAgB,CACxBhE,MAAK0e,GAAwChE,E,CAI/C,GAAI1a,MAAKggB,KAAmB,CAC1BhgB,MAAKme,I,KACA,CACLne,MAAK0gB,GAA2C/F,GAChD3a,MAAK2gB,GAAuCjG,E,CAG9C1O,EAAYhM,K,CAYd,yBAAM0E,CACJC,EACA/G,EACAC,EACAC,EACA8G,GAEA5E,MAAKie,GAASvZ,oBACZC,EACA/G,EACAC,EACAC,EACA8G,E,CAMJ,gBAAAgc,CAAiB3lB,GACfA,EAAMqG,kBAEN,MAAM6B,EAASlI,EAAMkI,OACrB,MAAM1G,EAAa0G,EAAOjD,GAC1B,MAAM+J,EAAcjK,MAAK4J,GAA4BzE,IAAI1I,GAIzD,IAAKwN,EAAa,CAChB,M,CAEF,MAAMC,EAAWD,EAAYE,KAE7BD,EAASuE,QAAUtL,EAAOsL,QAC1BvE,EAASwE,cAAgBvL,EAAOuL,cAEhC1O,MAAKyf,KAGL,GAAIzf,KAAKsZ,aAAe,WAAatZ,KAAKsZ,aAAe,YAAa,CACpEtZ,MAAKme,I,CAIPnS,EAAYhM,K,CAId,iBAAA6gB,CAAkB5lB,GAChB,IAAK+E,KAAKqL,0BAA2B,CACnC,M,CAEFpQ,EAAMqG,kBAEN,MAAM7E,EAAaxB,EAAMkI,OACzB,MAAM2d,EAAU9gB,KAAKqL,0BAA0B5O,GAC/CxB,EAAM6E,OAAOuF,YAAc,KAE3Byb,EAAQC,MAAK5U,IACXnM,KAAKoM,gBAAgB3P,EAAY0P,EAAO,G,CAK5C,eAAA6U,CAAgB/lB,GACd,IAAK+E,KAAKihB,0BAA2B,CACnC,M,CAEFhmB,EAAMqG,kBAEN,MAAMnB,EAAUlF,EAAM6E,OACtB,MAAMkF,EAAS/J,EAAMkI,OAAOjD,GAC5B,MAAM+J,EAAcjK,MAAK2J,GAAoBxE,IAAIH,GACjD,MAAMkF,EAAWD,EAAYE,KAC7B,MAAMiJ,EAAanY,EAAMkI,OAAOkE,QAChC,MAAM6Z,EAAahX,EAAS7C,QAI5B6C,EAAS7C,QAAU+L,EAInBjT,EAAQkH,QAAU+L,EAElB,MAAM0N,EAAU9gB,KAAKihB,0BAA0Bjc,EAAQoO,GAEvD0N,EAAQC,MAAKI,IACX,GAAIA,EAAOjB,QAAS,CAClBlgB,MAAKwf,GAAWvV,EAAYI,WAAWX,OAGvC1J,MAAKme,KAGLnS,EAAYhM,K,KACP,CACLG,EAAQkH,QAAU6Z,EAClBhX,EAAS7C,QAAU6Z,C,KAQzB,eAAAE,CACEnmB,GAEAA,EAAMqG,kBACNtB,KAAK8e,kBAAkB7e,KAAKhF,EAAMkI,O,CAGpCke,IACEpmB,IAEA,IAAK+E,KAAKshB,2BAA4B,CACpC,M,CAEFrmB,EAAMqG,kBAGN,MAAMqD,GAAmB,IAAI1D,MAAOC,UAEpC,MAAMqgB,EAAkBtmB,EAAMkI,OAC9B,MAAM2d,EAAU9gB,KAAKshB,2BAA2BC,GAEhDT,EAAQC,MAAKnc,IACX5E,KAAK0E,oBACHC,EACA4c,EAAgB9e,aAAavC,GAC7BqhB,EAAgB1jB,aAChB0jB,EAAgBzjB,SAChB8G,EACD,GACD,EAGJ4c,IACEvmB,IAEAA,EAAMqG,kBACN,MAAMmgB,EAAiB,IAAIziB,IAAI/D,EAAMkI,QAErC,MAAMue,EAAwB1hB,MAAK6J,GAGnC6X,EAAsB9Z,SAAQ+Z,IAC5B,MAAM1X,EAAcjK,MAAK2J,GAAoBxE,IAAIwc,GAAgBxX,KACjE,MAAMyX,EAAsBH,EAAetc,IAAIwc,GAG/C,GAAIC,EAAqB,CACvB3X,EAAYxE,SAAWmc,EAAoBnc,SAC3Cgc,EAAetd,OAAOwd,E,KAGnB,CACH1X,EAAYhG,SAAW,MACvByd,EAAsBvd,OAAOwd,E,KAKjCF,EAAe7Z,SAAQ,CAACia,EAAqB7c,KAC3C,MAAM8c,EAAkB9hB,MAAK2J,GAAoBxE,IAAIH,GAAQmF,KAC7D2X,EAAgB7d,SAAW,KAC3B6d,EAAgBrc,SAAWoc,EAAoBpc,SAE/Cic,EAAsB5G,IAAI9V,EAAO,IAKnCgH,EAAYhM,MAEZA,MAAKigB,IAAsB,EAG7B8B,IACE9mB,IAEA,MAAMkI,EAASlI,EAAMkI,OACrB,MAAM+G,EAAWlK,MAAK2J,GAAoBxE,IAAIhC,EAAOjD,IAAIiK,KACzDD,EAASzE,SAAWtC,EAAOsC,QAAQ,EAGrCuc,IACE/mB,IAEAA,EAAMqG,kBACNtB,KAAKN,gBAAgBO,KAAKhF,EAAMkI,OAAO,EAGzC8e,IACEhnB,IAEA,MAAMyL,EAAmBzL,EAAMkI,OAC/B,MAAMV,EAAeiE,EAAiBjE,aACtC,MAAMwc,EAAcxc,EAAavC,GAGjC,IAAKF,MAAK2J,GAAoBxE,IAAI8Z,GAAc,CAC9C,M,CAGF,MAAMphB,EAAqC6I,EAAiB7I,aAE5D,GAAIA,EAAaoJ,SAAW,IAAMjH,KAAKkiB,kBAAmB,CACxD,M,CAEFjnB,EAAMqG,kBAEN,MAAMwf,EAAU9gB,KAAKkiB,kBAAkBxb,GACvC1G,KAAK0I,mBAAqB,KAE1BoY,EAAQC,MAAK7V,MAAMiX,IACjBniB,KAAK+e,UAAUoD,EAASnD,WAAYtY,EAAkByb,EAASjT,OAC/DlP,KAAK0I,mBAAqB,KAAK,GAC/B,EAGJgW,IACE0D,IAEA,GAAIA,EAAqB5W,KAAO,EAAG,CACjC,MAAM6W,EAAqB,IAAID,EAAqBrb,UACpD,MAAMub,EAAgBF,EAAqB5W,KAAO,EAGlD,IAAK,IAAIyR,EAAQ,EAAGA,EAAQqF,EAAerF,IAAS,CAClD,MAAMjY,EAASqd,EAAmBpF,GAElCjd,MAAK2J,GAAoBxE,IAAIH,GAAQmF,KAAKlG,SAAW,K,CAIvDme,EAAqB1hB,QACrB0hB,EAAqBtH,IAAIuH,EAAmBC,IAE5CtiB,MAAKsf,I,GAITD,IACE,CAACkD,EAAkCC,IACnC,CAAC9b,EAAsCuW,KACrC,MAAMwF,EAAsBziB,MAAK2J,GAAoBxE,IACnDuB,EAAiBxG,IAEnB,MAAMiK,EAAOsY,EAAoBtY,KACjC,MAAMuY,EAAgBD,EAAoBpY,WAE1C,MAAMsY,EAAWD,EAAchZ,MAAMc,WAAUlG,GAAMA,EAAGpE,KAAOiK,EAAKjK,KAIpEqK,EAAcmY,EAAchZ,MAAOiZ,GAInC,GAAIH,IAAkB7W,UAAW,CAC/B,IAAIiX,EAAWJ,EAAcvF,MAAQA,EAIrC,GAAIyF,EAAcxiB,KAAOqiB,EAAcriB,IAAMyiB,EAAWC,EAAU,CAChEA,IACAJ,EAAcvF,O,CAGhB4F,EAAgBN,EAAc7Y,MAAOS,EAAMyY,E,KAGxC,CACHL,EAAc7Y,MAAM/B,KAAKwC,E,CAI3BsY,EAAoBpY,WAAakY,CAAa,EAGlDzC,IAAoB5Q,IAClB,MAAMxF,EAAQwF,EAAMxF,MAEpB,IAAKA,EAAO,CAEV,GAAIwF,EAAM1J,OAAS,KAAM,CACvB0J,EAAMxF,MAAQ,E,CAEhB,M,CAEF1J,MAAKwf,GAAW9V,GAEhBA,EAAM9B,QAAQ5H,MAAKuf,GAAoBrQ,GAAO,EAGhDqQ,IACGuD,GAAoC3Y,IACnCnK,MAAK2J,GAAoBzF,IAAIiG,EAAKjK,GAAI,CACpCmK,WAAYyY,EACZ3Y,KAAMA,IAIR,GAAInK,MAAKqY,GAAiBlO,GAAO,CAC/BnK,MAAK4J,GAA4B1F,IAAIiG,EAAKjK,GAAI,CAC5CmK,WAAYyY,EACZ3Y,KAAMA,G,CAMVA,EAAK1E,WAAaoW,GAClB1R,EAAKuE,gBAAkBoN,GACvB3R,EAAK+B,OAAS6P,GACd5R,EAAKsT,QAAUzB,GACf7R,EAAKlG,WAAagY,GAElB,GAAI9R,EAAKlG,SAAU,CACjBjE,MAAK6J,GAAeiR,IAAI3Q,EAAKjK,G,CAG/BF,MAAK8f,GAAiB3V,EAAK,EAG/BkO,IAAoBlO,GAClBkO,GAAgBlO,EAAMnK,KAAK+W,UAE7BiJ,IAAkB,IAAM9D,GAAmBlc,KAAKsZ,WAAYtZ,KAAKyY,QAEjE+G,IAActQ,IAEZ,GAAIlP,KAAKod,WAAa,SAAWpd,KAAK+iB,kBAAmB,CACvD/iB,KAAK+iB,kBAAkB7T,E,GAI3B0P,IAAgB,KACd5e,MAAK2J,GAAoBjJ,QACzBV,MAAK4J,GAA4BlJ,QACjCV,MAAK6J,GAAenJ,QAEpBV,MAAKoL,GAAY,CAAElL,GAAI8I,EAAS3B,QAAS2B,EAASU,MAAO1J,KAAKkP,OAC9DlP,MAAK8f,GAAiB9f,MAAKoL,IAG3BpL,MAAKme,GAA0B,aAI/Bne,MAAKsf,KAGLtf,MAAKyf,IAA6B,EAGpCuD,IAAkB,CAChB7Y,EACA4O,EACAqJ,EACAa,KAEA,IAAIC,EAAqB,MAGzB,GAAI/Y,EAAK3E,OAAS,MAAQ2E,EAAKT,OAAS,KAAM,CAC5C,IAAIyT,EAAaxR,UAEjBxB,EAAKT,MAAM9B,SAAQoJ,IACjB,MAAMmS,EAAsBnjB,MAAKgjB,GAC/BhS,EACA+H,EACAqJ,EACAa,GAEFC,IAAuBC,EAEvB,GAAIA,EAAqB,CACvBhG,EAAanM,EAAQ9Q,E,KAIzBiK,EAAKgT,WAAaA,C,CAKpB,MAAMiG,EACJF,GAAsB7J,GAAcrZ,KAAKsZ,WAAYnP,EAAM4O,GAE7D5O,EAAK7B,OAAS8a,EAGd,GAAIA,GAAmBjZ,EAAKjK,KAAO8I,EAAS,CAC1C,GAAImB,EAAKlG,SAAU,CACjBme,EAAqBtH,IAAI3Q,EAAKjK,G,CAGhC,GAAIF,MAAKqY,GAAiBlO,GAAO,CAC/B,MAAMF,EAAcjK,MAAK2J,GAAoBxE,IAAIgF,EAAKjK,IACtD+iB,EAAqB/e,IAAIiG,EAAKjK,GAAI+J,E,EAItC,OAAOmZ,CAAe,EAGxB3D,IAA8B,KAC5Bzf,MAAK4d,GAA0B,IAAI,EAGrC0B,IAA+B,KAC7Btf,MAAK2d,GAA2B,IAAI,EAGtCsC,IAAuB,KACrB,MAAMpc,EAAoB7D,MAAK0f,GAAc,IACxC1f,MAAK6J,GAAehD,SAEzB7G,KAAKJ,oBAAoBK,KAAK4D,EAAkB,EAGlDwf,IAAsB,KAEpB,MAAMC,EACJ,IAAItkB,IAAIgB,MAAK4J,IAGf0Z,EAAqB1b,SAAQqC,IAC3BA,EAAYE,KAAKsE,UAAYzO,KAAKyO,OAAO,IAG3CzO,KAAK6e,mBAAmB5e,KAAKqjB,EAAqB,EAGpDnF,IAA6BL,IAC3B9d,MAAK6d,GAAgB,KAErB,GAAIC,IAAoBnS,UAAW,CACjC3L,MAAK8d,KAAqBA,C,GAI9B4C,IACE/F,IAEA,GAAIA,EAAiBnP,OAASxL,MAAK4J,GAA4B4B,KAAM,CACnExL,MAAK4d,GAA0B,I,KAG5B,CACH5d,MAAK4J,GAA4BhC,SAAQ,CAAC2b,EAAGve,KAG3C,IAAK2V,EAAiBlU,IAAIzB,GAAS,CAEjChF,MAAK4d,GAA0B,I,KAMrC5d,MAAK4J,GAA8B+Q,CAAgB,EAGrDgG,IAA0CjG,IACxC,GAAIA,EAAiBlP,OAASxL,MAAK6J,GAAe2B,KAAM,CACtDxL,MAAK2d,GAA2B,I,KAG7B,CACH3d,MAAK6J,GAAejC,SAAQ5C,IAG1B,IAAK0V,EAAiBjU,IAAIzB,GAAS,CACjChF,MAAK2J,GAAoBxE,IAAIH,GAAQmF,KAAKlG,SAAW,MAGrDjE,MAAK2d,GAA2B,I,KAMtC3d,MAAK6J,GAAiB6Q,CAAgB,EAGxC8I,IAAiB,KACf,GAAIxjB,KAAKsZ,aAAe,OAAQ,CAE9B,MAAMmK,EACJ,IAAIzkB,IAENgB,MAAK2J,GAAoB/B,SAAQ,CAACqC,EAAajF,KAC7C,GAAIhF,MAAKqY,GAAiBpO,EAAYE,MAAO,CAC3CsZ,EAAkBvf,IAAIc,EAAQiF,E,KAIlCjK,MAAK0gB,GAA2C+C,GAChDzjB,MAAK0jB,KAEL1jB,MAAK8d,GAAmBnS,UAExB,M,CAIFpJ,aAAavC,MAAK+d,IAElB,MAAM4F,EACJ3jB,KAAK4jB,eAAiB,IACrB5jB,KAAKsZ,aAAe,WAAatZ,KAAKsZ,aAAe,YAExD,MAAMuK,EAAiB,KACrB,MAAMzB,EAAoC,IAAI7W,IAC9C,MAAMuY,EACJ,IAAI9kB,IAEN,GAAIgB,KAAKsZ,aAAe,OAAQ,CAC9BtZ,MAAKge,KAAqB,IAAIzS,G,CAGhCvL,MAAKgjB,GACH,CACE9iB,GAAI8I,EACJ3B,QAAS2B,EACTU,MAAO1J,KAAKkP,OAEd,CACEoJ,gBAAiBtY,KAAK+W,SACtBiC,eAAgBhZ,KAAKyO,QACrBgK,OAAQzY,KAAKyY,OACbG,cAAe5Y,KAAK4Y,cACpBM,UAAWlZ,MAAKge,IAElBoE,EACA0B,GAKF9jB,MAAK2gB,GAAuCyB,GAC5CpiB,MAAK0gB,GAA2CoD,GAEhD9jB,MAAK0jB,IAAkC,EAIzC,GAAIC,GAAuB3jB,MAAK8d,KAAqB,YAAa,CAChE9d,MAAK+d,GAAiBrY,YAAW,KAC/B1F,MAAK8d,GAAmBnS,UACxBkY,IACA7X,EAAYhM,KAAK,GAChBA,KAAK4jB,e,KAGL,CACH5jB,MAAK8d,GAAmBnS,UACxBkY,G,GAIJH,IAAmC,KACjC,GAAI1jB,MAAK4d,GAAyB,CAChC5d,MAAKqjB,KACLrjB,MAAK4d,GAA0B,K,CAGjC,GAAI5d,MAAK2d,GAA0B,CACjC3d,MAAK2d,GAA2B,MAGhC3d,MAAKigB,I,GAIT8D,IAA4B,KAC1B,MAAMlgB,EAA2D,IAAI7E,IAErEgB,MAAK6J,GAAejC,SAAQ5C,IAC1B,MAAMiF,EAAcjK,MAAK2J,GAAoBxE,IAAIH,GACjD,MAAMkF,EAAWD,EAAYE,KAE7BtG,EAAkBK,IAAIc,EAAQ,CAC5B9E,GAAIgK,EAAShK,GACbuF,SAAUyE,EAASzE,SACnBrF,SAAU8J,EAAS9J,SACnB0H,SAAUmC,EAAYI,WAAWnK,IACjC,IAGJ,OAAO2D,CAAiB,EAG1B,iBAAAkE,GAEE,IACGkN,EAA2B,uBAAwB,uBACpD,CACAoG,GAAoCrb,K,CAItCA,KAAKsE,GAAGwQ,aAAa,OAAQ,O,CAG/B,iBAAAK,GACEnV,MAAK4e,I,CAGP,mBAAAoF,GACE,IACGhkB,MAAK2d,KACL3d,MAAK4d,KACL5d,MAAK6d,GACN,CACA,M,CAKF,GAAI7d,MAAK6d,GAAe,CACtB7d,MAAKwjB,KACLxjB,MAAK6d,GAAgB,MACrB,M,CAGF7d,MAAK0jB,I,CAGP,MAAApb,GACE,OACEC,EAACC,EAAI,CAAAhI,IAAA,kEAAuBR,KAAKgE,eAAesD,YAC9CiB,EAAA,gBAAA/H,IAAA,2CACEwD,eAAgBhE,KAAKgE,eACrBF,sBAAuB9D,MAAK+jB,GAC5Brb,mBAAoB1I,KAAK0I,mBACzBub,qBAAsBjkB,MAAKqhB,GAC3B6C,qBAAsBlkB,MAAK+hB,GAC3BoC,kBAAmBnkB,MAAKgiB,GACxBoC,eAAgBpkB,MAAKiiB,GACrBoC,sBAAuBrkB,MAAKwhB,GAC5B3K,IAAKvS,GAAOtE,MAAKie,GAAW3Z,GAE3BtE,KAAKkP,MAAM9H,KAAI,CAACgV,EAAWa,IAC1Bjd,KAAKkd,WACHd,EACApc,KACAA,MAAKggB,KACLhgB,KAAK2P,YAAc,QAAUsN,IAAUjd,KAAKkP,MAAMjI,OAAS,EAC3D,EACAjH,KAAKod,WAAa,SAAWpd,KAAKsF,eAAiB,KACnDtF,KAAKyb,gB"}