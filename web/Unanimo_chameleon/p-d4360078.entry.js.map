{"version":3,"names":["filterWithCase","stringToFilter","filter","matchCase","includes","toLowerCase","filterWithString","filterOptions","regularExpression","match","filterCaption","item","filterInfo","caption","value","options","computeFilter","hideMatchesAndShowNonMatches","filterSubModel","displayedValues","aSubItemIsRendered","itemSubGroup","items","index","length","itemLeaf","itemSatisfiesFilter","satisfiesFilter","add","INDEX_SEPARATOR","getComboBoxElementIndex","parentIndex","insideAGroup","getComboBoxItemUIModel","model","indexes","split","itemFirstLevel","Number","getComboBoxItemImageStyle","images","undefined","start","end","styles","customComboBoxItemRender","parentDisabled","checkToDisplayValue","activeDescendantValue","itemImages","has","startImgSrc","endImgSrc","get","hasStartImg","hasEndImg","startImgClasses","startImgType","classes","endImgClasses","endImgType","isDisabled","disabled","itemGroup","isActiveDescendant","itemIndex","h","key","expandable","expanded","toString","role","class","part","tokenMap","COMBO_BOX_PARTS_DICTIONARY","GROUP","DISABLED","id","group__header","GROUP_HEADER","EXPANDABLE","EXPANDED","COLLAPSED","style","type","GROUP_HEADER_CAPTION","group__content","GROUP_CONTENT","map","tabindex","leaf","selected","ITEM","NESTED","SELECTED","nativeItemRender","selectedValue","label","findComboBoxLargestValue","largestValue","largestValueLength","forEach","subItems","mapValuesToItemInfo","valueToItemInfo","captionToItemInfo","clear","firstLevelIndex","firstLevelItemInfo","set","subItem","secondLevelIndex","secondLevelItemInfo","popoverWasClicked","event","composedPath","element","elementName","tagName","getComboBoxItemFromMouseEvent","stopPropagation","elementTarget","target","parentElement","activeDescendant","checkIfSecondLevelModelContainsActiveDescendant","secondIndex","secondLevelItem","comboBoxActiveDescendantIsRendered","firstIndex","firstLevelItem","SELECTED_VALUE_DOES_NOT_EXISTS","isValidIndex","array","findSelectedIndex","findNextSelectedIndex","currentIndex","increment","hasFilters","firstLevelItemItems","nextFirstLevelIndex","nestedLevel","computeComboBoxItemImage","itemUIModel","iconDirection","getImagePathCallback","img","updateDirectionInImageCustomVar","setComboBoxImagesForMap","computedImageModel","computedImage","getComboBoxImages","Map","comboBoxCss","ChComboBoxRenderStyle0","SELECTED_ITEM_SELECTOR","mobileDevice","isMobileDevice","DEFAULT_GET_IMAGE_PATH_CALLBACK","base","ChComboBoxRender","accessibleNameFromExternalLabel","lastConfirmedValue","applyFilters","queuedInputValueUpdate","selectNextIndex","currentSelectedIndex","preventDefault","nextSelectedIndex","this","newSelectedValue","keyEventsNoFiltersDictionary","ArrowUp","suggest","isModelAlreadyFiltered","ArrowDown","Home","End","Enter","el","focus","Space","Tab","keyEventsWithFiltersDictionary","checkAndEmitValueChangeWithFilters","inputRef","selectRef","handleExpandedChange","newExpandedValue","setComboBoxIcons","syncActiveDescendant","scheduleFilterProcessing","internals","modelChanged","newModel","findLargestValue","setValueInForm","suggestChanged","suggestDebounceChanged","suggestOptionsChanged","valueChanged","newValue","input","change","getActualImagePathCallback","getControlRegisterProperty","filterModel","suggestOptions","updateFilters","modelIsAlreadyFiltered","Set","getCurrentValueMapping","checkAndEmitValueChangeWithNoFilter","clearTimeout","emit","emitChangeEvent","strict","inputValueMatches","handleSelectChange","handleExpandedChangeWithKeyBoard","keyboardHandler","code","handlePopoverClose","focusComposedPath","handleInputFilterChange","suggestDebounce","setTimeout","displayPopover","clickWasPerformedInALabel","detail","handlePopoverClick","forceUpdate","handleMouseOverItem","alreadyProcessed","shouldRenderActiveItemIcon","renderActiveItemIconOnExpand","setFormValue","clientSideFilters","nativeRender","accessibleName","onChange","ref","placeholder","connectedCallback","labels","getElementInternalsLabel","analyzeLabelExistence","componentWillRender","componentDidRender","selectedElement","shadowRoot","querySelector","requestAnimationFrame","render","filtersAreApplied","disableTextSelection","comboBoxIsInteractive","readonly","currentItemInInput","currentValueMapping","inputValue","Host","COMBO_BOX_HOST_PARTS","PLACEHOLDER","hostParts","onKeyDown","onClickCapture","autocomplete","readOnly","onInputCapture","actionById","actionElement","blockAlign","inlineAlign","popoverInlineAlign","closeOnClickOutside","show","popover","resizable","inlineSizeMatch","overflowBehavior","positionTry","onClick","onMouseOver","onPopoverClosed"],"sources":["src/components/combo-box/helpers.ts","src/components/combo-box/renders.tsx","src/components/combo-box/utils.ts","src/components/combo-box/navigation.ts","src/components/combo-box/item-images.ts","src/components/combo-box/combo-box.scss?tag=ch-combo-box-render&encapsulation=shadow","src/components/combo-box/combo-box.tsx"],"sourcesContent":["import {\r\n  ComboBoxSuggestInfo,\r\n  ComboBoxSuggestOptions,\r\n  ComboBoxItemGroup,\r\n  ComboBoxItemModel\r\n} from \"./types\";\r\n\r\nconst filterWithCase = (\r\n  stringToFilter: string,\r\n  filter: string,\r\n  matchCase?: boolean\r\n) =>\r\n  matchCase\r\n    ? stringToFilter.includes(filter)\r\n    : stringToFilter.toLowerCase().includes(filter.toLowerCase());\r\n\r\nconst filterWithString = (\r\n  stringToFilter: string,\r\n  filter: string,\r\n  filterOptions: ComboBoxSuggestOptions\r\n) =>\r\n  filterOptions?.regularExpression\r\n    ? stringToFilter.match(filter) !== null\r\n    : filterWithCase(stringToFilter, filter, filterOptions?.matchCase);\r\n\r\nconst filterCaption = (\r\n  item: ComboBoxItemModel,\r\n  filterInfo: ComboBoxSuggestInfo\r\n) =>\r\n  !filterInfo.filter ||\r\n  filterWithString(\r\n    item.caption ?? item.value,\r\n    filterInfo.filter,\r\n    filterInfo.options\r\n  );\r\n\r\nconst computeFilter = (\r\n  item: ComboBoxItemModel,\r\n  filterInfo: ComboBoxSuggestInfo\r\n): boolean =>\r\n  filterInfo.options?.hideMatchesAndShowNonMatches === true\r\n    ? !filterCaption(item, filterInfo)\r\n    : filterCaption(item, filterInfo);\r\n\r\nexport const filterSubModel = (\r\n  item: ComboBoxItemModel,\r\n  filterInfo: ComboBoxSuggestInfo,\r\n  displayedValues: Set<ComboBoxItemModel>\r\n): boolean => {\r\n  // Check if a subitem is rendered\r\n  let aSubItemIsRendered = false;\r\n  const itemSubGroup = (item as ComboBoxItemGroup).items;\r\n\r\n  if (itemSubGroup != null) {\r\n    for (let index = 0; index < itemSubGroup.length; index++) {\r\n      const itemLeaf = itemSubGroup[index];\r\n      const itemSatisfiesFilter = filterSubModel(\r\n        itemLeaf,\r\n        filterInfo,\r\n        displayedValues\r\n      );\r\n\r\n      aSubItemIsRendered ||= itemSatisfiesFilter;\r\n    }\r\n  }\r\n\r\n  // The current item is rendered if it satisfies the filter condition or a\r\n  // subitem exists that needs to be rendered\r\n  const satisfiesFilter = aSubItemIsRendered || computeFilter(item, filterInfo);\r\n\r\n  // Update selected and checkbox items\r\n  if (satisfiesFilter) {\r\n    displayedValues.add(item);\r\n  }\r\n\r\n  return satisfiesFilter;\r\n};\r\n","import { h } from \"@stencil/core\";\r\nimport {\r\n  ComboBoxItemGroup,\r\n  ComboBoxItemImagesModel,\r\n  ComboBoxItemModel,\r\n  ComboBoxModel\r\n} from \"./types\";\r\nimport { tokenMap } from \"../../common/utils\";\r\nimport { COMBO_BOX_PARTS_DICTIONARY } from \"../../common/reserved-names\";\r\n\r\nconst INDEX_SEPARATOR = \"__\";\r\n\r\nconst getComboBoxElementIndex = (\r\n  parentIndex: string,\r\n  index: number,\r\n  insideAGroup: boolean\r\n) => (insideAGroup ? `${parentIndex}${INDEX_SEPARATOR}${index}` : `${index}`);\r\n\r\nexport const getComboBoxItemUIModel = (\r\n  index: string,\r\n  model: ComboBoxModel\r\n): ComboBoxItemModel => {\r\n  const indexes = index.split(INDEX_SEPARATOR);\r\n  const itemFirstLevel = model[Number(indexes[0])];\r\n\r\n  if (\r\n    indexes.length === 2 &&\r\n    (itemFirstLevel as ComboBoxItemGroup).items != null\r\n  ) {\r\n    return (itemFirstLevel as ComboBoxItemGroup).items[Number(indexes[1])];\r\n  }\r\n  return itemFirstLevel;\r\n};\r\n\r\n// TODO: Add a unit test for these cases\r\nexport const getComboBoxItemImageStyle = (\r\n  images: ComboBoxItemImagesModel | undefined\r\n) => {\r\n  if (!images) {\r\n    return undefined;\r\n  }\r\n\r\n  if (images.start && images.end) {\r\n    return {\r\n      ...images.start.styles,\r\n      ...images.end.styles\r\n    };\r\n  }\r\n\r\n  return images.start?.styles ?? images.end.styles;\r\n};\r\n\r\nexport const customComboBoxItemRender =\r\n  (\r\n    insideAGroup: boolean,\r\n    parentDisabled: boolean,\r\n    checkToDisplayValue: boolean,\r\n    activeDescendantValue: ComboBoxItemModel | undefined,\r\n    displayedValues: Set<ComboBoxItemModel> | undefined,\r\n    itemImages: Map<string, ComboBoxItemImagesModel>,\r\n    parentIndex: string\r\n  ) =>\r\n  (item: ComboBoxItemModel, index: number) => {\r\n    if (\r\n      checkToDisplayValue &&\r\n      // !this.#isModelAlreadyFiltered() &&\r\n      !displayedValues.has(item)\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    const images: ComboBoxItemImagesModel | undefined =\r\n      !!item.startImgSrc || !!item.endImgSrc\r\n        ? itemImages.get(item.value)\r\n        : undefined;\r\n    const hasStartImg = !!images?.start;\r\n    const hasEndImg = !!images?.end;\r\n\r\n    const startImgClasses = hasStartImg\r\n      ? `img--start start-img-type--${item.startImgType ?? \"background\"} ${\r\n          images.start.classes\r\n        }`\r\n      : undefined;\r\n    const endImgClasses = hasEndImg\r\n      ? `img--end end-img-type--${item.endImgType ?? \"background\"} ${\r\n          images.end.classes\r\n        }`\r\n      : undefined;\r\n\r\n    // This variable inherits the disabled state from group parents. Useful\r\n    // to propagate the disabled state in the child buttons\r\n    const isDisabled = parentDisabled || item.disabled;\r\n    const itemGroup = item as ComboBoxItemGroup;\r\n    const isActiveDescendant = item.value === activeDescendantValue?.value;\r\n\r\n    const itemIndex = getComboBoxElementIndex(parentIndex, index, insideAGroup);\r\n\r\n    return itemGroup.items != null ? (\r\n      <div\r\n        key={`__group__${item.value}`}\r\n        // TODO: This should be placed in the button\r\n        aria-controls={itemGroup.expandable ? `${index}__content` : null}\r\n        aria-expanded={\r\n          itemGroup.expandable ? (!!itemGroup.expanded).toString() : null\r\n        }\r\n        aria-labelledby={index.toString()}\r\n        role=\"group\"\r\n        class=\"group\"\r\n        part={tokenMap({\r\n          [item.value]: true,\r\n          [COMBO_BOX_PARTS_DICTIONARY.GROUP]: true,\r\n          [COMBO_BOX_PARTS_DICTIONARY.DISABLED]: isDisabled\r\n        })}\r\n      >\r\n        {itemGroup.expandable ? (\r\n          <button\r\n            id={itemIndex}\r\n            class={{\r\n              // eslint-disable-next-line camelcase\r\n              group__header: true,\r\n              \"group--expandable\": true,\r\n              \"group--collapsed\": !itemGroup.expanded,\r\n              disabled: isDisabled\r\n            }}\r\n            part={tokenMap({\r\n              [item.value]: true,\r\n              [COMBO_BOX_PARTS_DICTIONARY.GROUP_HEADER]: true,\r\n              [COMBO_BOX_PARTS_DICTIONARY.EXPANDABLE]: true,\r\n              [COMBO_BOX_PARTS_DICTIONARY.DISABLED]: isDisabled,\r\n              [COMBO_BOX_PARTS_DICTIONARY.EXPANDED]: itemGroup.expanded,\r\n              [COMBO_BOX_PARTS_DICTIONARY.COLLAPSED]: !itemGroup.expanded\r\n            })}\r\n            style={getComboBoxItemImageStyle(images)}\r\n            disabled={isDisabled}\r\n            type=\"button\"\r\n          >\r\n            <span\r\n              class={{\r\n                \"group__header-caption\": true,\r\n                [startImgClasses]: hasStartImg,\r\n                [endImgClasses]: hasEndImg\r\n              }}\r\n              part={`${COMBO_BOX_PARTS_DICTIONARY.GROUP_HEADER_CAPTION} ${item.value}`}\r\n            >\r\n              {item.caption ?? item.value}\r\n            </span>\r\n          </button>\r\n        ) : (\r\n          <span\r\n            id={index.toString()}\r\n            class={{\r\n              // eslint-disable-next-line camelcase\r\n              group__header: true,\r\n              disabled: isDisabled,\r\n\r\n              [startImgClasses]: hasStartImg,\r\n              [endImgClasses]: hasEndImg\r\n            }}\r\n            part={tokenMap({\r\n              [item.value]: true,\r\n              [COMBO_BOX_PARTS_DICTIONARY.GROUP_HEADER]: true,\r\n              [COMBO_BOX_PARTS_DICTIONARY.DISABLED]: isDisabled\r\n            })}\r\n            style={getComboBoxItemImageStyle(images)}\r\n          >\r\n            {item.caption ?? item.value}\r\n          </span>\r\n        )}\r\n\r\n        <div\r\n          key={`__content__${item.value}`}\r\n          id={itemGroup.expandable ? `${index}__content` : null}\r\n          class={{\r\n            // eslint-disable-next-line camelcase\r\n            group__content: true,\r\n            \"group__content--collapsed\":\r\n              itemGroup.expandable && !itemGroup.expanded\r\n          }}\r\n          part={`${COMBO_BOX_PARTS_DICTIONARY.GROUP_CONTENT} ${item.value}`}\r\n        >\r\n          {(!itemGroup.expandable || itemGroup.expanded) &&\r\n            itemGroup.items.map(\r\n              customComboBoxItemRender(\r\n                true,\r\n                isDisabled,\r\n                checkToDisplayValue,\r\n                activeDescendantValue,\r\n                displayedValues,\r\n                itemImages,\r\n                itemIndex\r\n              )\r\n            )}\r\n        </div>\r\n      </div>\r\n    ) : (\r\n      <button\r\n        key={item.value}\r\n        id={itemIndex}\r\n        role=\"option\"\r\n        // TODO: This should be a string\r\n        aria-selected={isActiveDescendant}\r\n        tabindex=\"-1\"\r\n        class={{\r\n          leaf: true,\r\n          disabled: isDisabled,\r\n          selected: isActiveDescendant,\r\n\r\n          [startImgClasses]: hasStartImg,\r\n          [endImgClasses]: hasEndImg\r\n        }}\r\n        part={tokenMap({\r\n          [item.value]: true,\r\n          [COMBO_BOX_PARTS_DICTIONARY.ITEM]: true,\r\n          [COMBO_BOX_PARTS_DICTIONARY.NESTED]: insideAGroup,\r\n          [COMBO_BOX_PARTS_DICTIONARY.DISABLED]: isDisabled,\r\n          [COMBO_BOX_PARTS_DICTIONARY.SELECTED]: isActiveDescendant\r\n        })}\r\n        style={getComboBoxItemImageStyle(images)}\r\n        disabled={isDisabled}\r\n        type=\"button\"\r\n      >\r\n        {\r\n          // TODO: Add unit test for this case\r\n          item.caption ?? item.value\r\n        }\r\n      </button>\r\n    );\r\n  };\r\n\r\nexport const nativeItemRender = (\r\n  item: ComboBoxItemModel,\r\n  selectedValue: string\r\n) =>\r\n  (item as ComboBoxItemGroup).items != null ? (\r\n    <optgroup label={item.caption ?? item.value}>\r\n      {(item as ComboBoxItemGroup).items.map(item =>\r\n        nativeItemRender(item, selectedValue)\r\n      )}\r\n    </optgroup>\r\n  ) : (\r\n    <option\r\n      key={item.value}\r\n      value={item.value}\r\n      disabled={item.disabled}\r\n      selected={item.value === selectedValue}\r\n    >\r\n      {item.caption ?? item.value}\r\n    </option>\r\n  );\r\n","import { ChameleonControlsTagName } from \"../../common/types\";\r\nimport { getComboBoxItemUIModel } from \"./renders\";\r\nimport {\r\n  ComboBoxItemGroup,\r\n  ComboBoxItemModel,\r\n  ComboBoxItemModelExtended,\r\n  ComboBoxModel\r\n} from \"./types\";\r\n\r\nexport const findComboBoxLargestValue = (model: ComboBoxModel): string => {\r\n  let largestValue = \"\";\r\n  let largestValueLength = 0;\r\n\r\n  model.forEach((itemGroup: ComboBoxItemGroup) => {\r\n    const subItems = itemGroup.items;\r\n\r\n    if (itemGroup.caption.length > largestValueLength) {\r\n      largestValue = itemGroup.caption;\r\n      largestValueLength = itemGroup.caption.length;\r\n    }\r\n\r\n    if (subItems != null) {\r\n      subItems.forEach(leaf => {\r\n        if (leaf.caption.length > largestValueLength) {\r\n          largestValue = leaf.caption;\r\n          largestValueLength = leaf.caption.length;\r\n        }\r\n      });\r\n    }\r\n  });\r\n\r\n  return largestValue;\r\n};\r\n\r\nexport const mapValuesToItemInfo = (\r\n  model: ComboBoxModel,\r\n  valueToItemInfo: Map<string, ComboBoxItemModelExtended>,\r\n  captionToItemInfo: Map<string, ComboBoxItemModelExtended>\r\n) => {\r\n  valueToItemInfo.clear();\r\n  captionToItemInfo.clear();\r\n\r\n  if (model == null) {\r\n    return;\r\n  }\r\n\r\n  model.forEach((item: ComboBoxItemGroup, firstLevelIndex: number) => {\r\n    const firstLevelItemInfo: ComboBoxItemModelExtended = {\r\n      item: item,\r\n      index: {\r\n        type: \"first-level\",\r\n        firstLevelIndex: firstLevelIndex\r\n      }\r\n    };\r\n\r\n    // First level item\r\n    valueToItemInfo.set(item.value, firstLevelItemInfo);\r\n    if (item.caption) {\r\n      captionToItemInfo.set(item.caption, firstLevelItemInfo);\r\n    }\r\n\r\n    // Second level items\r\n    item.items?.forEach((subItem, secondLevelIndex) => {\r\n      const secondLevelItemInfo: ComboBoxItemModelExtended = {\r\n        item: subItem,\r\n        index: {\r\n          type: \"nested\",\r\n          firstLevelIndex: firstLevelIndex,\r\n          secondLevelIndex: secondLevelIndex\r\n        }\r\n      };\r\n\r\n      valueToItemInfo.set(subItem.value, secondLevelItemInfo);\r\n\r\n      if (subItem.caption) {\r\n        captionToItemInfo.set(subItem.caption, secondLevelItemInfo);\r\n      }\r\n    });\r\n  });\r\n};\r\n\r\nexport const popoverWasClicked = (event: Event) => {\r\n  const composedPath = event.composedPath();\r\n\r\n  for (let index = 0; index < composedPath.length; index++) {\r\n    const element = composedPath[index] as HTMLElement;\r\n    const elementName = element.tagName?.toLowerCase();\r\n\r\n    if (elementName === (\"ch-popover\" satisfies ChameleonControlsTagName)) {\r\n      return true;\r\n    }\r\n    // The ch-popover tag does not exists in the path. There is no need to\r\n    // check the rest of the path\r\n    if (\r\n      elementName === (\"ch-combo-box-render\" satisfies ChameleonControlsTagName)\r\n    ) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nexport const getComboBoxItemFromMouseEvent = (\r\n  event: MouseEvent,\r\n  model: ComboBoxModel\r\n): ComboBoxItemModel | undefined => {\r\n  event.stopPropagation();\r\n\r\n  let elementTarget = event.target as HTMLButtonElement;\r\n\r\n  // Expandable button case\r\n  if (elementTarget.tagName?.toLowerCase() === \"span\") {\r\n    elementTarget = elementTarget.parentElement as HTMLButtonElement;\r\n  }\r\n\r\n  if (elementTarget.tagName?.toLowerCase() !== \"button\") {\r\n    return undefined;\r\n  }\r\n  const itemIndex = elementTarget.id;\r\n  return getComboBoxItemUIModel(itemIndex, model);\r\n};\r\n\r\n// TODO: Add a unit test for this check\r\nconst isActiveDescendant = (\r\n  item: ComboBoxItemModel | undefined,\r\n  activeDescendant: ComboBoxItemModel\r\n) =>\r\n  item &&\r\n  (item.value === activeDescendant.value ||\r\n    (item.caption && item.caption === activeDescendant.caption));\r\n\r\nconst checkIfSecondLevelModelContainsActiveDescendant = (\r\n  activeDescendant: ComboBoxItemModel | undefined,\r\n  model: ComboBoxModel\r\n) => {\r\n  for (let secondIndex = 0; secondIndex < model.length; secondIndex++) {\r\n    const secondLevelItem = model[secondIndex];\r\n\r\n    if (isActiveDescendant(secondLevelItem, activeDescendant)) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\nexport const comboBoxActiveDescendantIsRendered = (\r\n  activeDescendant: ComboBoxItemModel | undefined,\r\n  model: ComboBoxModel | undefined\r\n) => {\r\n  if (!activeDescendant || !model) {\r\n    return false;\r\n  }\r\n\r\n  for (let firstIndex = 0; firstIndex < model.length; firstIndex++) {\r\n    const firstLevelItem = model[firstIndex] as ComboBoxItemGroup;\r\n\r\n    if (isActiveDescendant(firstLevelItem, activeDescendant)) {\r\n      return true;\r\n    }\r\n    if (\r\n      firstLevelItem.items != null &&\r\n      checkIfSecondLevelModelContainsActiveDescendant(\r\n        activeDescendant,\r\n        firstLevelItem.items\r\n      )\r\n    ) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n","import {\r\n  ComboBoxItemGroup,\r\n  ComboBoxItemModel,\r\n  ComboBoxItemModelExtended,\r\n  ComboBoxModel,\r\n  ComboBoxSelectedIndex\r\n} from \"./types\";\r\n\r\nconst SELECTED_VALUE_DOES_NOT_EXISTS: ComboBoxSelectedIndex = {\r\n  type: \"not-exists\"\r\n} as const;\r\n\r\nconst isValidIndex = (array: any, index: number) =>\r\n  0 <= index && index < array.length;\r\n\r\nexport const findSelectedIndex = (\r\n  valueToItemInfo: Map<string, ComboBoxItemModelExtended>,\r\n  activeDescendant: ComboBoxItemModel | undefined\r\n): ComboBoxSelectedIndex => {\r\n  if (!activeDescendant) {\r\n    return SELECTED_VALUE_DOES_NOT_EXISTS;\r\n  }\r\n\r\n  return (\r\n    valueToItemInfo.get(activeDescendant.value)?.index ??\r\n    SELECTED_VALUE_DOES_NOT_EXISTS\r\n  );\r\n};\r\n\r\nexport const findNextSelectedIndex = (\r\n  model: ComboBoxModel,\r\n  currentIndex: ComboBoxSelectedIndex,\r\n  increment: 1 | -1,\r\n  hasFilters: boolean,\r\n  displayedValues: Set<ComboBoxItemModel>\r\n): ComboBoxSelectedIndex => {\r\n  if (currentIndex.type === \"not-exists\") {\r\n    return SELECTED_VALUE_DOES_NOT_EXISTS;\r\n  }\r\n  const firstLevelIndex = currentIndex.firstLevelIndex;\r\n\r\n  if (currentIndex.type === \"nested\") {\r\n    let secondLevelIndex = currentIndex.secondLevelIndex + increment; // Start from the first valid index\r\n    const firstLevelItemItems = (model[firstLevelIndex] as ComboBoxItemGroup)\r\n      .items;\r\n\r\n    // Search in the nested level skipping disabled and not rendered items\r\n    while (\r\n      isValidIndex(firstLevelItemItems, secondLevelIndex) &&\r\n      (firstLevelItemItems[secondLevelIndex].disabled ||\r\n        (hasFilters &&\r\n          !displayedValues.has(firstLevelItemItems[secondLevelIndex])))\r\n    ) {\r\n      secondLevelIndex += increment;\r\n    }\r\n\r\n    // If the index is not after the end of the array, the new selected value\r\n    // was found\r\n    if (isValidIndex(firstLevelItemItems, secondLevelIndex)) {\r\n      return {\r\n        type: \"nested\",\r\n        firstLevelIndex: firstLevelIndex,\r\n        secondLevelIndex: secondLevelIndex\r\n      };\r\n    }\r\n  }\r\n\r\n  // At this point, either all items in the nested level were disabled or the\r\n  // \"currentIndex\" was not nested. In any case, we must check the next item\r\n  // in the first level\r\n  let nextFirstLevelIndex = firstLevelIndex + increment;\r\n\r\n  // Search for the next first level item that is not disabled and is not filtered\r\n  while (\r\n    isValidIndex(model, nextFirstLevelIndex) &&\r\n    (model[nextFirstLevelIndex].disabled ||\r\n      (hasFilters && !displayedValues.has(model[nextFirstLevelIndex])))\r\n  ) {\r\n    nextFirstLevelIndex += increment;\r\n  }\r\n\r\n  // With this flag, we also say that we are at the end of the combo-box\r\n  // and there isn't any new \"next value\" to select\r\n  if (!isValidIndex(model, nextFirstLevelIndex)) {\r\n    return SELECTED_VALUE_DOES_NOT_EXISTS;\r\n  }\r\n\r\n  const nestedLevel = (model[nextFirstLevelIndex] as ComboBoxItemGroup).items;\r\n\r\n  if (nestedLevel != null) {\r\n    return findNextSelectedIndex(\r\n      model,\r\n      {\r\n        type: \"nested\",\r\n        firstLevelIndex: nextFirstLevelIndex,\r\n        secondLevelIndex: increment === 1 ? -1 : nestedLevel.length // The algorithm will sum 1 (or -1) to the start index\r\n      },\r\n      increment,\r\n      hasFilters,\r\n      displayedValues\r\n    );\r\n  }\r\n\r\n  return {\r\n    type: \"first-level\",\r\n    firstLevelIndex: nextFirstLevelIndex\r\n  };\r\n};\r\n","import {\r\n  GxImageMultiStateEnd,\r\n  GxImageMultiStateStart\r\n} from \"../../common/types\";\r\nimport { updateDirectionInImageCustomVar } from \"../../common/utils\";\r\nimport {\r\n  ComboBoxImagePathCallback,\r\n  ComboBoxItemGroup,\r\n  ComboBoxItemImagesModel,\r\n  ComboBoxItemModel,\r\n  ComboBoxModel\r\n} from \"./types\";\r\n\r\nexport const computeComboBoxItemImage = (\r\n  itemUIModel: ComboBoxItemModel,\r\n  iconDirection: \"start\" | \"end\",\r\n  getImagePathCallback: ComboBoxImagePathCallback\r\n) => {\r\n  const img = getImagePathCallback(itemUIModel, iconDirection);\r\n  return img\r\n    ? (updateDirectionInImageCustomVar(img, iconDirection) as\r\n        | GxImageMultiStateStart\r\n        | GxImageMultiStateEnd)\r\n    : undefined;\r\n};\r\n\r\nconst setComboBoxImagesForMap = (\r\n  model: ComboBoxModel | undefined,\r\n  getImagePathCallback: ComboBoxImagePathCallback | undefined,\r\n  itemImages: Map<string, ComboBoxItemImagesModel> | undefined\r\n) => {\r\n  for (let index = 0; index < model.length; index++) {\r\n    const itemUIModel = model[index] as ComboBoxItemGroup;\r\n    let computedImageModel: ComboBoxItemImagesModel | undefined;\r\n\r\n    // startImgSrc\r\n    if (itemUIModel.startImgSrc) {\r\n      const computedImage = computeComboBoxItemImage(\r\n        itemUIModel,\r\n        \"start\",\r\n        getImagePathCallback\r\n      ) as GxImageMultiStateStart;\r\n\r\n      computedImageModel = { start: computedImage };\r\n    }\r\n\r\n    // endImgSrc\r\n    if (itemUIModel.endImgSrc) {\r\n      const computedImage = computeComboBoxItemImage(\r\n        itemUIModel,\r\n        \"end\",\r\n        getImagePathCallback\r\n      ) as GxImageMultiStateEnd;\r\n\r\n      if (computedImageModel) {\r\n        computedImageModel.end = computedImage;\r\n      } else {\r\n        computedImageModel = { end: computedImage };\r\n      }\r\n    }\r\n\r\n    if (computedImageModel) {\r\n      itemImages.set(itemUIModel.value, computedImageModel);\r\n    }\r\n\r\n    // Recursive phase\r\n    if (itemUIModel.items != null) {\r\n      setComboBoxImagesForMap(\r\n        itemUIModel.items,\r\n        getImagePathCallback,\r\n        itemImages\r\n      );\r\n    }\r\n  }\r\n};\r\n\r\nexport const getComboBoxImages = (\r\n  model: ComboBoxModel | undefined,\r\n  getImagePathCallback: ComboBoxImagePathCallback | undefined\r\n): Map<string, ComboBoxItemImagesModel> | undefined => {\r\n  if (!model) {\r\n    return undefined;\r\n  }\r\n  const itemImages: Map<string, ComboBoxItemImagesModel> = new Map();\r\n  setComboBoxImagesForMap(model, getImagePathCallback, itemImages);\r\n\r\n  return itemImages;\r\n};\r\n","@import \"../../common/base\";\r\n@import \"../../common/icons\";\r\n\r\n@include input-reset();\r\n@include button-reset(); // Should be placed before the box-sizing reset\r\n@include box-sizing();\r\n\r\n:host {\r\n  /**\r\n   * @prop --ch-combo-box-group__expandable-button-size:\r\n   * Specifies the expandable button size in the group items.\r\n   * @default #{$default-decorative-image-size}\r\n   */\r\n  --ch-combo-box-group__expandable-button-size: #{$default-decorative-image-size};\r\n\r\n  /**\r\n   * @prop --ch-combo-box-group__expandable-button-image-size:\r\n   * Specifies the image size of the expandable button size in the group items. \r\n   * @default 100%\r\n   */\r\n  --ch-combo-box-group__expandable-button-image-size: #{$default-decorative-image-size};\r\n\r\n  /**\r\n   * @prop --ch-combo-box-item__image-size:\r\n   * Specifies the box size that contains an image in the items. For example,\r\n   * the box for the startImgSrc and endImgSrc\r\n   * @default #{$default-decorative-image-size}\r\n   */\r\n  --ch-combo-box-item__image-size: #{$default-decorative-image-size};\r\n\r\n  /**\r\n   * @prop --ch-combo-box-item__background-image-size:\r\n   * Specifies the image size of the items. For example, the image size for the\r\n   * startImgSrc and endImgSrc\r\n   * @default 100%\r\n   */\r\n  --ch-combo-box-item__background-image-size: 100%;\r\n\r\n  /**\r\n   * @prop --ch-combo-box__picker:\r\n   * Specifies the image of the combo-box's picker.\r\n   * @default url('data:image/svg+xml,<svg width=\"8\" height=\"12\" viewBox=\"0 0 8 12\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4.16669 0.666626L7.66669 4.66663H0.666687L4.16669 0.666626ZM4.16669 11.3333L0.666687 7.33329H7.66669L4.16669 11.3333Z\"/></svg>')\r\n   */\r\n  --ch-combo-box__picker: url('data:image/svg+xml,<svg width=\"8\" height=\"12\" viewBox=\"0 0 8 12\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4.16669 0.666626L7.66669 4.66663H0.666687L4.16669 0.666626ZM4.16669 11.3333L0.666687 7.33329H7.66669L4.16669 11.3333Z\"/></svg>');\r\n\r\n  /**\r\n   * @prop --ch-combo-box__picker-color:\r\n   * Specifies the color of the combo-box's picker.\r\n   * @default currentColor\r\n   */\r\n  --ch-combo-box__picker-color: currentColor;\r\n\r\n  /**\r\n   * @prop --ch-combo-box__picker-size:\r\n   * Specifies the box size that contains the combo-box's picker.\r\n   * @default #{$default-decorative-image-size}\r\n   */\r\n  --ch-combo-box__picker-size: #{$default-decorative-image-size};\r\n\r\n  /**\r\n   * @prop --ch-combo-box__picker-mask-size:\r\n   * Specifies the image size of the combo-box's picker.\r\n   * @default 100%\r\n   */\r\n  --ch-combo-box__picker-image-size: 100%;\r\n\r\n  /**\r\n   * @prop --ch-combo-box-item-gap:\r\n   * Specifies the spacing between the images, text and the expandable button\r\n   * on items.\r\n   * @default 0px\r\n   */\r\n  --ch-combo-box-item-gap: 0px;\r\n\r\n  /**\r\n   * @prop --ch-combo-box-separation:\r\n   * Specifies the separation between the combo-box and the displayed popover.\r\n   * @default 0px\r\n   */\r\n  --ch-combo-box-separation: 0px;\r\n\r\n  /**\r\n   * @prop --ch-combo-box-separation-x:\r\n   * Specifies the separation between the combo-box and the popover displayed\r\n   * on the x-axis.\r\n   * @default var(--ch-combo-box-separation)\r\n   */\r\n  --ch-combo-box-separation-x: var(--ch-combo-box-separation);\r\n\r\n  /**\r\n   * @prop --ch-combo-box-separation-y:\r\n   * Specifies the separation between the combo-box and the popover displayed\r\n   * on the y-axis.\r\n   * @default var(--ch-combo-box-separation)\r\n   */\r\n  --ch-combo-box-separation-y: var(--ch-combo-box-separation);\r\n\r\n  display: inline-grid;\r\n  grid-template-columns: 1fr max-content;\r\n  grid-template-rows: max-content 1fr;\r\n  align-items: center;\r\n\r\n  &::after {\r\n    grid-row: 1 / 3;\r\n    grid-column: 2;\r\n    inline-size: var(--ch-combo-box__picker-size);\r\n    block-size: var(--ch-combo-box__picker-size);\r\n    -webkit-mask: var(--ch-combo-box__picker) 50% 50% /\r\n      var(--ch-combo-box__picker-image-size)\r\n      var(--ch-combo-box__picker-image-size) no-repeat;\r\n    margin-inline-start: var(--ch-combo-box-item-gap);\r\n    background-color: var(--ch-combo-box__picker-color);\r\n    pointer-events: none;\r\n  }\r\n}\r\n\r\n:host(.ch-combo-box--normal) {\r\n  cursor: pointer;\r\n  // Remove text selection on double click\r\n  user-select: none;\r\n\r\n  &::after {\r\n    content: \"\";\r\n  }\r\n}\r\n\r\n:host(.ch-combo-box--suggest) {\r\n  --ch-combo-box__picker-size: 0px;\r\n  cursor: text;\r\n}\r\n\r\n:host(.ch-disabled) {\r\n  pointer-events: none;\r\n}\r\n\r\n.input-container {\r\n  grid-row: 2 / 3;\r\n\r\n  // Remove outline of the focus state.\r\n  outline: unset;\r\n}\r\n\r\n.invisible-text {\r\n  visibility: hidden;\r\n  pointer-events: none;\r\n  block-size: 0;\r\n\r\n  // TODO: Add a unit test to verify that the input does not overflows the\r\n  // combo-box when it has a reduced width (for example, 120px)\r\n  overflow: hidden;\r\n}\r\n\r\nselect {\r\n  all: unset;\r\n  display: grid;\r\n  overflow: hidden;\r\n  grid-row: 2 / 3;\r\n}\r\n\r\n.value {\r\n  display: inline-grid;\r\n  align-items: center;\r\n\r\n  // TODO: Add a unit test to verify that the input does not overflows the\r\n  // combo-box when it has a reduced width (for example, 120px)\r\n  inline-size: 100%;\r\n\r\n  &--readonly {\r\n    pointer-events: none;\r\n    text-overflow: ellipsis;\r\n  }\r\n}\r\n\r\n// - - - - - - - - - - - - - - - -\r\n//           Separation\r\n// - - - - - - - - - - - - - - - -\r\nch-popover {\r\n  --ch-popover-separation-x: var(--ch-combo-box-separation-x);\r\n  --ch-popover-separation-y: var(--ch-combo-box-separation-y);\r\n\r\n  // We must reset the cursor to avoid the inheriting \"cursor: pointer\" from\r\n  // the Host\r\n  cursor: auto;\r\n\r\n  // --ch-popover-min-inline-size: var(--ch-popover-action-width);\r\n\r\n  &:not(.hydrated) {\r\n    opacity: 0;\r\n  }\r\n}\r\n\r\n// - - - - - - - - - - - - - - - -\r\n//         Leaf and Group\r\n// - - - - - - - - - - - - - - - -\r\n.leaf,\r\n.group__header,\r\n.group__header-caption,\r\n.input-container {\r\n  display: flex;\r\n  gap: var(--ch-combo-box-item-gap);\r\n  align-items: center;\r\n  flex: 1; // Necessary to properly align the end image in expandable groups\r\n}\r\n\r\n.group {\r\n  display: grid;\r\n  grid-template-rows: max-content 1fr;\r\n\r\n  &--expandable {\r\n    &::before {\r\n      content: \"\";\r\n      inline-size: var(--ch-combo-box-group__expandable-button-size);\r\n      block-size: var(--ch-combo-box-group__expandable-button-size);\r\n      background-color: currentColor;\r\n      -webkit-mask: $expandable-icon 50% 50% /\r\n        var(--ch-combo-box-group__expandable-button-image-size)\r\n        var(--ch-combo-box-group__expandable-button-image-size) no-repeat;\r\n    }\r\n  }\r\n\r\n  &--collapsed::before {\r\n    transform: rotate(-90deg); // TODO: Add RTL support\r\n  }\r\n\r\n  &__content {\r\n    display: grid;\r\n    grid-auto-rows: max-content;\r\n\r\n    &--collapsed {\r\n      display: none;\r\n    }\r\n  }\r\n}\r\n\r\n// - - - - - - - - - - - - - - - -\r\n//             Images\r\n// - - - - - - - - - - - - - - - -\r\n.img--start::before,\r\n.img--end::after {\r\n  content: \"\";\r\n  display: block;\r\n  inline-size: var(--ch-combo-box-item__image-size);\r\n  block-size: var(--ch-combo-box-item__image-size);\r\n  min-inline-size: var(--ch-combo-box-item__image-size);\r\n  pointer-events: none; // TODO: Add a unit test for this\r\n}\r\n\r\n.img--start {\r\n  --ch-combo-box-item-start-img: var(--ch-start-img--base);\r\n\r\n  // Leafs (role=\"option\") only supports selected and disabled state.\r\n  &.selected.start-img--selected {\r\n    --ch-combo-box-item-start-img: var(--ch-start-img--selected);\r\n  }\r\n\r\n  // Group header\r\n  .group__header:hover > &.start-img--hover {\r\n    --ch-combo-box-item-start-img: var(--ch-start-img--hover);\r\n  }\r\n\r\n  .group__header:active > &.start-img--active {\r\n    --ch-combo-box-item-start-img: var(--ch-start-img--active);\r\n  }\r\n\r\n  // Icon on the Host\r\n  :host(:focus) &.input-container.start-img--focus {\r\n    --ch-combo-box-item-start-img: var(--ch-start-img--focus);\r\n  }\r\n\r\n  :host(:not(.ch-disabled):hover) &.input-container.start-img--hover {\r\n    --ch-combo-box-item-start-img: var(--ch-start-img--hover);\r\n  }\r\n\r\n  // Disabled\r\n  &.disabled.start-img--disabled,\r\n  .disabled > &.start-img--disabled,\r\n  :host(.ch-disabled) &.start-img--disabled {\r\n    --ch-combo-box-item-start-img: var(--ch-start-img--disabled);\r\n  }\r\n}\r\n\r\n.img--end {\r\n  --ch-combo-box-item-end-img: var(--ch-end-img--base);\r\n\r\n  &::after {\r\n    margin-inline-start: auto;\r\n  }\r\n\r\n  // Leafs (role=\"option\") only supports selected and disabled state.\r\n  &.selected.end-img--selected {\r\n    --ch-combo-box-item-end-img: var(--ch-end-img--selected);\r\n  }\r\n\r\n  .group__header:hover > &.end-img--hover {\r\n    --ch-combo-box-item-end-img: var(--ch-end-img--hover);\r\n  }\r\n\r\n  .group__header:active > &.end-img--active {\r\n    --ch-combo-box-item-end-img: var(--ch-end-img--active);\r\n  }\r\n\r\n  &.disabled.end-img--disabled,\r\n  .disabled > &.end-img--disabled {\r\n    --ch-combo-box-item-end-img: var(--ch-end-img--disabled);\r\n  }\r\n}\r\n\r\n.start-img-type--background::before {\r\n  background: no-repeat center / var(--ch-combo-box-item__background-image-size)\r\n    var(--ch-combo-box-item-start-img);\r\n}\r\n\r\n.end-img-type--background::after {\r\n  background: no-repeat center / var(--ch-combo-box-item__background-image-size)\r\n    var(--ch-combo-box-item-end-img);\r\n}\r\n\r\n.start-img-type--mask::before {\r\n  -webkit-mask: no-repeat center /\r\n    var(--ch-combo-box-item__background-image-size)\r\n    var(--ch-combo-box-item-start-img);\r\n  background-color: currentColor;\r\n}\r\n\r\n.end-img-type--mask::after {\r\n  -webkit-mask: no-repeat center /\r\n    var(--ch-combo-box-item__background-image-size)\r\n    var(--ch-combo-box-item-end-img);\r\n  background-color: currentColor;\r\n}\r\n","import {\r\n  AttachInternals,\r\n  Component,\r\n  Element,\r\n  Event,\r\n  EventEmitter,\r\n  Host,\r\n  Prop,\r\n  State,\r\n  Watch,\r\n  forceUpdate,\r\n  h\r\n} from \"@stencil/core\";\r\nimport {\r\n  AccessibleNameComponent,\r\n  DisableableComponent\r\n} from \"../../common/interfaces\";\r\nimport {\r\n  ComboBoxSuggestOptions,\r\n  ComboBoxItemModel,\r\n  ComboBoxItemGroup,\r\n  ComboBoxSuggestInfo,\r\n  ComboBoxModel,\r\n  ComboBoxSelectedIndex,\r\n  ComboBoxItemModelExtended,\r\n  ComboBoxItemImagesModel,\r\n  ComboBoxImagePathCallback\r\n} from \"./types\";\r\nimport { focusComposedPath } from \"../common/helpers\";\r\nimport {\r\n  COMBO_BOX_HOST_PARTS,\r\n  COMBO_BOX_PARTS_DICTIONARY,\r\n  KEY_CODES\r\n} from \"../../common/reserved-names\";\r\nimport { isMobileDevice, tokenMap } from \"../../common/utils\";\r\nimport { ChPopoverAlign } from \"../popover/types\";\r\nimport { ChPopoverCustomEvent, GxImageMultiState } from \"../../components\";\r\nimport { filterSubModel } from \"./helpers\";\r\nimport {\r\n  comboBoxActiveDescendantIsRendered,\r\n  findComboBoxLargestValue,\r\n  getComboBoxItemFromMouseEvent,\r\n  mapValuesToItemInfo,\r\n  popoverWasClicked\r\n} from \"./utils\";\r\nimport { findNextSelectedIndex, findSelectedIndex } from \"./navigation\";\r\nimport { customComboBoxItemRender, nativeItemRender } from \"./renders\";\r\nimport { computeComboBoxItemImage, getComboBoxImages } from \"./item-images\";\r\nimport { getControlRegisterProperty } from \"../../common/registry-properties\";\r\nimport { GxImageMultiStateStart } from \"../../common/types\";\r\nimport {\r\n  analyzeLabelExistence,\r\n  getElementInternalsLabel\r\n} from \"../../common/analysis/accessibility\";\r\n\r\nconst SELECTED_ITEM_SELECTOR = `button[part*='${COMBO_BOX_PARTS_DICTIONARY.SELECTED}']`;\r\nconst mobileDevice = isMobileDevice();\r\n\r\nconst DEFAULT_GET_IMAGE_PATH_CALLBACK = (\r\n  itemUIModel: ComboBoxItemModel,\r\n  iconDirection: \"start\" | \"end\"\r\n): GxImageMultiState => ({\r\n  base:\r\n    iconDirection === \"start\" ? itemUIModel.startImgSrc : itemUIModel.endImgSrc\r\n});\r\n\r\n// Keys\r\ntype KeyDownNoFiltersEvents =\r\n  | typeof KEY_CODES.ARROW_UP\r\n  | typeof KEY_CODES.ARROW_DOWN\r\n  | typeof KEY_CODES.HOME\r\n  | typeof KEY_CODES.END\r\n  | typeof KEY_CODES.ENTER\r\n  | typeof KEY_CODES.SPACE\r\n  | typeof KEY_CODES.TAB;\r\n\r\ntype KeyDownWithFiltersEvents =\r\n  | typeof KEY_CODES.ARROW_UP\r\n  | typeof KEY_CODES.ARROW_DOWN\r\n  | typeof KEY_CODES.ENTER\r\n  | typeof KEY_CODES.TAB;\r\n\r\n/**\r\n * @status experimental\r\n *\r\n * The ch-combo-box-render is an input widget that has an associated popup. The\r\n * popup enables users to choose a value for the input from a collection.\r\n *  - Items are only rendered when the popup is displayed.\r\n *\r\n * @part ... - ...\r\n */\r\n@Component({\r\n  formAssociated: true,\r\n  shadow: { delegatesFocus: true },\r\n  styleUrl: \"combo-box.scss\",\r\n  tag: \"ch-combo-box-render\"\r\n})\r\nexport class ChComboBoxRender\r\n  implements AccessibleNameComponent, DisableableComponent\r\n{\r\n  #accessibleNameFromExternalLabel: string | undefined;\r\n\r\n  /**\r\n   * This variable is used to emulate the behavior of the native select. The\r\n   * native select decides its min size based on the size of the largest option.\r\n   */\r\n  // eslint-disable-next-line @stencil-community/own-props-must-be-private\r\n  #largestValue: string;\r\n\r\n  /**\r\n   * Last value that was set correctly in the control. Useful to revert the\r\n   * value when applying strict filters.\r\n   */\r\n  // eslint-disable-next-line @stencil-community/own-props-must-be-private\r\n  #lastConfirmedValue: string;\r\n\r\n  #valueToItemInfo: Map<string, ComboBoxItemModelExtended> = new Map();\r\n  #captionToItemInfo: Map<string, ComboBoxItemModelExtended> = new Map();\r\n  #itemImages: Map<string, ComboBoxItemImagesModel> | undefined;\r\n\r\n  // Filters info\r\n  #applyFilters = false;\r\n  #queuedInputValueUpdate: NodeJS.Timeout;\r\n\r\n  /**\r\n   * Collection of displayed values. If a filter is applied and the value\r\n   * belongs to this Set, the item is displayed.\r\n   */\r\n  // eslint-disable-next-line @stencil-community/own-props-must-be-private\r\n  #displayedValues: Set<ComboBoxItemModel> | undefined; // Don't allocate memory until needed\r\n\r\n  #selectNextIndex = (\r\n    event: KeyboardEvent,\r\n    currentSelectedIndex: ComboBoxSelectedIndex,\r\n    increment: 1 | -1,\r\n    hasFilters: boolean,\r\n    displayedValues: Set<ComboBoxItemModel>\r\n  ) => {\r\n    event.preventDefault(); // Stop ArrowDown key from scrolling\r\n\r\n    const nextSelectedIndex =\r\n      currentSelectedIndex.type === \"not-exists\"\r\n        ? findNextSelectedIndex(\r\n            this.model,\r\n            {\r\n              type: \"first-level\",\r\n              firstLevelIndex: increment === 1 ? -1 : this.model.length\r\n            },\r\n            increment,\r\n            hasFilters,\r\n            displayedValues\r\n          )\r\n        : findNextSelectedIndex(\r\n            this.model,\r\n            currentSelectedIndex,\r\n            increment,\r\n            hasFilters,\r\n            displayedValues\r\n          );\r\n\r\n    if (nextSelectedIndex.type === \"not-exists\") {\r\n      return;\r\n    }\r\n\r\n    // The new selected value is either in the first level or in the group\r\n    const newSelectedValue =\r\n      nextSelectedIndex.type === \"first-level\"\r\n        ? this.model[nextSelectedIndex.firstLevelIndex]\r\n        : (this.model[nextSelectedIndex.firstLevelIndex] as ComboBoxItemGroup)\r\n            .items[nextSelectedIndex.secondLevelIndex];\r\n\r\n    if (this.activeDescendant !== newSelectedValue) {\r\n      this.activeDescendant = newSelectedValue;\r\n    }\r\n  };\r\n\r\n  // Keyboard events when the control has no filters\r\n  #keyEventsNoFiltersDictionary: {\r\n    [key in KeyDownNoFiltersEvents]: (event: KeyboardEvent) => void;\r\n  } = {\r\n    ArrowUp: (event: KeyboardEvent) =>\r\n      this.#selectNextIndex(\r\n        event,\r\n        findSelectedIndex(this.#valueToItemInfo, this.activeDescendant),\r\n        -1,\r\n        this.suggest && !this.#isModelAlreadyFiltered(),\r\n        this.#displayedValues\r\n      ),\r\n\r\n    ArrowDown: (event: KeyboardEvent) =>\r\n      this.#selectNextIndex(\r\n        event,\r\n        findSelectedIndex(this.#valueToItemInfo, this.activeDescendant),\r\n        1,\r\n        this.suggest && !this.#isModelAlreadyFiltered(),\r\n        this.#displayedValues\r\n      ),\r\n\r\n    Home: (event: KeyboardEvent) =>\r\n      this.#selectNextIndex(\r\n        event,\r\n        {\r\n          type: \"first-level\",\r\n          firstLevelIndex: -1\r\n        }, // The algorithm will sum 1 to the start index\r\n        1,\r\n        this.suggest && !this.#isModelAlreadyFiltered(),\r\n        this.#displayedValues\r\n      ),\r\n\r\n    End: (event: KeyboardEvent) =>\r\n      this.#selectNextIndex(\r\n        event,\r\n        {\r\n          type: \"first-level\",\r\n          firstLevelIndex: this.model.length\r\n        }, // The algorithm will sum -1 to the start index\r\n        -1,\r\n        this.suggest && !this.#isModelAlreadyFiltered(),\r\n        this.#displayedValues\r\n      ),\r\n\r\n    Enter: () => {\r\n      // The focus must return to the Host when closing the popover\r\n      if (this.expanded) {\r\n        this.el.focus();\r\n      }\r\n\r\n      this.expanded = !this.expanded;\r\n    },\r\n\r\n    Space: event => {\r\n      event.preventDefault(); // Stop space key from scrolling\r\n\r\n      // Only expands the ComboBox\r\n      this.expanded ||= true;\r\n    },\r\n\r\n    Tab: event => {\r\n      // The focus must return to the Host when tabbing with the popover\r\n      // expanded\r\n      if (this.expanded) {\r\n        event.preventDefault();\r\n\r\n        this.el.focus();\r\n        this.expanded = false;\r\n      }\r\n    }\r\n  };\r\n\r\n  // Keyboard events when the control has filters\r\n  #keyEventsWithFiltersDictionary: {\r\n    [key in KeyDownWithFiltersEvents]: (event: KeyboardEvent) => void;\r\n  } = {\r\n    ArrowUp: (event: KeyboardEvent) => {\r\n      if (this.expanded) {\r\n        this.#keyEventsNoFiltersDictionary.ArrowUp(event);\r\n      } else {\r\n        this.expanded = true;\r\n      }\r\n    },\r\n\r\n    ArrowDown: (event: KeyboardEvent) => {\r\n      if (this.expanded) {\r\n        this.#keyEventsNoFiltersDictionary.ArrowDown(event);\r\n      } else {\r\n        this.expanded = true;\r\n      }\r\n    },\r\n\r\n    Enter: (event: KeyboardEvent) =>\r\n      this.#checkAndEmitValueChangeWithFilters(event),\r\n\r\n    Tab: (event: KeyboardEvent) =>\r\n      this.#checkAndEmitValueChangeWithFilters(event)\r\n  };\r\n\r\n  // Refs\r\n  // #maskRef: HTMLDivElement;\r\n  #inputRef: HTMLInputElement;\r\n  #selectRef: HTMLSelectElement | undefined;\r\n\r\n  /**\r\n   * When the combo-box is expanded, the visually selected value must change,\r\n   * but in the interface the `value` property must only change when the\r\n   * popover is closed.\r\n   * This state help us to render the visually selected value, without updating\r\n   * the `value` property in the interface.\r\n   */\r\n  @State() activeDescendant: ComboBoxItemModel | undefined;\r\n\r\n  @State() expanded = false;\r\n  @Watch(\"expanded\")\r\n  handleExpandedChange(newExpandedValue: boolean) {\r\n    if (newExpandedValue && !mobileDevice) {\r\n      this.#setComboBoxIcons();\r\n\r\n      // Sync the active descendant when expanding the combo-box\r\n      this.#syncActiveDescendant();\r\n\r\n      // TODO: Add a unit test for this case\r\n      // When the control is expanded and has filters applied, we should\r\n      // refresh the rendered items without any debounce\r\n      if (this.suggest) {\r\n        this.#scheduleFilterProcessing();\r\n      }\r\n    }\r\n    // Free the memory, since the combo-box does not won't render any images\r\n    else {\r\n      this.#itemImages = undefined;\r\n    }\r\n  }\r\n\r\n  @AttachInternals() internals: ElementInternals;\r\n\r\n  @Element() el: HTMLChComboBoxRenderElement;\r\n\r\n  /**\r\n   * Specifies a short string, typically 1 to 3 words, that authors associate\r\n   * with an element to provide users of assistive technologies with a label\r\n   * for the element.\r\n   */\r\n  @Prop() readonly accessibleName?: string;\r\n\r\n  /**\r\n   * This attribute lets you specify if the element is disabled.\r\n   * If disabled, it will not fire any user interaction related event\r\n   * (for example, click event).\r\n   */\r\n  @Prop() readonly disabled: boolean = false;\r\n\r\n  /**\r\n   * This property specifies a callback that is executed when the path for an\r\n   * imgSrc needs to be resolved.\r\n   */\r\n  @Prop() readonly getImagePathCallback?: ComboBoxImagePathCallback;\r\n\r\n  /**\r\n   * Specifies a set of parts to use in the Host element (`ch-combo-box-render`).\r\n   */\r\n  @Prop() readonly hostParts?: string;\r\n\r\n  /**\r\n   * Specifies the items of the control\r\n   */\r\n  @Prop() readonly model: ComboBoxModel = [];\r\n  @Watch(\"model\")\r\n  modelChanged(newModel: ComboBoxModel) {\r\n    this.#findLargestValue(this.model);\r\n    mapValuesToItemInfo(\r\n      newModel,\r\n      this.#valueToItemInfo,\r\n      this.#captionToItemInfo\r\n    );\r\n\r\n    // TODO: Add a unit test for this\r\n    // The model can change when the combo-box is expanded by having server\r\n    // filters. In this case, we need to re-compute the icons\r\n    if (this.expanded) {\r\n      this.#setComboBoxIcons();\r\n    }\r\n\r\n    // this.#checkIfCurrentSelectedValueIsNoLongerValid();\r\n\r\n    // This must be the last operation, since it needs to wait for the UI Model\r\n    // Map to be updated (#valueToItemInfo)\r\n    this.#setValueInForm(this.value);\r\n  }\r\n\r\n  /**\r\n   * This attribute indicates that multiple options can be selected in the list.\r\n   * If it is not specified, then only one option can be selected at a time.\r\n   * When multiple is specified, the control will show a scrolling list box\r\n   * instead of a single line dropdown.\r\n   */\r\n  @Prop() readonly multiple: boolean = false;\r\n\r\n  /**\r\n   * This property specifies the `name` of the control when used in a form.\r\n   */\r\n  @Prop({ reflect: true }) readonly name?: string;\r\n\r\n  /**\r\n   * A hint to the user of what can be entered in the control. Same as\r\n   * [placeholder](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-placeholder)\r\n   * attribute for `input` elements.\r\n   */\r\n  @Prop() readonly placeholder: string;\r\n\r\n  /**\r\n   * Specifies the inline alignment of the popover.\r\n   */\r\n  @Prop() readonly popoverInlineAlign: ChPopoverAlign = \"inside-start\";\r\n\r\n  /**\r\n   * This attribute indicates that the user cannot modify the value of the control.\r\n   * Same as [readonly](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-readonly)\r\n   * attribute for `input` elements.\r\n   */\r\n  @Prop() readonly readonly: boolean = false;\r\n\r\n  /**\r\n   * Specifies whether the control can be resized. If `true` the control can be\r\n   * resized at runtime by dragging the edges or corners.\r\n   */\r\n  @Prop() readonly resizable: boolean = false;\r\n\r\n  /**\r\n   * This property lets you specify if the control behaves like a suggest.\r\n   * If `true` the combo-box value will be editable an displayed items will be\r\n   * filtered according to the input's value.\r\n   */\r\n  @Prop() readonly suggest: boolean = false;\r\n  @Watch(\"suggest\")\r\n  suggestChanged() {\r\n    this.#scheduleFilterProcessing();\r\n  }\r\n\r\n  /**\r\n   * This property lets you determine the debounce time (in ms) that the\r\n   * control waits until it processes the changes to the filter property.\r\n   * Consecutive changes to the `value` property between this range, reset the\r\n   * timeout to process the value.\r\n   * Only works if `suggest === true`.\r\n   */\r\n  @Prop() readonly suggestDebounce: number = 250;\r\n  @Watch(\"suggestDebounce\")\r\n  suggestDebounceChanged() {\r\n    if (this.suggest) {\r\n      this.#scheduleFilterProcessing();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This property lets you determine the options that will be applied to the\r\n   * suggest.\r\n   */\r\n  @Prop() readonly suggestOptions: ComboBoxSuggestOptions = {};\r\n  @Watch(\"suggestOptions\")\r\n  suggestOptionsChanged() {\r\n    this.#scheduleFilterProcessing();\r\n  }\r\n\r\n  /**\r\n   * Specifies the value (selected item) of the control.\r\n   */\r\n  @Prop({ mutable: true }) value?: string;\r\n  @Watch(\"value\")\r\n  valueChanged(newValue: string) {\r\n    this.#setValueInForm(newValue);\r\n\r\n    if (this.suggest) {\r\n      this.#scheduleFilterProcessing();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The `input` event is emitted when a change to the element's value is\r\n   * committed by the user.\r\n   *\r\n   * If `suggest = true`, this event is debounced by the `suggestDebounce` value.\r\n   */\r\n  @Event() input: EventEmitter<string>;\r\n\r\n  /**\r\n   * The `change` event is emitted when a change to the element's value is\r\n   * committed by the user.\r\n   *  - In normal mode (suggest = false), it is emitted after each input event.\r\n   *\r\n   *  - In suggest mode (suggest = true), it is emitted after the popover is closed\r\n   * and a new value is committed by the user.\r\n   *\r\n   * This event is NOT debounced by the `suggestDebounce` value.\r\n   */\r\n  @Event() change: EventEmitter<string>;\r\n\r\n  #findLargestValue = (model: ComboBoxModel) => {\r\n    this.#largestValue = findComboBoxLargestValue(model);\r\n  };\r\n\r\n  #getActualImagePathCallback = () =>\r\n    this.getImagePathCallback ??\r\n    getControlRegisterProperty(\"getImagePathCallback\", \"ch-combo-box-render\") ??\r\n    DEFAULT_GET_IMAGE_PATH_CALLBACK;\r\n\r\n  #setComboBoxIcons = () => {\r\n    this.#itemImages = getComboBoxImages(\r\n      this.model,\r\n      this.#getActualImagePathCallback()\r\n    );\r\n  };\r\n\r\n  #scheduleFilterProcessing = () => {\r\n    this.#applyFilters = true;\r\n  };\r\n\r\n  #filterModel = () => {\r\n    // New filter value\r\n    this.#displayedValues.clear();\r\n\r\n    const filterOptions: ComboBoxSuggestInfo = {\r\n      filter: this.value,\r\n      options: this.suggestOptions\r\n    };\r\n\r\n    for (let index = 0; index < this.model.length; index++) {\r\n      const item = this.model[index];\r\n      filterSubModel(item, filterOptions, this.#displayedValues);\r\n    }\r\n\r\n    // Remove the active descendant if it is no longer rendered\r\n    if (!this.#displayedValues.has(this.activeDescendant)) {\r\n      this.activeDescendant = undefined;\r\n    }\r\n  };\r\n\r\n  #updateFilters = () => {\r\n    if (!this.suggest) {\r\n      this.#displayedValues = undefined;\r\n      return;\r\n    }\r\n\r\n    const modelIsAlreadyFiltered = this.#isModelAlreadyFiltered();\r\n\r\n    // Check if the model already contains the filtered items\r\n    if (!modelIsAlreadyFiltered) {\r\n      this.#displayedValues ??= new Set();\r\n      this.#filterModel();\r\n    }\r\n  };\r\n\r\n  #getCurrentValueMapping = (): ComboBoxItemModelExtended | undefined =>\r\n    this.#captionToItemInfo.get(this.value) ??\r\n    this.#valueToItemInfo.get(this.value);\r\n\r\n  #checkAndEmitValueChangeWithNoFilter = () => {\r\n    const activeDescendant = this.activeDescendant;\r\n\r\n    // TODO: Should we debounce this event?\r\n    if (activeDescendant?.value !== this.value) {\r\n      // Clear last debounce\r\n      clearTimeout(this.#queuedInputValueUpdate);\r\n\r\n      this.value = this.suggest\r\n        ? activeDescendant.caption ?? activeDescendant.value\r\n        : activeDescendant.value;\r\n\r\n      // Emit event\r\n      this.input.emit(this.value);\r\n\r\n      // Emit change event\r\n      // TODO: Add a unit test for this\r\n      this.#emitChangeEvent();\r\n    }\r\n  };\r\n\r\n  #checkAndEmitValueChangeWithFilters = (event: KeyboardEvent) => {\r\n    if (!this.expanded) {\r\n      return;\r\n    }\r\n    this.expanded = false;\r\n\r\n    // The focus must return to the Host when tabbing with the popover\r\n    // expanded\r\n    this.el.focus();\r\n    event.preventDefault();\r\n\r\n    // \"Traditional selection\". A value was selected pressing the enter key\r\n    if (this.activeDescendant) {\r\n      this.#checkAndEmitValueChangeWithNoFilter();\r\n      return;\r\n    }\r\n\r\n    // No item was selected and the suggest is not strict\r\n    if (!this.suggestOptions?.strict) {\r\n      // TODO: Add a unit test: filters, no strict, value confirmation with\r\n      // Enter or Tab. Expected: The value update should not be debounced\r\n      // TODO: Avoid emitting duplicated input events if the value did not\r\n      // changed\r\n\r\n      // Clear last debounce and update the value right away, because the value\r\n      // selection was confirmed\r\n      clearTimeout(this.#queuedInputValueUpdate);\r\n      this.value = this.#inputRef.value;\r\n      this.input.emit(this.value);\r\n\r\n      // TODO: Add a unit test for this\r\n      this.#emitChangeEvent();\r\n      return;\r\n    }\r\n\r\n    // Strict selection\r\n    const inputValueMatches = this.#getCurrentValueMapping();\r\n\r\n    if (inputValueMatches) {\r\n      // TODO: Do we have to emit the change event?\r\n\r\n      // TODO: Add a unit test for this\r\n      this.#emitChangeEvent();\r\n    }\r\n    // Revert change because the input value does not match any item value\r\n    else {\r\n      // Clear last debounce\r\n      clearTimeout(this.#queuedInputValueUpdate);\r\n\r\n      this.value = this.#lastConfirmedValue;\r\n\r\n      // Emit filter change event to recover the previous state.\r\n      // TODO: Should we debounce this event?\r\n      this.input.emit(this.value);\r\n\r\n      // TODO: Add a unit test for this\r\n      this.#emitChangeEvent();\r\n    }\r\n  };\r\n\r\n  #handleSelectChange = (event: Event) => {\r\n    event.preventDefault();\r\n\r\n    this.value = this.#selectRef.value;\r\n    this.activeDescendant = this.#valueToItemInfo.get(\r\n      this.activeDescendant.value\r\n    )?.item;\r\n\r\n    // Emit event\r\n    this.input.emit(this.value);\r\n\r\n    // TODO: Prevent change event in the native select\r\n  };\r\n\r\n  #handleExpandedChangeWithKeyBoard = (event: KeyboardEvent) => {\r\n    if (!this.suggest) {\r\n      const keyboardHandler = this.#keyEventsNoFiltersDictionary[event.code];\r\n\r\n      if (!keyboardHandler) {\r\n        return;\r\n      }\r\n      keyboardHandler(event);\r\n\r\n      if (!this.expanded) {\r\n        this.#checkAndEmitValueChangeWithNoFilter();\r\n      }\r\n    }\r\n    // Keyboard implementation for filters\r\n    else {\r\n      const keyboardHandler = this.#keyEventsWithFiltersDictionary[event.code];\r\n\r\n      if (keyboardHandler) {\r\n        keyboardHandler(event);\r\n      }\r\n    }\r\n  };\r\n\r\n  #handlePopoverClose = (event: ChPopoverCustomEvent<any>) => {\r\n    event.stopPropagation();\r\n\r\n    // The focus must return to the Host when the popover is closed using the\r\n    // Escape key\r\n    this.expanded = false;\r\n\r\n    // TODO: When destroyItemsOnClose === true, StencilJS would throw 'The\r\n    // \"popoverClosed\" event was emitted, but the dispatcher node is no longer\r\n    // connected to the dom.', because the popoverOnClose event is emitted twice\r\n    // in the ch-popover\r\n\r\n    // Return the focus to the control if the popover was closed with the\r\n    // escape key or by clicking again the combo-box\r\n    if (focusComposedPath().includes(this.el)) {\r\n      this.el.focus();\r\n    }\r\n\r\n    if (this.suggest) {\r\n      // Strict selection. Closing the popover should never confirm the current\r\n      // value. In other words, it cancels the selection\r\n      if (this.suggestOptions.strict) {\r\n        // Clear last debounce\r\n        clearTimeout(this.#queuedInputValueUpdate);\r\n\r\n        // Revert change because the input value does not match any item value\r\n        this.value = this.#lastConfirmedValue;\r\n\r\n        // Emit filter change event to recover the previous state.\r\n        // TODO: Should we debounce this event?\r\n        this.input.emit(this.value);\r\n      }\r\n\r\n      // TODO: Add a unit test for this\r\n      this.#emitChangeEvent();\r\n    } else {\r\n      this.#checkAndEmitValueChangeWithNoFilter();\r\n    }\r\n  };\r\n\r\n  #emitChangeEvent = () =>\r\n    // TODO: Add a unit test for this\r\n    // TODO: Don't emit the event if the value didn't change\r\n    this.change.emit(this.value);\r\n\r\n  #handleInputFilterChange = (event: InputEvent) => {\r\n    event.stopPropagation();\r\n    this.expanded = true;\r\n\r\n    // Clear last debounce\r\n    clearTimeout(this.#queuedInputValueUpdate);\r\n\r\n    // TODO: Add unit tests for this case\r\n    if (this.suggestDebounce > 0) {\r\n      this.#queuedInputValueUpdate = setTimeout(() => {\r\n        this.value = this.#inputRef.value;\r\n        this.input.emit(this.value);\r\n      }, this.suggestDebounce);\r\n    } else {\r\n      this.value = this.#inputRef.value;\r\n      this.input.emit(this.value);\r\n    }\r\n  };\r\n\r\n  #displayPopover = (event: MouseEvent) => {\r\n    const clickWasPerformedInALabel = event.detail === 0;\r\n\r\n    // TODO: Add a unit test for this case (clicking on the popover should not\r\n    // close the popover)\r\n    if (\r\n      clickWasPerformedInALabel ||\r\n      (this.expanded && popoverWasClicked(event))\r\n    ) {\r\n      return;\r\n    }\r\n    event.stopPropagation();\r\n    this.expanded = !this.expanded;\r\n  };\r\n\r\n  #handlePopoverClick = (event: MouseEvent) => {\r\n    const itemUIModel = getComboBoxItemFromMouseEvent(event, this.model);\r\n\r\n    if (!itemUIModel) {\r\n      return;\r\n    }\r\n    const itemGroup = itemUIModel as ComboBoxItemGroup;\r\n\r\n    // Clicked in a group header\r\n    if (itemGroup.items != null) {\r\n      if (!itemGroup.expandable) {\r\n        return;\r\n      }\r\n      // Toggle expanded\r\n      itemGroup.expanded = !itemGroup.expanded;\r\n    }\r\n    // Clicked in a leaf\r\n    else {\r\n      this.activeDescendant = itemUIModel;\r\n      this.expanded = false;\r\n\r\n      this.#checkAndEmitValueChangeWithNoFilter();\r\n    }\r\n\r\n    forceUpdate(this);\r\n  };\r\n\r\n  #handleMouseOverItem = (event: MouseEvent) => {\r\n    const itemUIModel = getComboBoxItemFromMouseEvent(event, this.model) as\r\n      | ComboBoxItemGroup\r\n      | undefined;\r\n\r\n    if (itemUIModel && itemUIModel.items == null) {\r\n      this.activeDescendant = itemUIModel;\r\n      forceUpdate(this);\r\n    }\r\n  };\r\n\r\n  #isModelAlreadyFiltered = () => this.suggestOptions.alreadyProcessed === true;\r\n  #shouldRenderActiveItemIcon = () =>\r\n    !this.suggest ||\r\n    !this.expanded ||\r\n    this.suggestOptions.renderActiveItemIconOnExpand;\r\n\r\n  #setValueInForm = (value: string) => {\r\n    // TODO: Add a unit test for this case\r\n    if (!this.expanded) {\r\n      this.#lastConfirmedValue = value;\r\n    }\r\n\r\n    this.#syncActiveDescendant();\r\n\r\n    // Update form value\r\n    this.internals.setFormValue(value);\r\n  };\r\n\r\n  #syncActiveDescendant = () => {\r\n    // TODO: Should we set the activeDescendant at the end of this function?\r\n\r\n    // If the active descendant is not set, try to set it using the value\r\n    // TODO: Do we have to use the caption when using suggest?\r\n    if (!this.activeDescendant || !this.expanded) {\r\n      this.activeDescendant = this.#getCurrentValueMapping()?.item;\r\n    }\r\n\r\n    // If the value does not belong to a rendered item, remove the active\r\n    // descendant\r\n    const clientSideFilters = this.suggest && !this.#isModelAlreadyFiltered();\r\n    if (\r\n      !clientSideFilters &&\r\n      !comboBoxActiveDescendantIsRendered(this.activeDescendant, this.model)\r\n    ) {\r\n      this.activeDescendant = undefined;\r\n    }\r\n  };\r\n\r\n  #nativeRender = () => (\r\n    <select\r\n      aria-label={this.#accessibleNameFromExternalLabel ?? this.accessibleName}\r\n      disabled={this.disabled}\r\n      onChange={!this.disabled && this.#handleSelectChange}\r\n      ref={el => (this.#selectRef = el)}\r\n    >\r\n      {!this.activeDescendant && (\r\n        <option disabled selected value=\"\">\r\n          {this.placeholder}\r\n        </option>\r\n      )}\r\n      {this.model.map(item => nativeItemRender(item, this.value))}\r\n    </select>\r\n  );\r\n\r\n  connectedCallback() {\r\n    this.#findLargestValue(this.model);\r\n    mapValuesToItemInfo(\r\n      this.model,\r\n      this.#valueToItemInfo,\r\n      this.#captionToItemInfo\r\n    );\r\n\r\n    // Accessibility\r\n    this.#setValueInForm(this.value);\r\n    const labels = this.internals.labels;\r\n    this.#accessibleNameFromExternalLabel = getElementInternalsLabel(labels);\r\n\r\n    // Report any accessibility issue\r\n    analyzeLabelExistence(\r\n      this.el,\r\n      \"ch-combo-box-render\",\r\n      labels,\r\n      this.#accessibleNameFromExternalLabel,\r\n      this.accessibleName\r\n    );\r\n  }\r\n\r\n  componentWillRender() {\r\n    if (this.#applyFilters) {\r\n      this.#updateFilters(); // TODO: THERE IS A BUG IF THE COMBO-BOX STARTS WITH FILTERS APPLIED\r\n      this.#applyFilters = false;\r\n    }\r\n  }\r\n\r\n  componentDidRender() {\r\n    if (this.expanded) {\r\n      const selectedElement = this.el.shadowRoot.querySelector(\r\n        SELECTED_ITEM_SELECTOR\r\n      ) as HTMLElement | undefined;\r\n\r\n      // Focus the selected element to force the scroll into view\r\n      if (selectedElement) {\r\n        // Wait until the JS has been executed to avoid race conditions when\r\n        // rendering elements in the top layer and trying to focus them\r\n        requestAnimationFrame(() => {\r\n          selectedElement.focus();\r\n          this.#inputRef.focus();\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const filtersAreApplied = this.suggest;\r\n    const disableTextSelection = !this.disabled && !filtersAreApplied;\r\n    const comboBoxIsInteractive = !this.readonly && !this.disabled;\r\n\r\n    const currentItemInInput: ComboBoxItemModel | undefined = filtersAreApplied\r\n      ? this.#getCurrentValueMapping()?.item\r\n      : this.activeDescendant;\r\n\r\n    const computedImage =\r\n      currentItemInInput?.startImgSrc && this.#shouldRenderActiveItemIcon()\r\n        ? (computeComboBoxItemImage(\r\n            currentItemInInput,\r\n            \"start\",\r\n            this.#getActualImagePathCallback()\r\n          ) as GxImageMultiStateStart | undefined)\r\n        : undefined;\r\n\r\n    const startImgClasses = computedImage\r\n      ? `img--start start-img-type--${\r\n          currentItemInInput.startImgType ?? \"background\"\r\n        } ${computedImage.classes}`\r\n      : undefined;\r\n\r\n    // TODO: UNIT TESTS.\r\n    // - Clicking the combo-box with JS should not open the popover\r\n    // - User click must open the combo-box\r\n    // - Clicking the combo-box's label should not open the popover\r\n\r\n    // TODO: Add unit tests for this feature.\r\n    const currentValueMapping = this.#getCurrentValueMapping()?.item.value;\r\n    const inputValue = filtersAreApplied\r\n      ? this.value\r\n      : this.activeDescendant?.caption;\r\n\r\n    return (\r\n      <Host\r\n        class={{\r\n          \"ch-disabled\": this.disabled,\r\n          \"ch-combo-box--normal\": !filtersAreApplied,\r\n          \"ch-combo-box--suggest\": filtersAreApplied\r\n        }}\r\n        // TODO: Add unit tests for this feature, since it breaks custom parts\r\n        // rendered outside of the ch-combo-box-render render() method\r\n        part={tokenMap({\r\n          [currentValueMapping]: !!currentValueMapping,\r\n          [COMBO_BOX_HOST_PARTS.PLACEHOLDER]: !inputValue,\r\n          [this.hostParts]: !!this.hostParts\r\n        })}\r\n        onKeyDown={\r\n          !mobileDevice &&\r\n          comboBoxIsInteractive &&\r\n          this.#handleExpandedChangeWithKeyBoard\r\n        }\r\n        onClickCapture={\r\n          comboBoxIsInteractive &&\r\n          (!filtersAreApplied || !this.expanded) &&\r\n          this.#displayPopover\r\n        }\r\n      >\r\n        {mobileDevice\r\n          ? this.#nativeRender()\r\n          : [\r\n              <span class=\"invisible-text\">\r\n                {this.#largestValue || this.placeholder}\r\n              </span>,\r\n\r\n              <div\r\n                key=\"combobox\"\r\n                role=\"combobox\"\r\n                aria-label={\r\n                  this.#accessibleNameFromExternalLabel ?? this.accessibleName\r\n                }\r\n                tabindex={disableTextSelection ? \"0\" : null}\r\n                class={{\r\n                  \"input-container\": true,\r\n\r\n                  // TODO: Fix disabled styling when the group parent is disabled, but the option leaf isn't.\r\n                  // Class for disabled images. Used when the combo-box or selected item are disabled\r\n                  disabled: this.disabled || currentItemInInput?.disabled,\r\n                  [startImgClasses]: !!startImgClasses\r\n                }}\r\n                style={computedImage?.styles}\r\n              >\r\n                <input\r\n                  aria-controls=\"popover\"\r\n                  // This reset is necessary, since we use \"disabled\" to\r\n                  // disallow the focus and text selection in the input when\r\n                  // the combo-box has no filters\r\n                  aria-disabled={disableTextSelection ? \"false\" : null}\r\n                  aria-expanded={this.expanded.toString()}\r\n                  aria-haspopup=\"true\"\r\n                  autocomplete=\"off\"\r\n                  class={{\r\n                    value: true,\r\n                    \"value--readonly\": !filtersAreApplied\r\n                  }}\r\n                  disabled={this.disabled || !filtersAreApplied}\r\n                  placeholder={this.placeholder}\r\n                  readOnly={this.readonly || !filtersAreApplied}\r\n                  value={inputValue}\r\n                  onInputCapture={\r\n                    filtersAreApplied &&\r\n                    comboBoxIsInteractive &&\r\n                    this.#handleInputFilterChange\r\n                  }\r\n                  ref={el => (this.#inputRef = el)}\r\n                ></input>\r\n              </div>,\r\n\r\n              this.expanded && comboBoxIsInteractive && (\r\n                <ch-popover\r\n                  key=\"popover\"\r\n                  id=\"popover\"\r\n                  role=\"listbox\"\r\n                  aria-hidden=\"false\" // TODO: Remove this and add a unit test\r\n                  part=\"window\"\r\n                  actionById\r\n                  actionElement={this.el as unknown as HTMLButtonElement} // This is a WA. We should remove it\r\n                  blockAlign=\"outside-end\"\r\n                  inlineAlign={this.popoverInlineAlign}\r\n                  closeOnClickOutside\r\n                  show\r\n                  popover=\"manual\"\r\n                  resizable={this.resizable}\r\n                  inlineSizeMatch=\"action-element-as-minimum\"\r\n                  overflowBehavior=\"add-scroll\"\r\n                  positionTry=\"flip-block\"\r\n                  onClick={this.#handlePopoverClick}\r\n                  onMouseOver={this.#handleMouseOverItem}\r\n                  onPopoverClosed={this.#handlePopoverClose}\r\n                >\r\n                  {this.model.map(\r\n                    customComboBoxItemRender(\r\n                      false,\r\n                      this.disabled,\r\n                      filtersAreApplied && !this.#isModelAlreadyFiltered(),\r\n                      this.activeDescendant,\r\n                      this.#displayedValues,\r\n                      this.#itemImages,\r\n                      \"\"\r\n                    )\r\n                  )}\r\n                </ch-popover>\r\n              )\r\n            ]}\r\n      </Host>\r\n    );\r\n  }\r\n}\r\n"],"mappings":"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"}