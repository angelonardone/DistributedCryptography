{"version":3,"names":["linkDefinitions","Map","linkDefinitionPromises","getLinkDefinition","id","linkDefinition","get","undefined","definitionRequest","promise","resolver","definitionPromise","Promise","resolve","set","setLinkDefinition","url","pendingPromise","clearLinkDefinitions","clear","HEADING_ID_REGEX","LAST_NESTED_CHILD_CLASS","codeToJSX","HTMLToJSX","lastNestedChild","checkAndGetLastNestedChildClass","element","depthToHeading","content","classes","h","class","tableAlignmentDictionary","left","center","right","tableRender","table","metadata","__awaiter","_this","tableHeadRow","children","tableBodyRows","slice","columnCount","length","headCellPromises","map","tableCell","mdASTtoJSX","bodyCellPromises","forEach","tableHead","push","allSettled","tableHeadContent","_b","sent","tableBodyContent","headCells","jsx","value","bodyCells","alignments","align","alignment","index","rowIndex","cellIndex","renderDictionary","blockquote","break","code","then","codeHighlight","_c","parseCodeToJSX","lang","renderCode","definition","identifier","delete","emphasis","footnoteDefinition","footnoteReference","heading","lastChild","at","type","match","headingId","replace","concat","depth","html","rawHTML","module","import","rawHTMLToJSX","allowDangerousHtml","image","src","alt","title","loading","imageReference","inlineCode","link","includes","href","linkReference","referenceType","label","list","ordered","start","listItem","paragraph","strong","text","thematicBreak","yaml","findLastNestedChild","elementWithChildren","root","childrenLength","asyncJSX","Array","child","renderedContent","markdownToJSX","markdown","mdAST","markdownToMdAST","JSX","codeToJSXDictionary","className","properties","lastNestedChildClass","highlightJSClasses","join","renderCodeChildren","language","isLastNestedChild","actualLanguage","getActualLanguageWithoutAlias","registerLanguage","tree","parseCodeToHAST","nestedChildIsCodeTag","plainText","defaultCodeRender","options","markdownCss","ChMarkdownStyle0","ChMarkdown","exports","_a","_JSXTree","this","class_1","prototype","componentWillRender","rawHtml","__classPrivateFieldSet","apply","render","Host","__classPrivateFieldGet"],"sources":["src/deprecated-components/markdown/parsers/link-resolver.ts","src/deprecated-components/markdown/parsers/markdown-to-jsx.tsx","src/deprecated-components/markdown/parsers/code-highlight.tsx","src/deprecated-components/markdown/markdown.scss?tag=ch-markdown","src/deprecated-components/markdown/markdown.tsx"],"sourcesContent":["const linkDefinitions = new Map<string, string>();\r\n\r\nconst linkDefinitionPromises = new Map<\r\n  string,\r\n  { promise: Promise<string>; resolver: (url: string) => void }\r\n>();\r\n\r\nexport const getLinkDefinition = (id: string): Promise<string> | string => {\r\n  // See if we already have the definition\r\n  const linkDefinition = linkDefinitions.get(id);\r\n\r\n  if (linkDefinition !== undefined) {\r\n    return linkDefinition;\r\n  }\r\n\r\n  // See if we already have a Promise for this definition\r\n  const definitionRequest = linkDefinitionPromises.get(id);\r\n\r\n  if (definitionRequest !== undefined) {\r\n    return definitionRequest.promise;\r\n  }\r\n\r\n  let resolver: (value: string | PromiseLike<string>) => void;\r\n\r\n  // Create the promise and store the resolver to resolve the promise when the\r\n  // definition is encounter in the parser\r\n  const definitionPromise = new Promise<string>(resolve => {\r\n    resolver = resolve;\r\n\r\n    // TODO: Should resolve after 10s or so to avoid dead lock?\r\n  });\r\n\r\n  linkDefinitionPromises.set(id, {\r\n    promise: definitionPromise,\r\n    resolver: resolver\r\n  });\r\n\r\n  return definitionPromise;\r\n};\r\n\r\nexport const setLinkDefinition = (id: string, url: string) => {\r\n  // Store the url\r\n  linkDefinitions.set(id, url);\r\n\r\n  // See if are pending Promises to be resolved\r\n  const pendingPromise = linkDefinitionPromises.get(id);\r\n\r\n  if (pendingPromise !== undefined) {\r\n    pendingPromise.resolver(url);\r\n  }\r\n};\r\n\r\nexport const clearLinkDefinitions = () => {\r\n  linkDefinitions.clear();\r\n  linkDefinitionPromises.clear();\r\n};\r\n","import { h } from \"@stencil/core\";\r\nimport { AlignType, Code, Root, Table } from \"mdast\";\r\nimport { markdownToMdAST } from \"@genexus/markdown-parser\";\r\n\r\nimport {\r\n  ElementsWithChildren,\r\n  ElementsWithoutCustomRender,\r\n  MarkdownToJSXCommonMetadata\r\n} from \"./types\";\r\nimport { parseCodeToJSX } from \"./code-highlight\"; // The implementation is not used in the initial load, only the type.\r\nimport { rawHTMLToJSX } from \"./raw-html-to-jsx\";\r\nimport {\r\n  clearLinkDefinitions,\r\n  getLinkDefinition,\r\n  setLinkDefinition\r\n} from \"./link-resolver\";\r\n\r\n/**\r\n * Regex to match the id of the heading.\r\n *\r\n * @input `\"# Hello, world {#something} \"`\r\n * @output `something`\r\n */\r\nconst HEADING_ID_REGEX = /\\{#(.*?)\\}/;\r\n\r\nexport const LAST_NESTED_CHILD_CLASS = \"last-nested-child\";\r\n\r\n// Lazy load the code parser implementation\r\nlet codeToJSX: typeof parseCodeToJSX;\r\nlet HTMLToJSX: typeof rawHTMLToJSX;\r\nlet lastNestedChild: Root | ElementsWithChildren | Code;\r\n\r\nconst checkAndGetLastNestedChildClass = (element: ElementsWithChildren) =>\r\n  element === lastNestedChild ? LAST_NESTED_CHILD_CLASS : undefined;\r\n\r\nconst depthToHeading = {\r\n  1: (content: any, classes: string | null, id?: string) => (\r\n    <h1 class={classes} id={id}>\r\n      {content}\r\n    </h1>\r\n  ),\r\n  2: (content: any, classes: string | null, id?: string) => (\r\n    <h2 class={classes} id={id}>\r\n      {content}\r\n    </h2>\r\n  ),\r\n  3: (content: any, classes: string | null, id?: string) => (\r\n    <h3 class={classes} id={id}>\r\n      {content}\r\n    </h3>\r\n  ),\r\n  4: (content: any, classes: string | null, id?: string) => (\r\n    <h4 class={classes} id={id}>\r\n      {content}\r\n    </h4>\r\n  ),\r\n  5: (content: any, classes: string | null, id?: string) => (\r\n    <h5 class={classes} id={id}>\r\n      {content}\r\n    </h5>\r\n  ),\r\n  6: (content: any, classes: string | null, id?: string) => (\r\n    <h6 class={classes} id={id}>\r\n      {content}\r\n    </h6>\r\n  )\r\n} as const;\r\n\r\nconst tableAlignmentDictionary: { [key in AlignType]: string } = {\r\n  left: \"ch-markdown-table-column-start\",\r\n  center: \"ch-markdown-table-column-center\",\r\n  right: \"ch-markdown-table-column-end\"\r\n};\r\n\r\nconst tableRender = async (\r\n  table: Table,\r\n  metadata: MarkdownToJSXCommonMetadata\r\n) => {\r\n  const tableHeadRow = table.children[0];\r\n  const tableBodyRows = table.children.slice(1);\r\n  const columnCount = tableHeadRow.children.length;\r\n\r\n  // Head cell promises\r\n  const headCellPromises = tableHeadRow.children.map(tableCell =>\r\n    mdASTtoJSX(tableCell, metadata)\r\n  );\r\n\r\n  const bodyCellPromises = [];\r\n\r\n  // Body cell promises\r\n  tableBodyRows.forEach(tableHead => {\r\n    tableHead.children.forEach(tableCell => {\r\n      bodyCellPromises.push(mdASTtoJSX(tableCell, metadata));\r\n    });\r\n  });\r\n\r\n  // Wait for all results to be completed in parallel\r\n  const tableHeadContent = await Promise.allSettled(headCellPromises);\r\n  const tableBodyContent = await Promise.allSettled(bodyCellPromises);\r\n\r\n  // Return the JSX array\r\n  const headCells = tableHeadContent.map(\r\n    jsx => (jsx as PromiseFulfilledResult<any>).value\r\n  );\r\n  const bodyCells = tableBodyContent.map(\r\n    jsx => (jsx as PromiseFulfilledResult<any>).value\r\n  );\r\n\r\n  const alignments = table.align.map(\r\n    alignment => tableAlignmentDictionary[alignment]\r\n  );\r\n\r\n  return (\r\n    <table>\r\n      <thead>\r\n        <tr>\r\n          {tableHeadRow.children.map((tableCell, index) => (\r\n            <th\r\n              class={{\r\n                [alignments[index]]: !!alignments[index],\r\n                [LAST_NESTED_CHILD_CLASS]: tableCell === lastNestedChild\r\n              }}\r\n            >\r\n              {headCells[index]}\r\n            </th>\r\n          ))}\r\n        </tr>\r\n      </thead>\r\n\r\n      <tbody>\r\n        {tableBodyRows.map((tableHead, rowIndex) => (\r\n          <tr>\r\n            {tableHead.children.map((tableCell, cellIndex) => (\r\n              <td\r\n                class={{\r\n                  [alignments[cellIndex]]: !!alignments[cellIndex],\r\n                  [LAST_NESTED_CHILD_CLASS]: tableCell === lastNestedChild\r\n                }}\r\n              >\r\n                {bodyCells[columnCount * rowIndex + cellIndex]}\r\n              </td>\r\n            ))}\r\n          </tr>\r\n        ))}\r\n      </tbody>\r\n    </table>\r\n  );\r\n};\r\n\r\nexport const renderDictionary: {\r\n  [key in keyof ElementsWithoutCustomRender]: (\r\n    element: ElementsWithoutCustomRender[key],\r\n    metadata: MarkdownToJSXCommonMetadata\r\n  ) => Promise<any> | any;\r\n} = {\r\n  blockquote: async (element, metadata) => {\r\n    const content = await mdASTtoJSX(element, metadata);\r\n\r\n    return (\r\n      <blockquote class={checkAndGetLastNestedChildClass(element)}>\r\n        {content}\r\n      </blockquote>\r\n    );\r\n  }, // TODO: Check if code can be inside this tag\r\n\r\n  break: () => <br />,\r\n\r\n  code: async (element, metadata) => {\r\n    // Load the parser implementation\r\n    codeToJSX ||= (await import(\"./code-highlight\")).parseCodeToJSX; // TODO: Resolve race condition\r\n    const content = await codeToJSX(\r\n      element.value,\r\n      element.lang,\r\n      metadata.renderCode,\r\n      element === lastNestedChild\r\n    );\r\n\r\n    return content;\r\n  },\r\n\r\n  definition: element => setLinkDefinition(element.identifier, element.url),\r\n\r\n  delete: async (element, metadata) => {\r\n    const content = await mdASTtoJSX(element, metadata);\r\n\r\n    return (\r\n      <del class={checkAndGetLastNestedChildClass(element)}>{content}</del>\r\n    );\r\n  }, // TODO: Check if code can be inside this tag\r\n\r\n  emphasis: async (element, metadata) => {\r\n    const content = await mdASTtoJSX(element, metadata);\r\n\r\n    return <em class={checkAndGetLastNestedChildClass(element)}>{content}</em>;\r\n  }, // TODO: Check if code can be inside this tag\r\n\r\n  footnoteDefinition: () => \"\",\r\n\r\n  footnoteReference: () => \"\",\r\n\r\n  heading: async (element, metadata) => {\r\n    // Check if the heading has an id\r\n    const lastChild = element.children.at(-1);\r\n    let headingId: string;\r\n\r\n    if (lastChild?.type === \"text\") {\r\n      const match = lastChild.value.match(HEADING_ID_REGEX);\r\n\r\n      if (match && match.length > 1) {\r\n        headingId = match[1];\r\n\r\n        // Remove markdown id from the header text\r\n        lastChild.value = lastChild.value.replace(`{#${headingId}}`, \"\");\r\n      }\r\n    }\r\n\r\n    // Render the content after the heading id processing\r\n    const content = await mdASTtoJSX(element, metadata);\r\n    const classes = checkAndGetLastNestedChildClass(element);\r\n\r\n    return depthToHeading[element.depth](content, classes, headingId); // TODO: Add anchor icon at the start of the heading\r\n  },\r\n\r\n  html: async (element, metadata) => {\r\n    if (metadata.rawHTML && !HTMLToJSX) {\r\n      // Load the parser implementation\r\n      HTMLToJSX = (await import(\"./raw-html-to-jsx\")).rawHTMLToJSX;\r\n    }\r\n\r\n    return metadata.rawHTML\r\n      ? HTMLToJSX(element.value, metadata.allowDangerousHtml)\r\n      : element.value;\r\n  },\r\n\r\n  image: element => (\r\n    <img\r\n      src={element.url}\r\n      alt={element.alt}\r\n      title={element.title}\r\n      loading=\"lazy\"\r\n    />\r\n  ),\r\n\r\n  imageReference: () => \"\",\r\n\r\n  inlineCode: element => <code class=\"hljs\">{element.value}</code>,\r\n\r\n  link: async (element, metadata) => {\r\n    // Sanitize scripts\r\n    if (element.url.includes(\"javascript:\")) {\r\n      return;\r\n    }\r\n\r\n    const content = await mdASTtoJSX(element, metadata);\r\n\r\n    return (\r\n      <a\r\n        aria-label={element.title || null}\r\n        title={element.title || null}\r\n        class={checkAndGetLastNestedChildClass(element)}\r\n        href={element.url}\r\n      >\r\n        {content}\r\n      </a>\r\n    );\r\n  }, // TODO: Sanitize href?\r\n\r\n  linkReference: async (element, metadata) => {\r\n    const content = await mdASTtoJSX(element, metadata);\r\n    let url = \"\";\r\n\r\n    // TODO: Implement the rest of alternatives for \"referenceType\"\r\n    if (element.referenceType === \"shortcut\") {\r\n      url = await getLinkDefinition(element.identifier);\r\n    }\r\n\r\n    // TODO: It's unnecessary to set aria-label when referenceType === \"shortcut\"\r\n    // TODO: The title is not supported well. See \"An Example Putting the Parts Together\" section in markdown.html\r\n\r\n    // Sanitize scripts\r\n    if (url.includes(\"javascript:\")) {\r\n      return;\r\n    }\r\n\r\n    return (\r\n      <a\r\n        aria-label={element.label || null}\r\n        class={checkAndGetLastNestedChildClass(element)}\r\n        href={url}\r\n      >\r\n        {content}\r\n      </a>\r\n    );\r\n  },\r\n\r\n  list: async (element, metadata) => {\r\n    const content = await mdASTtoJSX(element, metadata);\r\n\r\n    return element.ordered ? (\r\n      <ol\r\n        class={checkAndGetLastNestedChildClass(element)}\r\n        start={element.start}\r\n      >\r\n        {content}\r\n      </ol> // TODO: Implement spread  // TODO: Check if code can be inside this tag\r\n    ) : (\r\n      <ul class={checkAndGetLastNestedChildClass(element)}>{content}</ul> // TODO: Implement spread  // TODO: Check if code can be inside this tag\r\n    );\r\n  },\r\n\r\n  listItem: async (element, metadata) => {\r\n    const content = await mdASTtoJSX(element, metadata);\r\n\r\n    return <li class={checkAndGetLastNestedChildClass(element)}>{content}</li>;\r\n  }, // TODO: Implement spread  // TODO: Check if code can be inside this tag\r\n\r\n  paragraph: async (element, metadata) => {\r\n    const content = await mdASTtoJSX(element, metadata);\r\n\r\n    return <p class={checkAndGetLastNestedChildClass(element)}>{content}</p>;\r\n  }, // TODO: Check if code can be inside this tag\r\n\r\n  strong: async (element, metadata) => {\r\n    const content = await mdASTtoJSX(element, metadata);\r\n\r\n    return (\r\n      <strong class={checkAndGetLastNestedChildClass(element)}>\r\n        {content}\r\n      </strong>\r\n    );\r\n  }, // TODO: Check if code can be inside this tag\r\n\r\n  table: tableRender, // TODO: Check if code can be inside this tag\r\n\r\n  text: element => element.value,\r\n\r\n  thematicBreak: () => <hr />,\r\n\r\n  yaml: () => \"\"\r\n} as const;\r\n\r\nconst findLastNestedChild = (\r\n  elementWithChildren: ElementsWithChildren | Root\r\n) => {\r\n  const lastChild = elementWithChildren.children.at(-1);\r\n\r\n  // The last element have children. We must check its sub children\r\n  if ((lastChild as ElementsWithChildren).children?.length > 0) {\r\n    return findLastNestedChild(lastChild as ElementsWithChildren);\r\n  }\r\n\r\n  if (lastChild.type === \"code\") {\r\n    return lastChild;\r\n  }\r\n\r\n  return elementWithChildren;\r\n};\r\n\r\n/**\r\n * Converts markdown abstract syntax tree (mdast) into JSX.\r\n */\r\nasync function mdASTtoJSX(\r\n  root: ElementsWithChildren | Root,\r\n  metadata: MarkdownToJSXCommonMetadata\r\n) {\r\n  const childrenLength = root.children.length;\r\n  const asyncJSX = new Array(childrenLength);\r\n\r\n  // Get the async JSX\r\n  for (let index = 0; index < childrenLength; index++) {\r\n    const child = root.children[index];\r\n\r\n    asyncJSX.push(renderDictionary[child.type](child, metadata));\r\n  }\r\n\r\n  // Wait for all results to be completed in parallel\r\n  const renderedContent = await Promise.allSettled(asyncJSX);\r\n\r\n  // Return the JSX array\r\n  return renderedContent.map(jsx => (jsx as PromiseFulfilledResult<any>).value);\r\n}\r\n\r\nexport const markdownToJSX = async (\r\n  markdown: string,\r\n  metadata: MarkdownToJSXCommonMetadata\r\n) => {\r\n  const mdAST: Root = markdownToMdAST(markdown);\r\n\r\n  // First, find the last nested child. Useful to set a marker in the element\r\n  // that accomplish this condition\r\n  lastNestedChild = findLastNestedChild(mdAST);\r\n\r\n  // Render the markdown as JSX\r\n  const JSX = await mdASTtoJSX(mdAST, metadata);\r\n\r\n  // Clear all definitions used to render the current markdown, so the next\r\n  // render does not have old information\r\n  clearLinkDefinitions();\r\n\r\n  return JSX;\r\n};\r\n","import { h } from \"@stencil/core\";\r\nimport { Element as HElement, Text as HText, Root as HRoot } from \"hast\";\r\n\r\nimport {\r\n  getActualLanguageWithoutAlias,\r\n  parseCodeToHAST,\r\n  registerLanguage\r\n} from \"@genexus/markdown-parser/dist/parse-code.js\";\r\nimport { MarkdownCodeRender, MarkdownCodeRenderOptions } from \"./types\";\r\nimport { LAST_NESTED_CHILD_CLASS } from \"./markdown-to-jsx\";\r\n\r\nlet lastNestedChild: HRoot | HElement;\r\n\r\nconst checkAndGetLastNestedChildClass = (\r\n  element: HElement\r\n): string | undefined =>\r\n  element === lastNestedChild ? LAST_NESTED_CHILD_CLASS : undefined;\r\n\r\nconst codeToJSXDictionary = {\r\n  element: (element: HElement) => {\r\n    const className = element.properties.className as string[];\r\n\r\n    const lastNestedChildClass = checkAndGetLastNestedChildClass(element);\r\n    const highlightJSClasses = className ? className.join(\" \") : undefined;\r\n\r\n    return (\r\n      <span\r\n        class={{\r\n          [highlightJSClasses]: !!highlightJSClasses,\r\n          [lastNestedChildClass]: !!lastNestedChildClass\r\n        }}\r\n      >\r\n        {renderCodeChildren(element)}\r\n      </span>\r\n    );\r\n  },\r\n\r\n  text: (element: HText) => element.value\r\n};\r\n\r\nfunction renderCodeChildren(element: HElement) {\r\n  return element.children.map(child => codeToJSXDictionary[child.type](child));\r\n}\r\n\r\nconst findLastNestedChild = (elementWithChildren: HRoot | HElement) => {\r\n  const lastChild = elementWithChildren.children.at(-1);\r\n\r\n  // The last element have children. We must check its sub children\r\n  if ((lastChild as HElement).children?.length > 0) {\r\n    return findLastNestedChild(lastChild as HElement);\r\n  }\r\n\r\n  return elementWithChildren;\r\n};\r\n\r\nexport const parseCodeToJSX = async (\r\n  code: string,\r\n  language: string,\r\n  renderCode: MarkdownCodeRender,\r\n  isLastNestedChild: boolean\r\n) => {\r\n  const actualLanguage = getActualLanguageWithoutAlias(language || \"plaintext\");\r\n\r\n  // Register the language\r\n  await registerLanguage(actualLanguage);\r\n\r\n  const tree: HRoot = parseCodeToHAST(actualLanguage, code);\r\n  lastNestedChild = undefined; // Reset last nested child\r\n\r\n  // Find last nested child\r\n  if (isLastNestedChild) {\r\n    lastNestedChild = findLastNestedChild(tree);\r\n  }\r\n\r\n  const nestedChildIsCodeTag = isLastNestedChild && tree === lastNestedChild;\r\n\r\n  return renderCode({\r\n    language: language || \"plaintext\",\r\n    nestedChildIsCodeTag: nestedChildIsCodeTag,\r\n    plainText: code,\r\n    renderedContent: tree.children.map(child =>\r\n      codeToJSXDictionary[child.type](child)\r\n    )\r\n  });\r\n};\r\n\r\n/**\r\n * @deprecated Use the `ch-code` component to render code blocks\r\n */\r\nexport const defaultCodeRender: MarkdownCodeRender = (\r\n  options: MarkdownCodeRenderOptions\r\n): any => (\r\n  <pre>\r\n    <code\r\n      class={{\r\n        [`hljs language-${options.language}`]: true,\r\n        [LAST_NESTED_CHILD_CLASS]: options.nestedChildIsCodeTag\r\n      }}\r\n    >\r\n      <div class=\"code-block__content\">{options.renderedContent}</div>\r\n    </code>\r\n  </pre>\r\n);\r\n","ch-markdown {\r\n  display: grid;\r\n  grid-auto-rows: max-content;\r\n}\r\n\r\n.ch-markdown-table-column-start {\r\n  text-align: start;\r\n}\r\n\r\n.ch-markdown-table-column-center {\r\n  text-align: center;\r\n}\r\n\r\n.ch-markdown-table-column-end {\r\n  text-align: end;\r\n}\r\n","import { Component, Element, Host, Prop, h } from \"@stencil/core\";\r\nimport { markdownToJSX } from \"./parsers/markdown-to-jsx\";\r\nimport { defaultCodeRender } from \"./parsers/code-highlight\";\r\nimport { MarkdownCodeRender } from \"./parsers/types\";\r\n\r\n/**\r\n * @deprecated Use the `ch-markdown-viewer` component instead.\r\n *\r\n * A control to render markdown syntax. It supports GitHub Flavored Markdown\r\n * (GFM) and code highlighting.\r\n *  - It parses the incoming markdown to [mdast](https://github.com/syntax-tree/mdast) using [micromark](https://github.com/micromark/micromark) via [mdast-util-from-markdown](https://github.com/syntax-tree/mdast-util-from-markdown).\r\n *\r\n * - After that, it implements a reactivity layer by implementing its own render for the mdast. With this, changes to the input markdown only update the portion of the DOM that changes.\r\n *\r\n * - It supports Github Flavored Markdown (GFM) by using [mdast-util-gfm](https://github.com/syntax-tree/mdast-util-gfm) and [micromark-extension-gfm](https://github.com/micromark/micromark-extension-gfm).\r\n *\r\n * - It supports code highlight by parsing the incomming code of the markdown to [hast](https://github.com/micromark/micromark-extension-gfm) using [lowlight](lowlight). After that, it implements a reactivity layer by implementing its own render for the hast.\r\n *\r\n * - It also supports all programming languages from [highlight.js](https://github.com/highlightjs/highlight.js).\r\n *\r\n * - When the code highlighting is needed at runtime, the control will load on demand the code parser and the programming language needed to parse the code.\r\n */\r\n@Component({\r\n  shadow: false,\r\n  styleUrl: \"markdown.scss\",\r\n  tag: \"ch-markdown\"\r\n})\r\nexport class ChMarkdown {\r\n  #JSXTree: any;\r\n\r\n  @Element() el: HTMLChMarkdownElement;\r\n\r\n  // /**\r\n  //  * `true` to render potentially dangerous user content when rendering HTML\r\n  //  * with the option `rawHtml === true`\r\n  //  */\r\n  // @Prop() readonly allowDangerousHtml: boolean = false;\r\n\r\n  /**\r\n   * `true` to render raw HTML with sanitization.\r\n   */\r\n  @Prop() readonly rawHtml: boolean = false;\r\n\r\n  /**\r\n   * This property allows us to implement custom rendering for the code blocks.\r\n   */\r\n  @Prop() readonly renderCode: MarkdownCodeRender = defaultCodeRender;\r\n\r\n  /**\r\n   * Specifies the markdown string to parse.\r\n   */\r\n  @Prop() readonly value: string;\r\n\r\n  async componentWillRender() {\r\n    if (!this.value) {\r\n      return;\r\n    }\r\n\r\n    this.#JSXTree = await markdownToJSX(this.value, {\r\n      rawHTML: this.rawHtml,\r\n      allowDangerousHtml: true, // Allow dangerous in this version\r\n      renderCode: this.renderCode\r\n    });\r\n  }\r\n\r\n  render() {\r\n    if (!this.value) {\r\n      return \"\";\r\n    }\r\n\r\n    return <Host>{this.#JSXTree}</Host>;\r\n  }\r\n}\r\n"],"mappings":"m9EAAA,IAAMA,EAAkB,IAAIC,IAE5B,IAAMC,EAAyB,IAAID,IAK5B,IAAME,EAAoB,SAACC,GAEhC,IAAMC,EAAiBL,EAAgBM,IAAIF,GAE3C,GAAIC,IAAmBE,UAAW,CAChC,OAAOF,C,CAIT,IAAMG,EAAoBN,EAAuBI,IAAIF,GAErD,GAAII,IAAsBD,UAAW,CACnC,OAAOC,EAAkBC,O,CAG3B,IAAIC,EAIJ,IAAMC,EAAoB,IAAIC,SAAgB,SAAAC,GAC5CH,EAAWG,C,IAKbX,EAAuBY,IAAIV,EAAI,CAC7BK,QAASE,EACTD,SAAUA,IAGZ,OAAOC,CACT,EAEO,IAAMI,EAAoB,SAACX,EAAYY,GAE5ChB,EAAgBc,IAAIV,EAAIY,GAGxB,IAAMC,EAAiBf,EAAuBI,IAAIF,GAElD,GAAIa,IAAmBV,UAAW,CAChCU,EAAeP,SAASM,E,CAE5B,EAEO,IAAME,EAAuB,WAClClB,EAAgBmB,QAChBjB,EAAuBiB,OACzB,EChCA,IAAMC,EAAmB,aAElB,IAAMC,EAA0B,oBAGvC,IAAIC,EACJ,IAAIC,EACJ,IAAIC,EAEJ,IAAMC,EAAkC,SAACC,GACvC,OAAAA,IAAYF,EAAkBH,EAA0Bd,SAAxD,EAEF,IAAMoB,EAAiB,CACrB,EAAG,SAACC,EAAcC,EAAwBzB,GAAW,OACnD0B,EAAA,MAAIC,MAAOF,EAASzB,GAAIA,GACrBwB,EAFgD,EAKrD,EAAG,SAACA,EAAcC,EAAwBzB,GAAW,OACnD0B,EAAA,MAAIC,MAAOF,EAASzB,GAAIA,GACrBwB,EAFgD,EAKrD,EAAG,SAACA,EAAcC,EAAwBzB,GAAW,OACnD0B,EAAA,MAAIC,MAAOF,EAASzB,GAAIA,GACrBwB,EAFgD,EAKrD,EAAG,SAACA,EAAcC,EAAwBzB,GAAW,OACnD0B,EAAA,MAAIC,MAAOF,EAASzB,GAAIA,GACrBwB,EAFgD,EAKrD,EAAG,SAACA,EAAcC,EAAwBzB,GAAW,OACnD0B,EAAA,MAAIC,MAAOF,EAASzB,GAAIA,GACrBwB,EAFgD,EAKrD,EAAG,SAACA,EAAcC,EAAwBzB,GAAW,OACnD0B,EAAA,MAAIC,MAAOF,EAASzB,GAAIA,GACrBwB,EAFgD,GAOvD,IAAMI,EAA2D,CAC/DC,KAAM,iCACNC,OAAQ,kCACRC,MAAO,gCAGT,IAAMC,EAAc,SAClBC,EACAC,GAAqC,OAAAC,UAAAC,OAAA,qB,oFAE/BC,EAAeJ,EAAMK,SAAS,GAC9BC,EAAgBN,EAAMK,SAASE,MAAM,GACrCC,EAAcJ,EAAaC,SAASI,OAGpCC,EAAmBN,EAAaC,SAASM,KAAI,SAAAC,GACjD,OAAAC,EAAWD,EAAWX,EAAtB,IAGIa,EAAmB,GAGzBR,EAAcS,SAAQ,SAAAC,GACpBA,EAAUX,SAASU,SAAQ,SAAAH,GACzBE,EAAiBG,KAAKJ,EAAWD,EAAWX,G,OAKvB,SAAM1B,QAAQ2C,WAAWR,I,OAA5CS,EAAmBC,EAAAC,OACA,SAAM9C,QAAQ2C,WAAWJ,I,OAA5CQ,EAAmBF,EAAAC,OAGnBE,EAAYJ,EAAiBR,KACjC,SAAAa,GAAQ,OAAAA,EAAoCC,KAApC,IAEJC,EAAYJ,EAAiBX,KACjC,SAAAa,GAAQ,OAAAA,EAAoCC,KAApC,IAGJE,EAAa3B,EAAM4B,MAAMjB,KAC7B,SAAAkB,GAAa,OAAAlC,EAAyBkC,EAAzB,IAGf,SACEpC,EAAA,aACEA,EAAA,aACEA,EAAA,UACGW,EAAaC,SAASM,KAAI,SAACC,EAAWkB,G,MAAK,OAC1CrC,EAAA,MACEC,OAAK0B,EAAA,GACHA,EAACO,EAAWG,MAAWH,EAAWG,GAClCV,EAACpC,GAA0B4B,IAAczB,E,IAG1CoC,EAAUO,GAP6B,MAahDrC,EAAA,aACGa,EAAcK,KAAI,SAACK,EAAWe,GAAQ,OACrCtC,EAAA,UACGuB,EAAUX,SAASM,KAAI,SAACC,EAAWoB,G,MAAS,OAC3CvC,EAAA,MACEC,OAAK0B,EAAA,GACHA,EAACO,EAAWK,MAAeL,EAAWK,GACtCZ,EAACpC,GAA0B4B,IAAczB,E,IAG1CuC,EAAUlB,EAAcuB,EAAWC,GAPK,IAFV,O,QAmBxC,IAAMC,EAKT,CACFC,WAAY,SAAO7C,EAASY,GAAQ,OAAAC,UAAAC,OAAA,qB,kEAClB,SAAMU,EAAWxB,EAASY,I,OAApCV,EAAU6B,EAAAC,OAEhB,SACE5B,EAAA,cAAYC,MAAON,EAAgCC,IAChDE,I,QAKP4C,MAAO,WAAM,OAAA1C,EAAA,YAEb2C,KAAM,SAAO/C,EAASY,GAAQ,OAAAC,UAAAC,OAAA,qB,oEAE5BiB,EAAAnC,E,KAAA,YAAe,SAAMV,QAAAC,UAAA6D,MAAA,kBAAAC,CAAA,K,SAArBrD,EAAesD,EAAAlB,OAAkCmB,e,iBAAjDpB,EACgB,SAAMnC,EACpBI,EAAQoC,MACRpC,EAAQoD,KACRxC,EAASyC,WACTrD,IAAYF,I,OAJRI,EAAUgD,EAAAlB,OAOhB,SAAO9B,G,QAGToD,WAAY,SAAAtD,GAAW,OAAAX,EAAkBW,EAAQuD,WAAYvD,EAAQV,IAA9C,EAEvBkE,OAAQ,SAAOxD,EAASY,GAAQ,OAAAC,UAAAC,OAAA,qB,kEACd,SAAMU,EAAWxB,EAASY,I,OAApCV,EAAU6B,EAAAC,OAEhB,SACE5B,EAAA,OAAKC,MAAON,EAAgCC,IAAWE,I,QAI3DuD,SAAU,SAAOzD,EAASY,GAAQ,OAAAC,UAAAC,OAAA,qB,kEAChB,SAAMU,EAAWxB,EAASY,I,OAApCV,EAAU6B,EAAAC,OAEhB,SAAO5B,EAAA,MAAIC,MAAON,EAAgCC,IAAWE,I,QAG/DwD,mBAAoB,WAAM,UAE1BC,kBAAmB,WAAM,UAEzBC,QAAS,SAAO5D,EAASY,GAAQ,OAAAC,UAAAC,OAAA,qB,0EAEzB+C,EAAY7D,EAAQgB,SAAS8C,IAAI,GAGvC,IAAID,IAAS,MAATA,SAAS,SAATA,EAAWE,QAAS,OAAQ,CACxBC,EAAQH,EAAUzB,MAAM4B,MAAMtE,GAEpC,GAAIsE,GAASA,EAAM5C,OAAS,EAAG,CAC7B6C,EAAYD,EAAM,GAGlBH,EAAUzB,MAAQyB,EAAUzB,MAAM8B,QAAQ,KAAAC,OAAKF,EAAS,KAAK,G,EAKjD,SAAMzC,EAAWxB,EAASY,I,OAApCV,EAAU6B,EAAAC,OACV7B,EAAUJ,EAAgCC,GAEhD,SAAOC,EAAeD,EAAQoE,OAAOlE,EAASC,EAAS8D,I,QAGzDI,KAAM,SAAOrE,EAASY,GAAQ,OAAAC,UAAAC,OAAA,qB,iEACxBF,EAAS0D,UAAYzE,GAArB,YAEW,SAAM0E,EAAAC,OAAO,2B,OAA1B3E,EAAakC,EAAAC,OAAmCyC,a,iBAGlD,SAAO7D,EAAS0D,QACZzE,EAAUG,EAAQoC,MAAOxB,EAAS8D,oBAClC1E,EAAQoC,O,QAGduC,MAAO,SAAA3E,GAAO,OACZI,EAAA,OACEwE,IAAK5E,EAAQV,IACbuF,IAAK7E,EAAQ6E,IACbC,MAAO9E,EAAQ8E,MACfC,QAAQ,QALE,EASdC,eAAgB,WAAM,UAEtBC,WAAY,SAAAjF,GAAW,OAAAI,EAAA,QAAMC,MAAM,QAAQL,EAAQoC,MAA5B,EAEvB8C,KAAM,SAAOlF,EAASY,GAAQ,OAAAC,UAAAC,OAAA,qB,kEAE5B,GAAId,EAAQV,IAAI6F,SAAS,eAAgB,CACvC,S,CAGc,SAAM3D,EAAWxB,EAASY,I,OAApCV,EAAU6B,EAAAC,OAEhB,SACE5B,EAAA,kBACcJ,EAAQ8E,OAAS,KAC7BA,MAAO9E,EAAQ8E,OAAS,KACxBzE,MAAON,EAAgCC,GACvCoF,KAAMpF,EAAQV,KAEbY,I,QAKPmF,cAAe,SAAOrF,EAASY,GAAQ,OAAAC,UAAAC,OAAA,qB,oEACrB,SAAMU,EAAWxB,EAASY,I,OAApCV,EAAU6B,EAAAC,OACZ1C,EAAM,G,KAGNU,EAAQsF,gBAAkB,YAA1B,YACI,SAAM7G,EAAkBuB,EAAQuD,a,OAAtCjE,EAAMyC,EAAAC,O,iBAOR,GAAI1C,EAAI6F,SAAS,eAAgB,CAC/B,S,CAGF,SACE/E,EAAA,kBACcJ,EAAQuF,OAAS,KAC7BlF,MAAON,EAAgCC,GACvCoF,KAAM9F,GAELY,I,QAKPsF,KAAM,SAAOxF,EAASY,GAAQ,OAAAC,UAAAC,OAAA,qB,kEACZ,SAAMU,EAAWxB,EAASY,I,OAApCV,EAAU6B,EAAAC,OAEhB,SAAOhC,EAAQyF,QACbrF,EAAA,MACEC,MAAON,EAAgCC,GACvC0F,MAAO1F,EAAQ0F,OAEdxF,GAGHE,EAAA,MAAIC,MAAON,EAAgCC,IAAWE,I,QAI1DyF,SAAU,SAAO3F,EAASY,GAAQ,OAAAC,UAAAC,OAAA,qB,kEAChB,SAAMU,EAAWxB,EAASY,I,OAApCV,EAAU6B,EAAAC,OAEhB,SAAO5B,EAAA,MAAIC,MAAON,EAAgCC,IAAWE,I,QAG/D0F,UAAW,SAAO5F,EAASY,GAAQ,OAAAC,UAAAC,OAAA,qB,kEACjB,SAAMU,EAAWxB,EAASY,I,OAApCV,EAAU6B,EAAAC,OAEhB,SAAO5B,EAAA,KAAGC,MAAON,EAAgCC,IAAWE,I,QAG9D2F,OAAQ,SAAO7F,EAASY,GAAQ,OAAAC,UAAAC,OAAA,qB,kEACd,SAAMU,EAAWxB,EAASY,I,OAApCV,EAAU6B,EAAAC,OAEhB,SACE5B,EAAA,UAAQC,MAAON,EAAgCC,IAC5CE,I,QAKPS,MAAOD,EAEPoF,KAAM,SAAA9F,GAAW,OAAAA,EAAQoC,KAAR,EAEjB2D,cAAe,WAAM,OAAA3F,EAAA,YAErB4F,KAAM,WAAM,WAGd,IAAMC,EAAsB,SAC1BC,G,MAEA,IAAMrC,EAAYqC,EAAoBlF,SAAS8C,IAAI,GAGnD,KAAK/B,EAAA8B,EAAmC7C,YAAQ,MAAAe,SAAA,SAAAA,EAAEX,QAAS,EAAG,CAC5D,OAAO6E,EAAoBpC,E,CAG7B,GAAIA,EAAUE,OAAS,OAAQ,CAC7B,OAAOF,C,CAGT,OAAOqC,CACT,EAKA,SAAe1E,EACb2E,EACAvF,G,0HAEMwF,EAAiBD,EAAKnF,SAASI,OAC/BiF,EAAW,IAAIC,MAAMF,GAG3B,IAAS3D,EAAQ,EAAGA,EAAQ2D,EAAgB3D,IAAS,CAC7C8D,EAAQJ,EAAKnF,SAASyB,GAE5B4D,EAASzE,KAAKgB,EAAiB2D,EAAMxC,MAAMwC,EAAO3F,G,CAI5B,SAAM1B,QAAQ2C,WAAWwE,I,OAA3CG,EAAkBzE,EAAAC,OAGxB,SAAOwE,EAAgBlF,KAAI,SAAAa,GAAQ,OAAAA,EAAoCC,KAApC,K,OAG9B,IAAMqE,EAAgB,SAC3BC,EACA9F,GAAqC,OAAAC,UAAAC,OAAA,qB,oEAE/B6F,EAAcC,EAAgBF,GAIpC5G,EAAkBmG,EAAoBU,GAG1B,SAAMnF,EAAWmF,EAAO/F,I,OAA9BiG,EAAM9E,EAAAC,OAIZxC,IAEA,SAAOqH,G,QCpYT,IAAI/G,EAEJ,IAAMC,EAAkC,SACtCC,GAEA,OAAAA,IAAYF,EAAkBH,EAA0Bd,SAAxD,EAEF,IAAMiI,EAAsB,CAC1B9G,QAAS,SAACA,G,MACR,IAAM+G,EAAY/G,EAAQgH,WAAWD,UAErC,IAAME,EAAuBlH,EAAgCC,GAC7D,IAAMkH,EAAqBH,EAAYA,EAAUI,KAAK,KAAOtI,UAE7D,OACEuB,EAAA,QACEC,OAAK0B,EAAA,GACHA,EAACmF,KAAuBA,EACxBnF,EAACkF,KAAyBA,E,IAG3BG,EAAmBpH,G,EAK1B8F,KAAM,SAAC9F,GAAmB,OAAAA,EAAQoC,KAAR,GAG5B,SAASgF,EAAmBpH,GAC1B,OAAOA,EAAQgB,SAASM,KAAI,SAAAiF,GAAS,OAAAO,EAAoBP,EAAMxC,MAAMwC,EAAhC,GACvC,CAEA,IAAMN,EAAsB,SAACC,G,MAC3B,IAAMrC,EAAYqC,EAAoBlF,SAAS8C,IAAI,GAGnD,KAAK/B,EAAA8B,EAAuB7C,YAAQ,MAAAe,SAAA,SAAAA,EAAEX,QAAS,EAAG,CAChD,OAAO6E,EAAoBpC,E,CAG7B,OAAOqC,CACT,EAEO,IAAM/C,EAAiB,SAC5BJ,EACAsE,EACAhE,EACAiE,GAA0B,OAAAzG,UAAAC,OAAA,qB,sEAEpByG,EAAiBC,EAA8BH,GAAY,aAGjE,SAAMI,EAAiBF,I,OAAvBxF,EAAAC,OAEM0F,EAAcC,EAAgBJ,EAAgBxE,GACpDjD,EAAkBjB,UAGlB,GAAIyI,EAAmB,CACrBxH,EAAkBmG,EAAoByB,E,CAGlCE,EAAuBN,GAAqBI,IAAS5H,EAE3D,SAAOuD,EAAW,CAChBgE,SAAUA,GAAY,YACtBO,qBAAsBA,EACtBC,UAAW9E,EACXyD,gBAAiBkB,EAAK1G,SAASM,KAAI,SAAAiF,GACjC,OAAAO,EAAoBP,EAAMxC,MAAMwC,EAAhC,O,QAQC,IAAMuB,EAAwC,SACnDC,G,MAAkC,OAElC3H,EAAA,WACEA,EAAA,QACEC,OAAK0B,EAAA,GACHA,EAAC,iBAAAoC,OAAiB4D,EAAQV,WAAa,KACvCtF,EAACpC,GAA0BoI,EAAQH,qB,IAGrCxH,EAAA,OAAKC,MAAM,uBAAuB0H,EAAQvB,kBATZ,E,2EC1FpC,IAAMwB,EAAc,2OACpB,IAAAC,EAAeD,E,IC0BFE,EAAUC,EAAA,eAAAC,EAAA,W,cACrBC,EAAAjJ,IAAAkJ,UAAA,G,uBAaoC,M,gBAKcR,E,iIAO5CS,EAAAC,UAAAC,oBAAN,W,kHACE,IAAKH,KAAKlG,MAAO,CACf,S,IAGFkG,KAAID,GAAY,SAAM5B,EAAc6B,KAAKlG,MAAO,CAC9CkC,QAASgE,KAAKI,QACdhE,mBAAoB,KACpBrB,WAAYiF,KAAKjF,c,OAHnBsF,uBAAAC,WAAA,EAAA7G,EAAAoC,OAAA,CAAgBjB,EAAAlB,OAId,O,kBAGJuG,EAAAC,UAAAK,OAAA,WACE,IAAKP,KAAKlG,MAAO,CACf,MAAO,E,CAGT,OAAOhC,EAAC0I,EAAI,KAAEC,uBAAAT,KAAID,EAAA,K,WA3CC,G"}