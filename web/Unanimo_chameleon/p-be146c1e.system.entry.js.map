{"version":3,"names":["cellIsRendered","cell","hasAttribute","style","display","isRenderedSmartCellVisible","element","smartGridBoundingRect","elementRect","getBoundingClientRect","smartGridRectLeftX","x","smartGridRectRightX","width","smartGridRectTopY","y","smartGridRectBottomY","height","rectLeftX","rectRightX","rectTopY","rectBottomY","inBetween","isVirtualSizeCellVisible","virtualSize","smartGridScrollTop","offsetTop","emptyItems","items","undefined","length","getSmartCells","scroller","__spreadArray","querySelectorAll","updateVirtualScrollSize","virtualPosition","virtualSizes","removedCells","renderedItemKeys","Set","index","startIndex","endIndex","smartGridItem","add","id","renderedCells","forEach","renderedCell","has","cellId","offsetLeft","cellBoundingRect","push","set","cellsInViewportAreLoadedAndVisible","smartGrid","inverseLoading","cells","smartGridBoundingBox","lastIndex","increment","currentCell","WAITING_FOR_CELLS_TO_BE_RENDERED","type","findFirstVirtualSizeThatIsNotVisible","bufferSize","closerVirtualSizeId","closerVirtualSizeBottomY","virtualSizeId","virtualSizeBottomY","virtualSizeIsHidden","closerVirtualItemIndex","findIndex","el","Math","max","renderedCellsCount","cellsThatAreNotVisible","get","isVirtualSizeVisible","isRenderedCellVisible","min","LOWER_BUFFER_RANGE","firstIndex","UPPER_BUFFER_RANGE","getAmountOfCellsThatAreVisibleInTheBuffer","lastRenderedCellIndex","indexLimit","checkIndexRange","currentIndex","shift","getNewStartAndEndIndexes","virtualStartSize","virtualEndSize","allCellsAreRendered","every","scrollTop","secondRenderedCell","scrollIsAtVirtualStartSize","secondLastCell","at","scrollIsAtVirtualEndSize","startShift","endShift","virtualScrollerCss","ChVirtualScrollerStyle0","VIRTUAL_SCROLL_CUSTOM_VAR_PREFIX","VIRTUAL_SCROLL_START_SIZE_CUSTOM_VAR","concat","VIRTUAL_SCROLL_START_DISPLAY_CUSTOM_VAR","VIRTUAL_SCROLL_END_SIZE_CUSTOM_VAR","VIRTUAL_SCROLL_END_DISPLAY_CUSTOM_VAR","ChVirtualScroller","exports","_a","_startIndex","this","_endIndex","_virtualStartSize","_virtualEndSize","_canUpdateRenderedCells","_waitingForCellsToBeRendered","_abortController","_syncWithRAF","SyncWithRAF","_virtualSizes","_resizeObserver","_smartGrid","_updateVirtualScrollSize","__classPrivateFieldSet","_this","__classPrivateFieldGet","lastIndexForVirtualStartSize","firstIndexForVirtualEndSize","lastCellForVirtualStartSize","firstCellForVirtualEndSize","additionalHeightsStartIndex","virtualIndex","cellIdToAddVirtualSize","maxSmartGridVirtualHeight_1","removedCell","setProperty","_handleSmartGridContentScroll","perform","_updateRenderedCells","cellsToRender","bufferAmount","_shiftIndex","call","_emitVirtualItemsChange","virtualItems","slice","virtualItemsChanged","emit","totalItems","_resetVirtualScrollerState","mode","Map","_setViewportItemsOnInitialRender","indexToShift","initialRenderViewportItems","startIncomingShift","endIncomingShift","newEndIndex","newStartIndex","_setVirtualScroller","AbortController","requestAnimationFrame","addEventListener","passive","signal","ResizeObserver","observe","_handleRenderedCell","event","waitingForContent","_checkInitialRenderVisibility","_checkCellsRenderedAtRuntime","detail","virtualScrollerDidLoad","delete","class_1","prototype","waitingForContentChanged","itemsChanged","newItems","addItems","position","_i","arguments","_b","unshift","apply","newItemsCount","_c","connectedCallback","componentDidLoad","closest","disconnectedCallback","disconnect","cancel","abort","render","h","Host","key","class","onSlotchange"],"sources":["src/virtual-scroller/utils.ts","src/virtual-scroller/update-virtual-scroll.ts","src/virtual-scroller/cells-in-viewport-are-rendered-and-visible.ts","src/virtual-scroller/get-new-start-and-end-indexes.ts","src/virtual-scroller/virtual-scroller.scss?tag=ch-virtual-scroller&encapsulation=shadow","src/virtual-scroller/virtual-scroller.tsx"],"sourcesContent":["import { inBetween } from \"../common/utils\";\r\nimport { SmartGridModel } from \"../components/smart-grid/types\";\r\nimport { SmartGridCellVirtualSize } from \"./types\";\r\n\r\nexport const cellIsRendered = (cell: HTMLElement) =>\r\n  cell.hasAttribute(\"data-did-load\") && cell.style.display !== \"none\";\r\n\r\nexport const isRenderedSmartCellVisible = (\r\n  element: HTMLElement,\r\n  smartGridBoundingRect: DOMRect\r\n) => {\r\n  const elementRect = element.getBoundingClientRect();\r\n\r\n  const smartGridRectLeftX = smartGridBoundingRect.x;\r\n  const smartGridRectRightX =\r\n    smartGridBoundingRect.x + smartGridBoundingRect.width;\r\n\r\n  const smartGridRectTopY = smartGridBoundingRect.y;\r\n  const smartGridRectBottomY =\r\n    smartGridBoundingRect.y + smartGridBoundingRect.height;\r\n\r\n  const rectLeftX = elementRect.x;\r\n  const rectRightX = elementRect.x + elementRect.width;\r\n\r\n  const rectTopY = elementRect.y;\r\n  const rectBottomY = elementRect.y + elementRect.height;\r\n\r\n  return (\r\n    // At least, the left or right edge is visible in the X axis\r\n    (inBetween(smartGridRectLeftX, rectLeftX, smartGridRectRightX) ||\r\n      inBetween(smartGridRectLeftX, rectRightX, smartGridRectRightX)) &&\r\n    // At least, the top or bottom edge is visible in the Y axis\r\n    (inBetween(smartGridRectTopY, rectTopY, smartGridRectBottomY) ||\r\n      inBetween(smartGridRectTopY, rectBottomY, smartGridRectBottomY))\r\n  );\r\n};\r\n\r\nexport const isVirtualSizeCellVisible = (\r\n  virtualSize: SmartGridCellVirtualSize,\r\n  smartGridScrollTop: number,\r\n  smartGridBoundingRect: DOMRect\r\n): boolean => {\r\n  const smartGridRectTopY = smartGridScrollTop;\r\n  const smartGridRectBottomY =\r\n    smartGridScrollTop + smartGridBoundingRect.height;\r\n  const rectTopY = virtualSize.offsetTop;\r\n  const rectBottomY = virtualSize.offsetTop + virtualSize.height;\r\n\r\n  // At least, the top or bottom edge is visible in the Y axis\r\n  return (\r\n    inBetween(smartGridRectTopY, rectTopY, smartGridRectBottomY) ||\r\n    inBetween(smartGridRectTopY, rectBottomY, smartGridRectBottomY)\r\n  );\r\n};\r\n\r\nexport const emptyItems = (items: SmartGridModel) =>\r\n  items === undefined || items.length === 0;\r\n\r\nexport const getSmartCells = (scroller: HTMLChVirtualScrollerElement) =>\r\n  [\r\n    ...scroller.querySelectorAll(\":scope>ch-smart-grid-cell\")\r\n  ] as HTMLChSmartGridCellElement[];\r\n","import { SmartGridModel } from \"../components/smart-grid/types\";\r\nimport {\r\n  SmartGridCellVirtualSize,\r\n  SmartGridVirtualPositionIndex\r\n} from \"./types\";\r\nimport { cellIsRendered } from \"./utils\";\r\n\r\n/**\r\n * Update the virtual sizes and returns the removed cells.\r\n */\r\nexport const updateVirtualScrollSize = (\r\n  virtualPosition: SmartGridVirtualPositionIndex,\r\n  virtualSizes: Map<string, SmartGridCellVirtualSize>,\r\n  items: SmartGridModel\r\n): HTMLChSmartGridCellElement[] => {\r\n  const removedCells: HTMLChSmartGridCellElement[] = [];\r\n\r\n  const renderedItemKeys: Set<string> = new Set();\r\n\r\n  // Store the keys of the items that must be rendered\r\n  for (\r\n    let index = virtualPosition.startIndex;\r\n    index <= virtualPosition.endIndex;\r\n    index++\r\n  ) {\r\n    const smartGridItem = items[index];\r\n    renderedItemKeys.add(smartGridItem.id);\r\n  }\r\n\r\n  // Remove rendered cells that are will be no longer displayed\r\n  virtualPosition.renderedCells.forEach(renderedCell => {\r\n    if (\r\n      !renderedItemKeys.has(renderedCell.cellId) &&\r\n      cellIsRendered(renderedCell) &&\r\n      renderedCell.style.display !== \"none\"\r\n    ) {\r\n      const { offsetTop, offsetLeft } = renderedCell;\r\n      const cellBoundingRect = renderedCell.getBoundingClientRect();\r\n\r\n      removedCells.push(renderedCell);\r\n\r\n      virtualSizes.set(renderedCell.cellId, {\r\n        width: cellBoundingRect.width,\r\n        height: cellBoundingRect.height,\r\n        offsetTop: offsetTop,\r\n        offsetLeft: offsetLeft\r\n      });\r\n    }\r\n  });\r\n\r\n  return removedCells;\r\n};\r\n","import { inBetween } from \"../common/utils\";\r\nimport {\r\n  cellIsRendered,\r\n  getSmartCells,\r\n  isRenderedSmartCellVisible\r\n} from \"./utils\";\r\n\r\n// TODO: Use padding in the ch-smart-grid and see if this works well\r\nexport const cellsInViewportAreLoadedAndVisible = (\r\n  scroller: HTMLChVirtualScrollerElement,\r\n  smartGrid: HTMLChSmartGridElement,\r\n  inverseLoading: boolean\r\n): boolean => {\r\n  const cells = getSmartCells(scroller);\r\n  const smartGridBoundingBox = smartGrid.getBoundingClientRect();\r\n\r\n  const lastIndex = cells.length - 1;\r\n  let startIndex = inverseLoading ? lastIndex : 0;\r\n  const increment = inverseLoading ? -1 : 1;\r\n\r\n  while (inBetween(0, startIndex, lastIndex)) {\r\n    const currentCell = cells[startIndex];\r\n\r\n    if (cellIsRendered(currentCell)) {\r\n      // The previous cells were visible, but we found a cell that is rendered\r\n      // and its not in the viewport. Assume that the cell won't be displayed\r\n      // in the viewport even when it's fully rendered\r\n      if (!isRenderedSmartCellVisible(currentCell, smartGridBoundingBox)) {\r\n        return true;\r\n      }\r\n    }\r\n    // There is a cell that isn't rendered, we can check its visibility, but\r\n    // we can't ensure if when the cell is rendered, the next cells will be\r\n    // visible or not\r\n    else {\r\n      return false;\r\n    }\r\n\r\n    startIndex += increment;\r\n  }\r\n\r\n  return true;\r\n};\r\n","import { inBetween } from \"../common/utils\";\r\nimport { SmartGridModel } from \"../components/smart-grid/types\";\r\nimport { SmartGridVirtualPosition, SmartGridCellVirtualSize } from \"./types\";\r\nimport {\r\n  cellIsRendered,\r\n  getSmartCells,\r\n  isRenderedSmartCellVisible,\r\n  isVirtualSizeCellVisible\r\n} from \"./utils\";\r\n\r\nconst WAITING_FOR_CELLS_TO_BE_RENDERED = {\r\n  type: \"waiting-for-cells-to-render\"\r\n} as const satisfies SmartGridVirtualPosition;\r\n\r\nconst findFirstVirtualSizeThatIsNotVisible = (\r\n  renderedCells: HTMLChSmartGridCellElement[],\r\n  items: SmartGridModel,\r\n  virtualSizes: Map<string, SmartGridCellVirtualSize>,\r\n  bufferSize: number,\r\n  smartGridScrollTop: number,\r\n  smartGridBoundingRect: DOMRect,\r\n  inverseLoading: boolean\r\n): SmartGridVirtualPosition => {\r\n  let closerVirtualSizeId = \"\";\r\n  let closerVirtualSizeBottomY = 0;\r\n\r\n  // Find the key of the closer virtual size to the viewport that isn't visible\r\n  virtualSizes.forEach((virtualSize, virtualSizeId) => {\r\n    const virtualSizeBottomY = virtualSize.offsetTop + virtualSize.height;\r\n    const virtualSizeIsHidden = virtualSizeBottomY <= smartGridScrollTop;\r\n\r\n    if (virtualSizeIsHidden && closerVirtualSizeBottomY <= virtualSizeBottomY) {\r\n      closerVirtualSizeBottomY = virtualSizeBottomY;\r\n      closerVirtualSizeId = virtualSizeId;\r\n    }\r\n  });\r\n\r\n  // TODO: Use memory to retrieve the index given the cellId\r\n  const closerVirtualItemIndex = items.findIndex(\r\n    el => el.id === closerVirtualSizeId\r\n  );\r\n\r\n  // Since we found the closer hidden virtual size, the shift is one cell smaller\r\n  const startIndex = Math.max(0, closerVirtualItemIndex + 1 - bufferSize);\r\n  const lastIndex = items.length - 1;\r\n  let endIndex = closerVirtualItemIndex + 1; // Start in the first visible cell\r\n  let renderedCellsCount = 0;\r\n  let cellsThatAreNotVisible = 0;\r\n\r\n  // When the virtual scroll has inverse loading enabled, all items on the end\r\n  // of the viewport are always rendered, to avoid flickering issues with the\r\n  // scroll. In other words, the endIndex is always the last index\r\n  if (inverseLoading) {\r\n    return {\r\n      startIndex,\r\n      endIndex: lastIndex,\r\n      renderedCells,\r\n      type: \"index\"\r\n    };\r\n  }\r\n\r\n  // Find the endIndex to render the cells. This index takes into account the\r\n  // cells that must be not visible in the buffer\r\n  while (\r\n    inBetween(0, endIndex, lastIndex) &&\r\n    cellsThatAreNotVisible < bufferSize\r\n  ) {\r\n    const cellId = items[endIndex].id;\r\n    const virtualSize = virtualSizes.get(cellId);\r\n\r\n    if (virtualSize) {\r\n      const isVirtualSizeVisible = isVirtualSizeCellVisible(\r\n        virtualSize,\r\n        smartGridScrollTop,\r\n        smartGridBoundingRect\r\n      );\r\n\r\n      if (!isVirtualSizeVisible) {\r\n        cellsThatAreNotVisible++;\r\n      }\r\n    }\r\n    // We assume that the rendered cells are sorted\r\n    else {\r\n      const renderedCell = renderedCells[renderedCellsCount];\r\n\r\n      const isRenderedCellVisible = isRenderedSmartCellVisible(\r\n        renderedCell,\r\n        smartGridBoundingRect\r\n      );\r\n\r\n      if (!isRenderedCellVisible) {\r\n        cellsThatAreNotVisible++;\r\n      }\r\n\r\n      renderedCellsCount++;\r\n    }\r\n\r\n    endIndex++;\r\n  }\r\n\r\n  endIndex = Math.min(lastIndex, endIndex + bufferSize - 1);\r\n\r\n  return {\r\n    startIndex,\r\n    endIndex,\r\n    renderedCells,\r\n    type: \"index\"\r\n  };\r\n};\r\n\r\nconst LOWER_BUFFER_RANGE = (index: number, firstIndex) => firstIndex <= index;\r\nconst UPPER_BUFFER_RANGE = (index: number, lastIndex) => index <= lastIndex;\r\n\r\nconst getAmountOfCellsThatAreVisibleInTheBuffer = (\r\n  increment: -1 | 1,\r\n  bufferSize: number,\r\n  renderedCells: HTMLChSmartGridCellElement[],\r\n  smartGridBoundingRect: DOMRect\r\n): number => {\r\n  const lastRenderedCellIndex = renderedCells.length - 1;\r\n\r\n  const indexLimit =\r\n    increment === 1 ? lastRenderedCellIndex - bufferSize : bufferSize;\r\n  const checkIndexRange =\r\n    increment === 1 ? UPPER_BUFFER_RANGE : LOWER_BUFFER_RANGE;\r\n\r\n  // Depending on the direction, start from the first or last index of the\r\n  // current rendered cells\r\n  let currentIndex = increment === 1 ? 0 : lastRenderedCellIndex;\r\n  let shift = bufferSize;\r\n\r\n  // Check how many cells are visible in the buffer\r\n  while (checkIndexRange(currentIndex, indexLimit)) {\r\n    const currentCell = renderedCells[currentIndex];\r\n\r\n    if (isRenderedSmartCellVisible(currentCell, smartGridBoundingRect)) {\r\n      break;\r\n    }\r\n\r\n    shift--;\r\n    currentIndex += increment;\r\n  }\r\n\r\n  return shift;\r\n};\r\n\r\n/**\r\n * Depending on the scroll position and the bufferSize, it returns the start\r\n * and end index of the virtual array to rendered the cells\r\n */\r\nexport const getNewStartAndEndIndexes = (\r\n  scroller: HTMLChVirtualScrollerElement,\r\n  smartGrid: HTMLChSmartGridElement,\r\n  items: SmartGridModel,\r\n  virtualSizes: Map<string, SmartGridCellVirtualSize>,\r\n  virtualStartSize: number,\r\n  virtualEndSize: number,\r\n  bufferSize: number,\r\n  inverseLoading: boolean\r\n): SmartGridVirtualPosition => {\r\n  const renderedCells = getSmartCells(scroller);\r\n  const allCellsAreRendered = renderedCells.every(cellIsRendered);\r\n\r\n  // All cells must be rendered before trying to update the DOM\r\n  if (!allCellsAreRendered) {\r\n    return WAITING_FOR_CELLS_TO_BE_RENDERED;\r\n  }\r\n\r\n  // DOM read operations\r\n  const smartGridBoundingRect = smartGrid.getBoundingClientRect();\r\n  const smartGridScrollTop = smartGrid.scrollTop;\r\n\r\n  // TODO: Force the buffer to be at least 2\r\n  const secondRenderedCell = renderedCells[1];\r\n\r\n  const scrollIsAtVirtualStartSize =\r\n    virtualStartSize > 0 &&\r\n    secondRenderedCell.style.display !== \"none\" &&\r\n    smartGridScrollTop < secondRenderedCell.offsetTop;\r\n\r\n  if (scrollIsAtVirtualStartSize) {\r\n    return findFirstVirtualSizeThatIsNotVisible(\r\n      renderedCells,\r\n      items,\r\n      virtualSizes,\r\n      bufferSize,\r\n      smartGridScrollTop,\r\n      smartGridBoundingRect,\r\n      inverseLoading\r\n    );\r\n  }\r\n\r\n  const secondLastCell = renderedCells.at(-2);\r\n\r\n  const scrollIsAtVirtualEndSize =\r\n    virtualEndSize > 0 &&\r\n    secondLastCell.style.display !== \"none\" &&\r\n    secondLastCell.offsetTop + secondLastCell.getBoundingClientRect().height <\r\n      smartGridScrollTop;\r\n\r\n  if (scrollIsAtVirtualEndSize) {\r\n    return findFirstVirtualSizeThatIsNotVisible(\r\n      renderedCells,\r\n      items,\r\n      virtualSizes,\r\n      bufferSize,\r\n      smartGridScrollTop,\r\n      smartGridBoundingRect,\r\n      inverseLoading\r\n    );\r\n  }\r\n\r\n  const startShift = getAmountOfCellsThatAreVisibleInTheBuffer(\r\n    1,\r\n    bufferSize,\r\n    renderedCells,\r\n    smartGridBoundingRect\r\n  );\r\n  const endShift = inverseLoading\r\n    ? // We could use zero instead of this value, but this value ensure that\r\n      // dynamically added items at the end will always be rendered in the next\r\n      // frame\r\n      items.length - 1\r\n    : getAmountOfCellsThatAreVisibleInTheBuffer(\r\n        -1,\r\n        bufferSize,\r\n        renderedCells,\r\n        smartGridBoundingRect\r\n      );\r\n\r\n  return { startShift, endShift, renderedCells, type: \"shift\" };\r\n};\r\n",":host {\r\n  --ch-virtual-scroll__scroll-start-size: 0px;\r\n  --ch-virtual-scroll__scroll-end-size: 0px;\r\n\r\n  --ch-virtual-scroll__scroll-start-display: none;\r\n  --ch-virtual-scroll__scroll-end-display: none;\r\n\r\n  display: grid;\r\n  grid-auto-rows: max-content;\r\n}\r\n\r\n:host(.ch-virtual-scroller--content-not-loaded) {\r\n  opacity: 0;\r\n  // Necessary to ensure the scroll is positioned correctly when using inverseLoading\r\n  pointer-events: none;\r\n}\r\n\r\n// This is an optimization to avoid flickering when swapping cell.\r\n// With this CSS, cells being rendered do not take up space until they are\r\n// fully rendered. When they are fully rendered, we make the cells take up\r\n// space and in the same DOM write operation we update the virtual scroll size\r\n:host(.ch-virtual-scroller--content-loaded)\r\n  ::slotted(ch-smart-grid-cell:not([data-did-load])) {\r\n  position: absolute;\r\n  pointer-events: none;\r\n  visibility: hidden;\r\n}\r\n\r\n:host(.ch-virtual-scroller--virtual-scroll) {\r\n  &::before {\r\n    content: \"\";\r\n    display: var(--ch-virtual-scroll__scroll-start-display);\r\n    block-size: calc(var(--ch-virtual-scroll__scroll-start-size));\r\n    inline-size: 0px;\r\n    pointer-events: none;\r\n  }\r\n\r\n  &::after {\r\n    content: \"\";\r\n    display: var(--ch-virtual-scroll__scroll-end-display);\r\n    block-size: calc(var(--ch-virtual-scroll__scroll-end-size));\r\n    inline-size: 0px;\r\n    pointer-events: none;\r\n  }\r\n}\r\n","import {\r\n  Component,\r\n  ComponentInterface,\r\n  Element,\r\n  Event,\r\n  EventEmitter,\r\n  h,\r\n  Host,\r\n  Method,\r\n  Prop,\r\n  State,\r\n  Watch\r\n} from \"@stencil/core\";\r\nimport { emptyItems } from \"./utils\";\r\nimport { SyncWithRAF } from \"../common/sync-with-frames\";\r\nimport { SmartGridModel } from \"../components/smart-grid/types\";\r\nimport { SmartGridCellVirtualSize, VirtualScrollVirtualItems } from \"./types\";\r\nimport { updateVirtualScrollSize } from \"./update-virtual-scroll\";\r\nimport { ChSmartGridCellCustomEvent } from \"../components\";\r\nimport { cellsInViewportAreLoadedAndVisible } from \"./cells-in-viewport-are-rendered-and-visible\";\r\nimport { getNewStartAndEndIndexes } from \"./get-new-start-and-end-indexes\";\r\n\r\nconst VIRTUAL_SCROLL_CUSTOM_VAR_PREFIX = \"--ch-virtual-scroll__scroll-\";\r\n\r\nconst VIRTUAL_SCROLL_START_SIZE_CUSTOM_VAR = `${VIRTUAL_SCROLL_CUSTOM_VAR_PREFIX}start-size`;\r\nconst VIRTUAL_SCROLL_START_DISPLAY_CUSTOM_VAR = `${VIRTUAL_SCROLL_CUSTOM_VAR_PREFIX}start-display`;\r\n\r\nconst VIRTUAL_SCROLL_END_SIZE_CUSTOM_VAR = `${VIRTUAL_SCROLL_CUSTOM_VAR_PREFIX}end-size`;\r\nconst VIRTUAL_SCROLL_END_DISPLAY_CUSTOM_VAR = `${VIRTUAL_SCROLL_CUSTOM_VAR_PREFIX}end-display`;\r\n\r\n@Component({\r\n  shadow: true,\r\n  styleUrl: \"virtual-scroller.scss\",\r\n  tag: \"ch-virtual-scroller\"\r\n})\r\nexport class ChVirtualScroller implements ComponentInterface {\r\n  #startIndex = 0;\r\n  #endIndex = 0;\r\n\r\n  #virtualStartSize = 0;\r\n  #virtualEndSize = 0;\r\n\r\n  #canUpdateRenderedCells = true;\r\n  #waitingForCellsToBeRendered = false;\r\n\r\n  #abortController: AbortController | undefined; // Allocated at runtime to save resources\r\n  #syncWithRAF = new SyncWithRAF();\r\n\r\n  #virtualSizes: Map<string, SmartGridCellVirtualSize> | undefined; // Allocated at runtime to save resources\r\n\r\n  #resizeObserver: ResizeObserver | undefined;\r\n\r\n  /**\r\n   * This element represents the ch-smart-grid element.\r\n   * ```tsx\r\n   *   <ch-smart-grid>\r\n   *     #shadow-root (open)\r\n   *     |  <ch-infinite-scroll></ch-infinite-scroll>\r\n   *     |  <slot name=\"grid-content\"></slot>\r\n   *     <ch-smart-grid-virtual-scroller slot=\"grid-content\">\r\n   *       <ch-smart-grid-cell>...</ch-smart-grid-cell>\r\n   *       <ch-smart-grid-cell>...</ch-smart-grid-cell>\r\n   *       ...\r\n   *     </ch-smart-grid-virtual-scroller>\r\n   *   </ch-smart-grid>\r\n   * ```\r\n   */\r\n  // eslint-disable-next-line @stencil-community/own-props-must-be-private\r\n  #smartGrid!: HTMLChSmartGridElement | undefined;\r\n\r\n  @Element() el!: HTMLChVirtualScrollerElement;\r\n\r\n  /**\r\n   * `true` if the virtual scroller is waiting for all the content to be\r\n   * rendered.\r\n   */\r\n  @State() waitingForContent = true;\r\n  @Watch(\"waitingForContent\")\r\n  waitingForContentChanged() {\r\n    this.#setVirtualScroller();\r\n  }\r\n\r\n  /**\r\n   * The number of elements to be rendered above and below the current\r\n   * container's viewport.\r\n   */\r\n  @Prop() readonly bufferAmount: number = 5;\r\n\r\n  /**\r\n   * Specifies an estimation for the items that will enter in the viewport of\r\n   * the initial render.\r\n   */\r\n  // TODO: Ensure a min value\r\n  @Prop() readonly initialRenderViewportItems: number = 10;\r\n\r\n  /**\r\n   * When set to `true`, the grid items will be loaded in inverse order, with\r\n   * the scroll positioned at the bottom on the initial load.\r\n   *\r\n   * If `mode=\"virtual-scroll\"`, only the items at the start of the viewport\r\n   * that are not visible will be removed from the DOM. The items at the end of\r\n   * the viewport that are not visible will remain rendered to avoid flickering\r\n   * issues.\r\n   */\r\n  @Prop() readonly inverseLoading: boolean = false;\r\n\r\n  /**\r\n   * The array of items to be rendered in the ch-smart-grid.\r\n   */\r\n  @Prop() readonly items!: SmartGridModel | undefined;\r\n  @Watch(\"items\")\r\n  itemsChanged(newItems: SmartGridModel) {\r\n    this.#resetVirtualScrollerState();\r\n    this.#setViewportItemsOnInitialRender(newItems);\r\n  }\r\n\r\n  /**\r\n   * The number of elements in the items array.\r\n   * Use if the array changes, without recreating the array.\r\n   */\r\n  @Prop() readonly itemsCount: number;\r\n\r\n  /**\r\n   * Specifies how the control will behave.\r\n   */\r\n  @Prop() readonly mode: \"virtual-scroll\" | \"lazy-render\" = \"virtual-scroll\";\r\n\r\n  /**\r\n   * Emitted when the array of visible items in the ch-smart-grid changes.\r\n   */\r\n  @Event()\r\n  virtualItemsChanged: EventEmitter<VirtualScrollVirtualItems>;\r\n\r\n  /**\r\n   * Fired when the visible content of the virtual scroller did render for the\r\n   * first time.\r\n   */\r\n  @Event() virtualScrollerDidLoad: EventEmitter;\r\n\r\n  /**\r\n   * Add items to the beginning or end of the items property. This method is\r\n   * useful for adding new items to the collection, without impacting in the\r\n   * internal indexes used to display the virtual items. Without this method,\r\n   * the virtual scroll would behave unexpectedly when new items are added.\r\n   */\r\n  @Method()\r\n  async addItems(position: \"start\" | \"end\", ...items: SmartGridModel) {\r\n    if (position === \"start\") {\r\n      this.items.unshift(...items);\r\n\r\n      const newItemsCount = items.length;\r\n      this.#startIndex += newItemsCount;\r\n      this.#endIndex += newItemsCount;\r\n    } else {\r\n      this.items.push(...items);\r\n    }\r\n\r\n    this.#handleSmartGridContentScroll();\r\n  }\r\n\r\n  // TODO: Check what happens when the cells has margin\r\n  #updateVirtualScrollSize = (removedCells?: HTMLChSmartGridCellElement[]) => {\r\n    this.#virtualStartSize = 0;\r\n    this.#virtualEndSize = 0;\r\n\r\n    const items = this.items;\r\n    const virtualSizes = this.#virtualSizes;\r\n    const lastIndex = items.length - 1;\r\n\r\n    // - - - - - - - - - - - - - DOM read operations - - - - - - - - - - - - -\r\n    const lastIndexForVirtualStartSize = Math.max(0, this.#startIndex - 1);\r\n    const firstIndexForVirtualEndSize = Math.min(lastIndex, this.#endIndex + 1);\r\n\r\n    const lastCellForVirtualStartSize = virtualSizes.get(\r\n      items[lastIndexForVirtualStartSize].id\r\n    );\r\n    const firstCellForVirtualEndSize = virtualSizes.get(\r\n      items[firstIndexForVirtualEndSize].id\r\n    );\r\n\r\n    // The virtual start size is at least the last unrendered cell\r\n    if (lastCellForVirtualStartSize) {\r\n      this.#virtualStartSize =\r\n        lastCellForVirtualStartSize.offsetTop +\r\n        lastCellForVirtualStartSize.height;\r\n    }\r\n\r\n    const additionalHeightsStartIndex = Math.max(1, this.#startIndex);\r\n\r\n    // TODO: Add support for gap in this virtual sizes\r\n    // Between two different animation frames, rendered cells can be destroyed\r\n    // and replaced by other new ones. When cells are destroyed the scroll size\r\n    // must be maintained. To do this, the virtual start size is increased by\r\n    // the size of the cells that have not yet been rendered\r\n    for (\r\n      let virtualIndex = additionalHeightsStartIndex;\r\n      virtualIndex < this.#endIndex;\r\n      virtualIndex++\r\n    ) {\r\n      const cellIdToAddVirtualSize = items[virtualIndex].id;\r\n      const virtualSize = virtualSizes.get(cellIdToAddVirtualSize);\r\n\r\n      if (virtualSize) {\r\n        this.#virtualStartSize += virtualSize.height;\r\n      }\r\n    }\r\n\r\n    // Additional size for the virtual start scroll\r\n    if (this.#endIndex === lastIndex) {\r\n      const cellIdToAddVirtualSize = items[this.#endIndex].id;\r\n      const virtualSize = virtualSizes.get(cellIdToAddVirtualSize);\r\n\r\n      if (virtualSize) {\r\n        this.#virtualStartSize += virtualSize.height;\r\n      }\r\n    }\r\n    // Virtual end scroll\r\n    else if (firstCellForVirtualEndSize) {\r\n      let maxSmartGridVirtualHeight = 0;\r\n\r\n      virtualSizes.forEach(virtualSize => {\r\n        maxSmartGridVirtualHeight = Math.max(\r\n          maxSmartGridVirtualHeight,\r\n          virtualSize.offsetTop + virtualSize.height\r\n        );\r\n      });\r\n\r\n      this.#virtualEndSize =\r\n        maxSmartGridVirtualHeight - firstCellForVirtualEndSize.offsetTop;\r\n    }\r\n\r\n    // - - - - - - - - - - - - - DOM write operations - - - - - - - - - - - - -\r\n    // Faster removal of the cells, due to the virtual height will be updated\r\n    // in the next DOM write operation\r\n    removedCells?.forEach(removedCell => {\r\n      removedCell.style.display = \"none\";\r\n    });\r\n\r\n    this.el.style.setProperty(\r\n      VIRTUAL_SCROLL_START_SIZE_CUSTOM_VAR,\r\n      `${this.#virtualStartSize}px`\r\n    );\r\n    this.el.style.setProperty(\r\n      VIRTUAL_SCROLL_START_DISPLAY_CUSTOM_VAR,\r\n      // The virtual size must be \"destroyed\" to avoid displaying and\r\n      // unnecessary gap at the start of the scroll\r\n      this.#virtualStartSize === 0 ? \"none\" : \"block\"\r\n    );\r\n\r\n    this.el.style.setProperty(\r\n      VIRTUAL_SCROLL_END_SIZE_CUSTOM_VAR,\r\n      `${this.#virtualEndSize}px`\r\n    );\r\n    this.el.style.setProperty(\r\n      VIRTUAL_SCROLL_END_DISPLAY_CUSTOM_VAR,\r\n      // The virtual size must be \"destroyed\" to avoid displaying and\r\n      // unnecessary gap at the end of the scroll\r\n      this.#virtualEndSize === 0 ? \"none\" : \"block\"\r\n    );\r\n  };\r\n\r\n  #handleSmartGridContentScroll = () => {\r\n    if (this.#canUpdateRenderedCells) {\r\n      this.#syncWithRAF.perform(this.#updateRenderedCells);\r\n    }\r\n  };\r\n\r\n  #updateRenderedCells = () => {\r\n    // this.#canUpdateRenderedCells = false;\r\n\r\n    // requestAnimationFrame(() => {\r\n    //   this.#canUpdateRenderedCells = true;\r\n    // });\r\n\r\n    const cellsToRender = getNewStartAndEndIndexes(\r\n      this.el,\r\n      this.#smartGrid,\r\n      this.items,\r\n      this.#virtualSizes,\r\n      this.#virtualStartSize,\r\n      this.#virtualEndSize,\r\n      this.bufferAmount,\r\n      this.inverseLoading\r\n    );\r\n\r\n    if (cellsToRender.type === \"waiting-for-cells-to-render\") {\r\n      this.#waitingForCellsToBeRendered = true;\r\n      return;\r\n    }\r\n    this.#waitingForCellsToBeRendered = false;\r\n\r\n    if (cellsToRender.type === \"shift\") {\r\n      if (cellsToRender.startShift === 0 && cellsToRender.endShift === 0) {\r\n        return;\r\n      }\r\n\r\n      this.#shiftIndex(\r\n        cellsToRender.startShift,\r\n        cellsToRender.endShift,\r\n        cellsToRender.renderedCells\r\n      );\r\n    }\r\n    //\r\n    else {\r\n      const { startIndex, endIndex } = cellsToRender;\r\n\r\n      // Nothing to update\r\n      if (this.#startIndex === startIndex && this.#endIndex === endIndex) {\r\n        return;\r\n      }\r\n\r\n      const removedCells = updateVirtualScrollSize(\r\n        cellsToRender,\r\n        this.#virtualSizes,\r\n        this.items\r\n      );\r\n\r\n      this.#startIndex = startIndex;\r\n      this.#endIndex = endIndex;\r\n\r\n      this.#emitVirtualItemsChange(removedCells);\r\n    }\r\n  };\r\n\r\n  #emitVirtualItemsChange = (removedCells?: HTMLChSmartGridCellElement[]) => {\r\n    this.#updateVirtualScrollSize(removedCells);\r\n    const virtualItems = this.items.slice(this.#startIndex, this.#endIndex + 1);\r\n\r\n    this.virtualItemsChanged.emit({\r\n      startIndex: this.#startIndex,\r\n      endIndex: this.#endIndex,\r\n      totalItems: this.items.length,\r\n      virtualItems\r\n    });\r\n  };\r\n\r\n  #resetVirtualScrollerState = () => {\r\n    this.#virtualStartSize = 0;\r\n    this.#virtualEndSize = 0;\r\n\r\n    // Render the last items when the scroll is inverted\r\n    if (this.inverseLoading) {\r\n      const lastIndex = this.items.length - 1;\r\n\r\n      this.#startIndex = lastIndex;\r\n      this.#endIndex = lastIndex;\r\n    } else {\r\n      this.#startIndex = 0;\r\n      this.#endIndex = 0;\r\n    }\r\n\r\n    if (this.mode === \"virtual-scroll\") {\r\n      this.#virtualSizes = new Map();\r\n    }\r\n  };\r\n\r\n  #setViewportItemsOnInitialRender = (items: SmartGridModel) => {\r\n    if (emptyItems(items)) {\r\n      this.#emitVirtualItemsChange();\r\n      return;\r\n    }\r\n\r\n    const indexToShift = this.initialRenderViewportItems + this.bufferAmount;\r\n\r\n    if (this.inverseLoading) {\r\n      this.#shiftIndex(indexToShift, 0);\r\n    } else {\r\n      this.#shiftIndex(0, indexToShift);\r\n    }\r\n  };\r\n\r\n  #shiftIndex = (\r\n    startIncomingShift: number,\r\n    endIncomingShift: number,\r\n    renderedCells?: HTMLChSmartGridCellElement[]\r\n  ) => {\r\n    const startShift =\r\n      this.mode === \"lazy-render\"\r\n        ? Math.max(0, startIncomingShift)\r\n        : startIncomingShift;\r\n    const endShift =\r\n      this.mode === \"lazy-render\"\r\n        ? Math.max(0, endIncomingShift)\r\n        : endIncomingShift;\r\n\r\n    // Nothing to update\r\n    if (startShift === 0 && endShift === 0) {\r\n      return;\r\n    }\r\n\r\n    const newEndIndex = Math.min(\r\n      this.#endIndex + endShift,\r\n      this.items.length - 1\r\n    );\r\n\r\n    // const lastEndIndex = this.items.length - 1 === endShift;\r\n    // const adjustmentToAvoidFlickering = lastEndIndex ? 1 : 0;\r\n\r\n    const newStartIndex = Math.max(0, this.#startIndex - startShift);\r\n\r\n    // Nothing to update\r\n    if (\r\n      this.#startIndex === newStartIndex &&\r\n      this.#endIndex === newEndIndex &&\r\n      // TODO: Add a unit test for this use case\r\n      this.items.length > 1\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    this.#startIndex = newStartIndex;\r\n    this.#endIndex = newEndIndex;\r\n\r\n    const removedCells =\r\n      this.mode === \"virtual-scroll\" &&\r\n      renderedCells !== undefined &&\r\n      renderedCells.length > 0\r\n        ? updateVirtualScrollSize(\r\n            {\r\n              endIndex: this.#endIndex,\r\n              startIndex: this.#startIndex,\r\n              renderedCells,\r\n              type: \"index\"\r\n            },\r\n            this.#virtualSizes,\r\n            this.items\r\n          )\r\n        : [];\r\n\r\n    this.#emitVirtualItemsChange(removedCells);\r\n  };\r\n\r\n  #setVirtualScroller = () => {\r\n    this.#abortController = new AbortController();\r\n\r\n    // RAF is used to avoid unnecessary check on the initial load when using\r\n    // inverseLoading, since on the initial load the scroll will be repositioned\r\n    requestAnimationFrame(() => {\r\n      this.#smartGrid.addEventListener(\r\n        \"scroll\",\r\n        this.#handleSmartGridContentScroll,\r\n        {\r\n          passive: true,\r\n          signal: this.#abortController.signal\r\n        }\r\n      );\r\n\r\n      this.#resizeObserver = new ResizeObserver(\r\n        this.#handleSmartGridContentScroll\r\n      );\r\n      this.#resizeObserver.observe(this.#smartGrid);\r\n    });\r\n  };\r\n\r\n  #handleRenderedCell = (event: ChSmartGridCellCustomEvent<string>) => {\r\n    if (this.waitingForContent) {\r\n      this.#checkInitialRenderVisibility();\r\n    } else {\r\n      this.#checkCellsRenderedAtRuntime(event.detail);\r\n    }\r\n  };\r\n\r\n  #checkInitialRenderVisibility = () =>\r\n    this.#syncWithRAF.perform(() => {\r\n      const waitingForContent = !cellsInViewportAreLoadedAndVisible(\r\n        this.el,\r\n        this.#smartGrid,\r\n        this.inverseLoading\r\n      );\r\n\r\n      if (!waitingForContent) {\r\n        requestAnimationFrame(() => {\r\n          this.virtualScrollerDidLoad.emit();\r\n          this.waitingForContent = waitingForContent;\r\n        });\r\n      }\r\n    });\r\n\r\n  #checkCellsRenderedAtRuntime = (cellId: string) => {\r\n    // Delete virtual size, since the cell is now rendered\r\n    this.#virtualSizes.delete(cellId);\r\n\r\n    this.#updateVirtualScrollSize();\r\n\r\n    if (this.#waitingForCellsToBeRendered) {\r\n      this.#handleSmartGridContentScroll();\r\n    }\r\n  };\r\n\r\n  connectedCallback(): void {\r\n    // Listen for the render of the smart cells\r\n    this.el.addEventListener(\"smartCellDidLoad\", this.#handleRenderedCell);\r\n\r\n    this.#resetVirtualScrollerState();\r\n  }\r\n\r\n  componentDidLoad(): void {\r\n    this.#smartGrid = this.el.closest(\"ch-smart-grid\");\r\n    this.#setViewportItemsOnInitialRender(this.items);\r\n  }\r\n\r\n  disconnectedCallback(): void {\r\n    this.#resizeObserver?.disconnect();\r\n    this.#resizeObserver = undefined;\r\n\r\n    this.#syncWithRAF.cancel();\r\n    this.#syncWithRAF = undefined;\r\n\r\n    // Remove scroll events in the smart grid\r\n    this.#abortController.abort();\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <Host\r\n        class={{\r\n          \"ch-virtual-scroller--content-not-loaded\": this.waitingForContent,\r\n          \"ch-virtual-scroller--content-loaded\": !this.waitingForContent,\r\n          \"ch-virtual-scroller--virtual-scroll\":\r\n            !this.waitingForContent && this.mode === \"virtual-scroll\"\r\n        }}\r\n      >\r\n        <slot\r\n          onSlotchange={\r\n            this.waitingForContent\r\n              ? this.#checkInitialRenderVisibility\r\n              : undefined\r\n          }\r\n        ></slot>\r\n      </Host>\r\n    );\r\n  }\r\n}\r\n"],"mappings":"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"}