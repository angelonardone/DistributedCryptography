{"version":3,"names":["tabCss","ChTabRenderStyle0","TAB_BUTTON_CLASS","CLOSE_BUTTON_CLASS","TRANSITION_DURATION","BUTTON_POSITION_X","BUTTON_POSITION_Y","BUTTON_SIZE","MOUSE_OFFSET_X","MOUSE_OFFSET_Y","MOUSE_POSITION_X","MOUSE_POSITION_Y","TAB_LIST_EDGE_START_POSITION","TAB_LIST_EDGE_END_POSITION","FIRST_CAPTION_BUTTON","tabListRef","querySelector","LAST_CAPTION_BUTTON","setProperty","element","property","value","style","setButtonInitialPosition","positionX","positionY","setButtonSize","size","setMousePosition","setTabListStartEndPosition","startPosition","endPosition","getTabListSizesAndSetPosition","hostRef","blockDirection","buttonRect","tabListRect","getBoundingClientRect","tabListSizes","xStart","x","xEnd","width","yStart","y","yEnd","height","setMouseOffset","offsetX","offsetY","addGrabbingStyle","document","body","removeGrabbingStyle","removeProperty","getNextEnabledButtonCaption","currentBUttonCaption","nextElementSibling","getPreviousEnabledButtonCaption","previousElementSibling","focusNextOrPreviousCaption","focusNextSibling","focusedCaption","event","preventDefault","nextFocusedCaption","searchFunction","disabled","focus","click","GET_IMAGE_PATH_CALLBACK_REGISTRY","DEFAULT_GET_IMAGE_PATH_CALLBACK","imageSrc","base","ChTabRender","DEFAULT_TAB_LIST_POSITION","cancelId","selectedIndex","lastDragEvent","needForRAF","initialMousePosition","itemSizes","images","Map","mouseBoundingLimits","renderedPages","itemIdToIndex","dragPreviewRef","tabPageRef","keyEvents","KEY_CODES","ARROW_UP","ev","focusedButton","this","ARROW_RIGHT","isRTL","ARROW_DOWN","ARROW_LEFT","HOME","_","END","getImagePathCallbackChanged","computeImages","modelChanged","newModel","updateRenderedPages","selectedIdChanged","newSelectedId","newSelectedTabItem","model","find","item","id","set","expandMainGroup","itemClose","selectedItemChange","itemDragStart","endDragPreview","handleDragEnd","getDraggableViews","mainView","el","pageView","tabListView","promoteDragPreviewToTopLayer","draggedElementIndex","popover","showPopover","removePage","pageId","forceRerender","delete","forceUpdate","computeImage","undefined","getImagePathCallback","img","updateDirectionInImageCustomVar","clear","forEach","itemUIModel","itemImage","startImgSrc","buttonIsCloseButton","buttonRef","className","items","wasRendered","selectedId","handleDragStart","composedPath","tagName","toLowerCase","itemIndex","get","mousePositionX","clientX","mousePositionY","clientY","isBlockDirection","tabListPosition","getItemSize","children","map","target","buttonSizes","mouseDistanceToButtonTopEdge","mouseDistanceToButtonBottomEdge","mouseDistanceToButtonLeftEdge","mouseDistanceToButtonRightEdge","dragOutside","addEventListener","handleItemDrag","capture","passive","cancelAnimationFrame","removeEventListener","anItemWasReordered","hasCrossedBoundaries","draggedElementNewIndex","itemToInsert","removeElement","insertIntoIndex","adjustLastSelectedIndexValueAfterReorder","requestAnimationFrame","mouseLimits","draggedButtonIsInsideTheTabList","inBetween","emit","length","mousePosition","hasMovedToTheEnd","distanceTraveled","Math","abs","newIndex","preventMouseDownOnScroll","buttons","MouseEventButtons","WHEEL","handleSelectedItemChange","stopPropagation","emitCloseEvent","parentElement","itemId","eventInfo","lastSelectedIndex","newSelectedIndex","defaultPrevented","handleClose","button","MouseEventButton","hasCloseButton","closeButton","handleTabFocus","keyEventHandler","code","currentFocusedCaption","focusComposedPath","closest","getEnabledItems","itemsEnabled","imgRender","startImgType","h","class","part","TAB_PARTS_DICTIONARY","IMAGE","alt","src","loading","renderTabListPosition","position","startDirection","key","tokenMap","LIST_START","LIST_END","BLOCK","INLINE","START","name","renderTabList","thereAreShiftedElements","isStartDirection","enabledItems","atLeastOneItemsIsEnabled","role","accessibleName","LIST","onAuxClick","onClick","onDragStart","sortable","onKeyDown","onMouseDown","ref","index","renderTabButton","isDisabled","selected","startImage","startImageClasses","classes","isDecorativeImage","isPseudoElementImg","PANEL_ID","showCaptions","toString","TAB","CLOSABLE","NOT_CLOSABLE","SELECTED","NOT_SELECTED","DISABLED","styles","closeButtonAccessibleName","CLOSE_BUTTON","type","renderTabPages","expanded","PANEL_CONTAINER","values","renderTabPanel","contain","overflow","hasContain","hasOverflow","tabButtonHidden","panel","SCROLLABLE_CLASS","includes","PANEL","renderDragPreview","draggedElement","DRAG_PREVIEW","DRAG_PREVIEW_OUTSIDE","DRAG_PREVIEW_INSIDE_INLINE","DRAG_PREVIEW_INSIDE_BLOCK","DRAGGING","DRAGGING_OUT_OF_TAB_LIST","DRAGGING_OVER_TAB_LIST","initializeState","connectedCallback","adoptCommonThemes","shadowRoot","adoptedStyleSheets","getControlRegisterProperty","componentWillLoad","render","draggedIndex","thereAreShiftedElementsInPreview","Host","showTabListStart","showTabListEnd"],"sources":["src/components/tab/tab.scss?tag=ch-tab-render&encapsulation=shadow","src/components/tab/tab.tsx"],"sourcesContent":["@import \"../../common/base\";\r\n@import \"../../common/icons\";\r\n\r\n// - - - - - - - - - - - - - - - -\r\n//         Caption button\r\n// - - - - - - - - - - - - - - - -\r\n@include button-reset();\r\n\r\n@include box-sizing();\r\n\r\n$z-index-gx-navbar-item: 107; // Same as $z-index-gx-navbar-item from w-c-l\r\n\r\n:host {\r\n  --ch-tab-transition-duration: 150ms;\r\n\r\n  /**\r\n   * @prop --ch-tab-button__image-size:\r\n   * Specifies the box size that contains the start images of the tab buttons.\r\n   * @default #{$default-decorative-image-size}\r\n   */\r\n  --ch-tab-button__image-size: #{$default-decorative-image-size};\r\n\r\n  /**\r\n   * @prop --ch-tab-button__background-image-size:\r\n   * Specifies the size of the start images of the tab buttons.\r\n   * @default 100%\r\n   */\r\n  --ch-tab-button__background-image-size: 100%;\r\n\r\n  /**\r\n   * @prop --ch-tab-close-button__image-size:\r\n   * Specifies the box size that contains an image for the close button.\r\n   * @default #{$default-decorative-image-size}\r\n   */\r\n  --ch-tab-close-button__image-size: #{$default-decorative-image-size};\r\n\r\n  /**\r\n    * @prop --ch-tab-close-button__background-image-size:\r\n    * Specifies the image size of the close button.\r\n    * @default 100%\r\n    */\r\n  --ch-tab-close-button__background-image-size: 100%;\r\n\r\n  display: grid;\r\n}\r\n\r\n:host(.ch-tab--block-start) {\r\n  grid-template:\r\n    \"list-start list list-end\" max-content\r\n    \"panel-container panel-container panel-container\" 1fr / max-content 1fr max-content;\r\n}\r\n\r\n:host(.ch-tab--block-end) {\r\n  grid-template:\r\n    \"panel-container panel-container panel-container\" 1fr\r\n    \"list-start list list-end\" max-content / max-content 1fr max-content;\r\n}\r\n\r\n:host(.ch-tab--inline-start) {\r\n  grid-template:\r\n    \"list-start panel-container\" max-content\r\n    \"list panel-container\" 1fr\r\n    \"list-end panel-container\" max-content / max-content 1fr;\r\n}\r\n\r\n:host(.ch-tab--inline-end) {\r\n  grid-template:\r\n    \"panel-container list-start\" max-content\r\n    \"panel-container list\" 1fr\r\n    \"panel-container list-end\" max-content / 1fr max-content;\r\n}\r\n\r\n// - - - - - - - - - - - - - - - - - - - -\r\n//                Tab lists\r\n// - - - - - - - - - - - - - - - - - - - -\r\n.tab-list {\r\n  grid-area: list;\r\n  display: grid;\r\n\r\n  &-start {\r\n    grid-area: list-start;\r\n  }\r\n\r\n  &-end {\r\n    grid-area: list-end;\r\n  }\r\n\r\n  &-start,\r\n  &-end {\r\n    display: flex;\r\n    align-items: center;\r\n  }\r\n\r\n  &--inline {\r\n    grid-auto-flow: row;\r\n    grid-auto-rows: max-content;\r\n  }\r\n\r\n  &--block {\r\n    grid-auto-flow: column;\r\n    grid-auto-columns: max-content;\r\n  }\r\n}\r\n\r\n// - - - - - - - - - - - - - - - - - - - -\r\n//             Panel container\r\n// - - - - - - - - - - - - - - - - - - - -\r\n.panel-container {\r\n  grid-area: panel-container;\r\n  display: grid;\r\n  grid-template: \"selected\" 1fr / 1fr;\r\n}\r\n\r\n.panel {\r\n  display: grid;\r\n\r\n  &--selected {\r\n    grid-area: selected;\r\n  }\r\n}\r\n\r\n// content-visibility: hidden is faster for rendering the content back, as\r\n// it preserves the rendering state of the content (display: none does not)\r\n@supports (content-visibility: hidden) {\r\n  .panel-container--collapsed,\r\n  .panel--hidden {\r\n    content-visibility: hidden;\r\n  }\r\n\r\n  .panel-container--collapsed {\r\n    inline-size: 0;\r\n  }\r\n}\r\n\r\n@supports not (content-visibility: hidden) {\r\n  .panel-container--collapsed,\r\n  .panel--hidden {\r\n    display: none; // Destroys the render state. Ctrl + Z and Ctrl + C won't work properly\r\n  }\r\n}\r\n\r\n// - - - - - - - - - - - - - - - - - - - -\r\n//                   Tab\r\n// - - - - - - - - - - - - - - - - - - - -\r\n.tab {\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n\r\n  &:hover > .close-button::after,\r\n  &:focus-within > .close-button::after,\r\n  &[aria-selected=\"true\"] > .close-button::after {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n.no-captions {\r\n  justify-content: center;\r\n}\r\n\r\n.sortable {\r\n  // Allow user drag\r\n  -webkit-user-drag: element;\r\n}\r\n\r\n// - - - - - - - - - - - - - - - - - - - -\r\n//                 Images\r\n// - - - - - - - - - - - - - - - - - - - -\r\n.tab {\r\n  --ch-tab-button-start-img: var(--ch-start-img--base);\r\n\r\n  &.start-img--hover:hover {\r\n    --ch-tab-button-start-img: var(--ch-start-img--hover);\r\n  }\r\n\r\n  &.start-img--active:active {\r\n    --ch-tab-button-start-img: var(--ch-start-img--active);\r\n  }\r\n\r\n  &.start-img--focus:focus {\r\n    --ch-tab-button-start-img: var(--ch-start-img--focus);\r\n  }\r\n\r\n  &.start-img--selected.selected {\r\n    --ch-tab-button-start-img: var(--ch-start-img--selected);\r\n  }\r\n\r\n  &:disabled.start-img--disabled {\r\n    --ch-tab-button-start-img: var(--ch-start-img--disabled);\r\n  }\r\n}\r\n\r\n.caption-image,\r\n.pseudo-img--start::before {\r\n  display: block;\r\n  block-size: var(--ch-tab-button__image-size);\r\n  inline-size: var(--ch-tab-button__image-size);\r\n  min-inline-size: var(--ch-tab-button__image-size);\r\n}\r\n\r\n.pseudo-img--start::before {\r\n  content: \"\";\r\n  content-visibility: auto;\r\n  contain-intrinsic-size: auto var(--ch-tab-button__image-size);\r\n}\r\n\r\n// Background\r\n.start-img-type--background::before {\r\n  background: no-repeat center / var(--ch-tab-button__background-image-size)\r\n    var(--ch-tab-button-start-img);\r\n}\r\n\r\n// Mask\r\n.start-img-type--mask::before {\r\n  -webkit-mask: no-repeat center / var(--ch-tab-button__background-image-size)\r\n    var(--ch-tab-button-start-img);\r\n  background-color: currentColor;\r\n}\r\n\r\n.close-button {\r\n  &::after {\r\n    content: \"\";\r\n    display: flex;\r\n    block-size: var(--ch-tab-close-button__image-size);\r\n    inline-size: var(--ch-tab-close-button__image-size);\r\n    -webkit-mask: no-repeat center /\r\n      var(--ch-tab-close-button__background-image-size) #{$close-icon};\r\n    background-color: currentColor;\r\n    opacity: 0;\r\n  }\r\n}\r\n\r\n// - - - - - - - - - - - - - - - -\r\n//          Drag preview\r\n// - - - - - - - - - - - - - - - -\r\n// \"Hide\" the dragged element, without removing it from the accessibility tree\r\n.dragged-element {\r\n  opacity: 0;\r\n\r\n  &--outside {\r\n    display: none;\r\n  }\r\n}\r\n\r\n.drag-preview {\r\n  // \"clamp\" implements snap to the edges\r\n  --ch-tab-snap-drag-preview: clamp(\r\n    var(--ch-tab-list-start),\r\n    var(--ch-tab-mouse-position),\r\n    var(--ch-tab-list-end)\r\n  );\r\n\r\n  position: fixed;\r\n  left: 0; // Necessary since the custom vars are physical values\r\n  top: 0; // Necessary since the custom vars are physical values\r\n  z-index: $z-index-gx-navbar-item + 1;\r\n  cursor: grabbing;\r\n\r\n  &:popover-open {\r\n    // Reset popover's browser defaults\r\n    padding: 0;\r\n    margin: 0;\r\n    border: unset;\r\n    color: unset;\r\n\r\n    // Native popovers have \"inset: 0\", so we need to reset that property with\r\n    // the physical values again to support RTL\r\n    inset: unset;\r\n    left: 0;\r\n    top: 0;\r\n\r\n    // The preview MUST NOT capture pointer-events in order to properly show\r\n    // the droppable areas\r\n    pointer-events: none;\r\n  }\r\n\r\n  // Drag outside\r\n  &--outside-tab-list {\r\n    transform: translate(\r\n      calc(var(--ch-tab-mouse-position-x) - var(--ch-tab-mouse-offset-x)),\r\n      calc(var(--ch-tab-mouse-position-y) - var(--ch-tab-mouse-offset-y))\r\n    );\r\n  }\r\n\r\n  // Drag inside (block)\r\n  &--inside-tab-list__block {\r\n    --ch-tab-mouse-position: calc(\r\n      var(--ch-tab-mouse-position-x) - var(--ch-tab-mouse-offset-x)\r\n    );\r\n\r\n    transform: translate(\r\n      var(--ch-tab-snap-drag-preview),\r\n      var(--ch-tab-button-position-y)\r\n    );\r\n  }\r\n\r\n  // Drag inside (inline)\r\n  &--inside-tab-list__inline {\r\n    --ch-tab-mouse-position: calc(\r\n      var(--ch-tab-mouse-position-y) - var(--ch-tab-mouse-offset-y)\r\n    );\r\n\r\n    transform: translate(\r\n      var(--ch-tab-button-position-x),\r\n      var(--ch-tab-snap-drag-preview)\r\n    );\r\n  }\r\n}\r\n\r\n.shifted-element {\r\n  transition: transform var(--ch-tab-transition-duration);\r\n}\r\n\r\n:host(.ch-tab--block-start),\r\n:host(.ch-tab--block-end) {\r\n  .shifted-element--start {\r\n    transform: translate(calc(var(--ch-tab-button-size) * -1), 0);\r\n  }\r\n\r\n  .shifted-element--end {\r\n    transform: translate(var(--ch-tab-button-size), 0);\r\n  }\r\n}\r\n\r\n:host(.ch-tab--inline-start),\r\n:host(.ch-tab--inline-end) {\r\n  .shifted-element--start {\r\n    transform: translateY(calc(var(--ch-tab-button-size) * -1));\r\n  }\r\n\r\n  .shifted-element--end {\r\n    transform: translateY(var(--ch-tab-button-size));\r\n  }\r\n}\r\n","import {\r\n  Component,\r\n  Element,\r\n  Event,\r\n  EventEmitter,\r\n  Host,\r\n  Method,\r\n  Prop,\r\n  State,\r\n  Watch,\r\n  forceUpdate,\r\n  h\r\n} from \"@stencil/core\";\r\nimport {\r\n  DraggableView,\r\n  DraggableViewInfo\r\n} from \"../flexible-layout/internal/flexible-layout/types\";\r\nimport {\r\n  inBetween,\r\n  isPseudoElementImg,\r\n  isRTL,\r\n  tokenMap,\r\n  updateDirectionInImageCustomVar\r\n} from \"../../common/utils\";\r\nimport {\r\n  TabElementSize,\r\n  TabItemCloseInfo,\r\n  TabItemModel,\r\n  TabListPosition,\r\n  TabModel,\r\n  TabSelectedItemInfo\r\n} from \"./types\";\r\nimport {\r\n  DEFAULT_TAB_LIST_POSITION,\r\n  DRAG_PREVIEW,\r\n  DRAG_PREVIEW_INSIDE_BLOCK,\r\n  DRAG_PREVIEW_INSIDE_INLINE,\r\n  DRAG_PREVIEW_OUTSIDE,\r\n  isBlockDirection,\r\n  isStartDirection,\r\n  PANEL_ID\r\n} from \"./utils\";\r\nimport { insertIntoIndex, removeElement } from \"../../common/array\";\r\nimport {\r\n  focusComposedPath,\r\n  MouseEventButton,\r\n  MouseEventButtons\r\n} from \"../common/helpers\";\r\nimport type {\r\n  CssContainProperty,\r\n  CssOverflowProperty,\r\n  GxImageMultiState,\r\n  GxImageMultiStateStart\r\n} from \"../../common/types\";\r\nimport { getControlRegisterProperty } from \"../../common/registry-properties\";\r\nimport {\r\n  KEY_CODES,\r\n  SCROLLABLE_CLASS,\r\n  TAB_PARTS_DICTIONARY\r\n} from \"../../common/reserved-names\";\r\nimport { adoptCommonThemes } from \"../../common/theme\";\r\n\r\nconst TAB_BUTTON_CLASS = \"tab\";\r\nconst CLOSE_BUTTON_CLASS = \"close-button\";\r\n\r\n// Custom vars\r\nconst TRANSITION_DURATION = \"--ch-tab-transition-duration\";\r\n\r\nconst BUTTON_POSITION_X = \"--ch-tab-button-position-x\";\r\nconst BUTTON_POSITION_Y = \"--ch-tab-button-position-y\";\r\n\r\nconst BUTTON_SIZE = \"--ch-tab-button-size\";\r\n\r\nconst MOUSE_OFFSET_X = \"--ch-tab-mouse-offset-x\";\r\nconst MOUSE_OFFSET_Y = \"--ch-tab-mouse-offset-y\";\r\n\r\nconst MOUSE_POSITION_X = \"--ch-tab-mouse-position-x\";\r\nconst MOUSE_POSITION_Y = \"--ch-tab-mouse-position-y\";\r\n\r\nconst TAB_LIST_EDGE_START_POSITION = \"--ch-tab-list-start\";\r\nconst TAB_LIST_EDGE_END_POSITION = \"--ch-tab-list-end\";\r\n\r\ntype KeyEvents =\r\n  | typeof KEY_CODES.ARROW_UP\r\n  | typeof KEY_CODES.ARROW_RIGHT\r\n  | typeof KEY_CODES.ARROW_DOWN\r\n  | typeof KEY_CODES.ARROW_LEFT\r\n  | typeof KEY_CODES.HOME\r\n  | typeof KEY_CODES.END;\r\n\r\n// Selectors\r\nconst FIRST_CAPTION_BUTTON = (tabListRef: HTMLElement) =>\r\n  tabListRef.querySelector(\":scope>button\") as HTMLButtonElement;\r\n\r\nconst LAST_CAPTION_BUTTON = (tabListRef: HTMLElement) =>\r\n  tabListRef.querySelector(\":scope>button:last-child\") as HTMLButtonElement;\r\n\r\n// Utility functions\r\n\r\nconst setProperty = (element: HTMLElement, property: string, value: number) =>\r\n  element.style.setProperty(property, `${value}px`);\r\n\r\nconst setButtonInitialPosition = (\r\n  element: HTMLElement,\r\n  positionX: number,\r\n  positionY: number\r\n) => {\r\n  setProperty(element, BUTTON_POSITION_X, positionX);\r\n  setProperty(element, BUTTON_POSITION_Y, positionY);\r\n};\r\n\r\nconst setButtonSize = (element: HTMLElement, size: number) => {\r\n  setProperty(element, BUTTON_SIZE, size);\r\n};\r\n\r\nconst setMousePosition = (\r\n  element: HTMLElement,\r\n  positionX: number,\r\n  positionY: number\r\n) => {\r\n  setProperty(element, MOUSE_POSITION_X, positionX);\r\n  setProperty(element, MOUSE_POSITION_Y, positionY);\r\n};\r\n\r\n// Useful to implement snap to the edges\r\nconst setTabListStartEndPosition = (\r\n  element: HTMLElement,\r\n  startPosition: number,\r\n  endPosition: number\r\n) => {\r\n  setProperty(element, TAB_LIST_EDGE_START_POSITION, startPosition);\r\n  setProperty(element, TAB_LIST_EDGE_END_POSITION, endPosition);\r\n};\r\n\r\nconst getTabListSizesAndSetPosition = (\r\n  hostRef: HTMLChTabRenderElement,\r\n  tabListRef: HTMLElement,\r\n  blockDirection: boolean,\r\n  buttonRect: DOMRect\r\n): TabElementSize => {\r\n  const tabListRect = tabListRef.getBoundingClientRect();\r\n\r\n  // Tab List information\r\n  const tabListSizes: TabElementSize = {\r\n    xStart: tabListRect.x,\r\n    xEnd: tabListRect.x + tabListRect.width,\r\n    yStart: tabListRect.y,\r\n    yEnd: tabListRect.y + tabListRect.height\r\n  };\r\n\r\n  if (blockDirection) {\r\n    setTabListStartEndPosition(\r\n      hostRef,\r\n      tabListSizes.xStart,\r\n      tabListSizes.xEnd - buttonRect.width\r\n    );\r\n  } else {\r\n    setTabListStartEndPosition(\r\n      hostRef,\r\n      tabListSizes.yStart,\r\n      tabListSizes.yEnd - buttonRect.height\r\n    );\r\n  }\r\n\r\n  return tabListSizes;\r\n};\r\n\r\nconst setMouseOffset = (\r\n  element: HTMLElement,\r\n  offsetX: number,\r\n  offsetY: number\r\n) => {\r\n  setProperty(element, MOUSE_OFFSET_X, offsetX);\r\n  setProperty(element, MOUSE_OFFSET_Y, offsetY);\r\n};\r\n\r\nconst addGrabbingStyle = () =>\r\n  document.body.style.setProperty(\"cursor\", \"grabbing\");\r\nconst removeGrabbingStyle = () => document.body.style.removeProperty(\"cursor\");\r\n\r\nconst getNextEnabledButtonCaption = (\r\n  currentBUttonCaption: HTMLButtonElement,\r\n  tabListRef: HTMLElement\r\n) =>\r\n  (currentBUttonCaption.nextElementSibling ??\r\n    FIRST_CAPTION_BUTTON(tabListRef)) as HTMLButtonElement;\r\n\r\nconst getPreviousEnabledButtonCaption = (\r\n  currentBUttonCaption: HTMLButtonElement,\r\n  tabListRef: HTMLElement\r\n) =>\r\n  (currentBUttonCaption.previousElementSibling ??\r\n    LAST_CAPTION_BUTTON(tabListRef)) as HTMLButtonElement;\r\n\r\nconst focusNextOrPreviousCaption = (\r\n  focusNextSibling: boolean,\r\n  tabListRef: HTMLElement,\r\n  focusedCaption: HTMLButtonElement,\r\n  event: KeyboardEvent\r\n) => {\r\n  // Prevent scroll\r\n  event.preventDefault();\r\n\r\n  let nextFocusedCaption: HTMLButtonElement;\r\n\r\n  const searchFunction = focusNextSibling\r\n    ? getNextEnabledButtonCaption\r\n    : getPreviousEnabledButtonCaption;\r\n\r\n  // Determine the next selected caption button\r\n  nextFocusedCaption = searchFunction(focusedCaption, tabListRef);\r\n\r\n  while (nextFocusedCaption.disabled) {\r\n    nextFocusedCaption = searchFunction(nextFocusedCaption, tabListRef);\r\n  }\r\n\r\n  // Focus and select the caption\r\n  nextFocusedCaption.focus();\r\n  nextFocusedCaption.click();\r\n};\r\n\r\nlet GET_IMAGE_PATH_CALLBACK_REGISTRY: (\r\n  imageSrc: string\r\n) => GxImageMultiState | undefined;\r\n\r\nconst DEFAULT_GET_IMAGE_PATH_CALLBACK: (\r\n  imageSrc: string\r\n) => GxImageMultiState | undefined = imageSrc => ({ base: imageSrc });\r\n\r\n@Component({\r\n  shadow: true,\r\n  styleUrl: \"tab.scss\",\r\n  tag: \"ch-tab-render\"\r\n})\r\nexport class ChTabRender implements DraggableView {\r\n  #cancelId: number;\r\n\r\n  #selectedIndex: number = -1;\r\n\r\n  #lastDragEvent: MouseEvent;\r\n  #needForRAF = true; // To prevent redundant RAF (request animation frame) calls\r\n\r\n  #initialMousePosition = -1;\r\n\r\n  // Allocated at runtime to reduce memory usage\r\n  #itemSizes: number[];\r\n\r\n  // TODO: Allocate at runtime to reduce memory usage\r\n  #images: Map<string, GxImageMultiStateStart | undefined> = new Map();\r\n\r\n  /**\r\n   * This variable represents the boundaries of the box where the mouse can be\r\n   * placed when dragging a caption, to consider that the caption is within the\r\n   * tab list.\r\n   */\r\n  // eslint-disable-next-line @stencil-community/own-props-must-be-private\r\n  #mouseBoundingLimits: TabElementSize;\r\n\r\n  #renderedPages: Map<string, TabItemModel> = new Map();\r\n  #itemIdToIndex: Map<string, number> = new Map();\r\n\r\n  // Refs\r\n  #dragPreviewRef: HTMLButtonElement;\r\n  #tabListRef: HTMLDivElement;\r\n  #tabPageRef: HTMLDivElement;\r\n\r\n  // Keyboard interactions\r\n  #keyEvents: {\r\n    [key in KeyEvents]: (\r\n      blockDirection: boolean,\r\n      event: KeyboardEvent,\r\n      focusedCaption: HTMLButtonElement\r\n    ) => void;\r\n  } = {\r\n    [KEY_CODES.ARROW_UP]: (blockDirection, ev, focusedButton) => {\r\n      if (blockDirection) {\r\n        return;\r\n      }\r\n      focusNextOrPreviousCaption(false, this.#tabListRef, focusedButton, ev);\r\n    },\r\n\r\n    [KEY_CODES.ARROW_RIGHT]: (blockDirection, ev, focusedButton) => {\r\n      if (!blockDirection) {\r\n        return;\r\n      }\r\n      focusNextOrPreviousCaption(!isRTL(), this.#tabListRef, focusedButton, ev);\r\n    },\r\n\r\n    [KEY_CODES.ARROW_DOWN]: (blockDirection, ev, focusedButton) => {\r\n      if (blockDirection) {\r\n        return;\r\n      }\r\n      focusNextOrPreviousCaption(true, this.#tabListRef, focusedButton, ev);\r\n    },\r\n\r\n    [KEY_CODES.ARROW_LEFT]: (blockDirection, ev, focusedButton) => {\r\n      if (!blockDirection) {\r\n        return;\r\n      }\r\n      focusNextOrPreviousCaption(isRTL(), this.#tabListRef, focusedButton, ev);\r\n    },\r\n\r\n    [KEY_CODES.HOME]: (_, ev) =>\r\n      focusNextOrPreviousCaption(\r\n        true,\r\n        this.#tabListRef,\r\n        LAST_CAPTION_BUTTON(this.#tabListRef),\r\n        ev\r\n      ),\r\n\r\n    [KEY_CODES.END]: (_, ev) =>\r\n      focusNextOrPreviousCaption(\r\n        false,\r\n        this.#tabListRef,\r\n        FIRST_CAPTION_BUTTON(this.#tabListRef),\r\n        ev\r\n      )\r\n  };\r\n\r\n  @Element() el: HTMLChTabRenderElement;\r\n\r\n  @State() draggedElementIndex = -1;\r\n  @State() draggedElementNewIndex = -1;\r\n\r\n  /**\r\n   * `true` when the mouse position is out of bounds at least once.\r\n   */\r\n  @State() hasCrossedBoundaries = false;\r\n\r\n  /**\r\n   * Specifies a short string, typically 1 to 3 words, that authors associate\r\n   * with an element to provide users of assistive technologies with a label\r\n   * for the element.\r\n   */\r\n  @Prop() readonly accessibleName: string;\r\n\r\n  /**\r\n   * `true` to display a close button for the items.\r\n   */\r\n  @Prop() readonly closeButton: boolean = false;\r\n\r\n  /**\r\n   * Specifies a short string, typically 1 to 3 words, that authors associate\r\n   * with an element to provide users of assistive technologies with a label\r\n   * for the element. This label is used for the close button of the captions.\r\n   */\r\n  @Prop() readonly closeButtonAccessibleName: string = \"Close\";\r\n\r\n  /**\r\n   * Same as the contain CSS property. This property indicates that an item\r\n   * and its contents are, as much as possible, independent from the rest of\r\n   * the document tree. Containment enables isolating a subsection of the DOM,\r\n   * providing performance benefits by limiting calculations of layout, style,\r\n   * paint, size, or any combination to a DOM subtree rather than the entire\r\n   * page.\r\n   * Containment can also be used to scope CSS counters and quotes.\r\n   */\r\n  @Prop() readonly contain?: CssContainProperty = \"none\";\r\n\r\n  /**\r\n   * This attribute lets you specify if all tab buttons are disabled.\r\n   * If disabled, tab buttons will not fire any user interaction related event\r\n   * (for example, click event).\r\n   */\r\n  @Prop() readonly disabled: boolean = false;\r\n\r\n  /**\r\n   * When the control is sortable, the items can be dragged outside of the\r\n   * tab-list.\r\n   *\r\n   * This property lets you specify if this behavior is enabled.\r\n   */\r\n  @Prop() readonly dragOutside: boolean = false;\r\n\r\n  /**\r\n   * `true` if the group has is view section expanded. Otherwise, only the\r\n   * toolbar will be displayed.\r\n   */\r\n  // eslint-disable-next-line @stencil-community/ban-default-true\r\n  @Prop() readonly expanded: boolean = true;\r\n\r\n  /**\r\n   * This property specifies a callback that is executed when the path for an\r\n   * startImgSrc needs to be resolved.\r\n   */\r\n  @Prop() readonly getImagePathCallback?: (\r\n    imageSrc: string\r\n  ) => GxImageMultiState | undefined;\r\n  @Watch(\"getImagePathCallback\")\r\n  getImagePathCallbackChanged() {\r\n    this.#computeImages();\r\n  }\r\n\r\n  /**\r\n   * Specifies the items of the tab control.\r\n   */\r\n  @Prop() readonly model: TabModel;\r\n  @Watch(\"model\")\r\n  modelChanged(newModel: TabModel) {\r\n    this.#computeImages();\r\n    this.#updateRenderedPages(newModel);\r\n  }\r\n\r\n  /**\r\n   * Same as the overflow CSS property. This property sets the desired behavior\r\n   * when content does not fit in the item's padding box (overflows) in the\r\n   * horizontal and/or vertical direction.\r\n   */\r\n  @Prop() readonly overflow:\r\n    | CssOverflowProperty\r\n    | `${CssOverflowProperty} ${CssOverflowProperty}` = \"visible\";\r\n\r\n  /**\r\n   * Specifies the selected item of the widgets array.\r\n   */\r\n  @Prop({ mutable: true }) selectedId: string;\r\n  @Watch(\"selectedId\")\r\n  selectedIdChanged(newSelectedId: string) {\r\n    const newSelectedTabItem = this.model.find(\r\n      item => item.id === newSelectedId\r\n    );\r\n\r\n    if (newSelectedTabItem) {\r\n      this.#renderedPages.set(newSelectedId, newSelectedTabItem);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * `true` to show the captions of the items.\r\n   */\r\n  @Prop() readonly showCaptions: boolean = true;\r\n\r\n  /**\r\n   * `true` to render a slot named \"tab-list-end\" to project content at the\r\n   * end position of the tab-list (\"after\" the tab buttons).\r\n   */\r\n  @Prop() readonly showTabListEnd: boolean = false;\r\n\r\n  /**\r\n   * `true` to render a slot named \"tab-list-start\" to project content at the\r\n   * start position of the tab-list (\"before\" the tab buttons).\r\n   */\r\n  @Prop() readonly showTabListStart: boolean = false;\r\n\r\n  /**\r\n   * `true` to enable sorting the tab buttons by dragging them in the tab-list.\r\n   *\r\n   * If `false`, the tab buttons can not be dragged out either.\r\n   */\r\n  @Prop() readonly sortable: boolean = false;\r\n\r\n  /**\r\n   * `true` to not render the tab buttons of the control.\r\n   */\r\n  @Prop() readonly tabButtonHidden: boolean = false;\r\n\r\n  /**\r\n   * Specifies the position of the tab list of the `ch-tab-render`.\r\n   */\r\n  @Prop() readonly tabListPosition: TabListPosition = DEFAULT_TAB_LIST_POSITION;\r\n\r\n  /**\r\n   * Fired when an item of the main group is double clicked.\r\n   */\r\n  @Event() expandMainGroup: EventEmitter<string>;\r\n\r\n  /**\r\n   * Fired the close button of an item is clicked.\r\n   */\r\n  @Event() itemClose: EventEmitter<TabItemCloseInfo>;\r\n\r\n  /**\r\n   * Fired when the selected item change.\r\n   * This event can be default prevented to prevent the item selection.\r\n   */\r\n  @Event() selectedItemChange: EventEmitter<TabSelectedItemInfo>;\r\n\r\n  /**\r\n   * Fired the first time a caption button is dragged outside of its tab list.\r\n   */\r\n  @Event() itemDragStart: EventEmitter<number>;\r\n\r\n  /**\r\n   * Ends the preview of the dragged item. Useful for ending the preview via\r\n   * keyboard interaction.\r\n   */\r\n  @Method()\r\n  async endDragPreview(): Promise<void> {\r\n    this.#handleDragEnd();\r\n  }\r\n\r\n  /**\r\n   * Returns the info associated to the draggable view.\r\n   */\r\n  @Method()\r\n  async getDraggableViews(): Promise<DraggableViewInfo> {\r\n    return {\r\n      mainView: this.el,\r\n      pageView: this.#tabPageRef,\r\n      tabListView: this.#tabListRef\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Promotes the drag preview to the top layer. Useful to avoid z-index issues.\r\n   */\r\n  @Method()\r\n  async promoteDragPreviewToTopLayer(): Promise<void> {\r\n    if (this.draggedElementIndex === -1) {\r\n      return;\r\n    }\r\n\r\n    // If this property is added in a declarative way via the Stencil's render,\r\n    // we would have to use requestAnimationFrame to delay the shopPopover()\r\n    // method, since the popover defaults to \"auto\", which does not allow to\r\n    // keep multiple \"auto\" popover open at the same time\r\n    this.#dragPreviewRef.popover = \"manual\";\r\n\r\n    this.#dragPreviewRef.showPopover();\r\n  }\r\n\r\n  /**\r\n   * Given an id, remove the page from the render\r\n   */\r\n  @Method()\r\n  async removePage(pageId: string, forceRerender = true) {\r\n    this.#renderedPages.delete(pageId);\r\n\r\n    if (forceRerender) {\r\n      forceUpdate(this);\r\n    }\r\n  }\r\n\r\n  // TODO: This code is exactly the same as the ch-accordion-render. We should\r\n  // find the way to avoid this duplication\r\n  #computeImage = (\r\n    imageSrc: string | undefined\r\n  ): GxImageMultiStateStart | undefined => {\r\n    if (!imageSrc) {\r\n      return undefined;\r\n    }\r\n    const getImagePathCallback =\r\n      this.getImagePathCallback ?? GET_IMAGE_PATH_CALLBACK_REGISTRY;\r\n\r\n    if (!getImagePathCallback) {\r\n      return undefined;\r\n    }\r\n    const img = getImagePathCallback(imageSrc);\r\n\r\n    return img\r\n      ? (updateDirectionInImageCustomVar(\r\n          img,\r\n          \"start\"\r\n        ) as GxImageMultiStateStart)\r\n      : undefined;\r\n  };\r\n\r\n  #computeImages = () => {\r\n    this.#images.clear();\r\n\r\n    this.model?.forEach(itemUIModel => {\r\n      const itemImage = this.#computeImage(itemUIModel.startImgSrc);\r\n\r\n      if (itemImage) {\r\n        this.#images.set(itemUIModel.id, itemImage);\r\n      }\r\n    });\r\n  };\r\n\r\n  #buttonIsCloseButton = (buttonRef: HTMLButtonElement) =>\r\n    buttonRef.className === CLOSE_BUTTON_CLASS;\r\n\r\n  /**\r\n   * Make a set based on the rendered items array to maintain order between the\r\n   * pages, even when re-ordering tabs. This is useful for optimizing rendering\r\n   * performance by not re-ordering pages when the caption's order changes.\r\n   */\r\n  // eslint-disable-next-line @stencil-community/own-props-must-be-private\r\n  #updateRenderedPages = (items: TabModel) => {\r\n    this.#renderedPages.clear();\r\n    this.#itemIdToIndex.clear();\r\n\r\n    (items ?? []).forEach(item => {\r\n      if (item.wasRendered) {\r\n        this.#renderedPages.set(item.id, item);\r\n      }\r\n    });\r\n\r\n    // The selected id must be added to the rendered pages, even if it was not\r\n    // marked as \"wasRendered\" in the UI Model\r\n    if (this.selectedId && items !== undefined) {\r\n      const newSelectedTabItem = this.model.find(\r\n        item => item.id === this.selectedId\r\n      );\r\n\r\n      if (newSelectedTabItem) {\r\n        this.#renderedPages.set(this.selectedId, newSelectedTabItem);\r\n      }\r\n    }\r\n  };\r\n\r\n  // #handleItemDblClick = (event: MouseEvent) => {\r\n  //   event.preventDefault();\r\n  //   event.stopPropagation();\r\n\r\n  //   this.expandMainGroup.emit();\r\n  // };\r\n\r\n  #handleDragStart = (event: DragEvent) => {\r\n    const buttonRef = event.composedPath()[0] as HTMLButtonElement;\r\n\r\n    if (buttonRef.tagName.toLowerCase() !== \"button\") {\r\n      return;\r\n    }\r\n\r\n    // The only button that can perform dragstart is the tab button\r\n    const itemIndex = this.#itemIdToIndex.get(buttonRef.id);\r\n\r\n    // Remove dragover event to allow mousemove event to fire\r\n    event.preventDefault();\r\n\r\n    // Store the index of the dragged element\r\n    this.draggedElementIndex = itemIndex;\r\n\r\n    // - - - - - - - - - - - DOM read operations - - - - - - - - - - -\r\n    const mousePositionX = event.clientX;\r\n    const mousePositionY = event.clientY;\r\n    const blockDirection = isBlockDirection(this.tabListPosition);\r\n\r\n    const getItemSize = blockDirection\r\n      ? (item: HTMLElement) => item.getBoundingClientRect().width\r\n      : (item: HTMLElement) => item.getBoundingClientRect().height;\r\n    this.#itemSizes = [...this.#tabListRef.children].map(getItemSize);\r\n\r\n    const buttonRect = (\r\n      event.target as HTMLButtonElement\r\n    ).getBoundingClientRect();\r\n\r\n    // Tab List information\r\n    const tabListSizes = getTabListSizesAndSetPosition(\r\n      this.el,\r\n      this.#tabListRef,\r\n      blockDirection,\r\n      buttonRect\r\n    );\r\n\r\n    // Button information\r\n    const buttonSizes: TabElementSize = {\r\n      xStart: buttonRect.x,\r\n      xEnd: buttonRect.x + buttonRect.width,\r\n      yStart: buttonRect.y,\r\n      yEnd: buttonRect.y + buttonRect.height\r\n    };\r\n\r\n    const mouseDistanceToButtonTopEdge = mousePositionY - buttonSizes.yStart;\r\n    const mouseDistanceToButtonBottomEdge = buttonSizes.yEnd - mousePositionY;\r\n    const mouseDistanceToButtonLeftEdge = mousePositionX - buttonSizes.xStart;\r\n    const mouseDistanceToButtonRightEdge = buttonSizes.xEnd - mousePositionX;\r\n\r\n    // Update mouse limits if drag outside is enabled\r\n    if (this.dragOutside) {\r\n      this.#mouseBoundingLimits = {\r\n        xStart: tabListSizes.xStart - mouseDistanceToButtonRightEdge,\r\n        xEnd: tabListSizes.xEnd + mouseDistanceToButtonLeftEdge,\r\n        yStart: tabListSizes.yStart - mouseDistanceToButtonBottomEdge,\r\n        yEnd: tabListSizes.yEnd + mouseDistanceToButtonTopEdge\r\n      };\r\n    }\r\n\r\n    // Store initial mouse position\r\n    this.#initialMousePosition = blockDirection\r\n      ? mousePositionX\r\n      : mousePositionY;\r\n\r\n    // - - - - - - - - - - - DOM write operations - - - - - - - - - - -\r\n    // Initialize mouse position to avoid initial flickering\r\n    setMousePosition(this.el, mousePositionX, mousePositionY);\r\n\r\n    // Initialize the button position\r\n    setButtonInitialPosition(this.el, buttonSizes.xStart, buttonSizes.yStart);\r\n\r\n    setButtonSize(\r\n      this.el,\r\n      blockDirection ? buttonRect.width : buttonRect.height\r\n    );\r\n\r\n    // Update mouse offset to correctly place the dragged element preview\r\n    setMouseOffset(\r\n      this.el,\r\n      mouseDistanceToButtonLeftEdge,\r\n      mouseDistanceToButtonTopEdge\r\n    );\r\n\r\n    addGrabbingStyle();\r\n\r\n    // Add listeners\r\n    document.addEventListener(\"mousemove\", this.#handleItemDrag, {\r\n      capture: true,\r\n      passive: true\r\n    });\r\n\r\n    document.addEventListener(\"mouseup\", this.#handleDragEnd, {\r\n      capture: true\r\n    });\r\n  };\r\n\r\n  #handleDragEnd = () => {\r\n    // Since mousemove callbacks are executed on animation frames, we must also\r\n    // remove the events on animations frame. Otherwise we would remove the\r\n    // events and in the next frame the mousemove handler will be executes\r\n    cancelAnimationFrame(this.#cancelId);\r\n    this.#needForRAF = true;\r\n\r\n    document.removeEventListener(\"mousemove\", this.#handleItemDrag, {\r\n      capture: true\r\n    });\r\n\r\n    document.removeEventListener(\"mouseup\", this.#handleDragEnd, {\r\n      capture: true\r\n    });\r\n\r\n    removeGrabbingStyle();\r\n\r\n    const anItemWasReordered =\r\n      !this.hasCrossedBoundaries &&\r\n      this.draggedElementNewIndex !== this.draggedElementIndex;\r\n\r\n    // Move the item to the new position\r\n    if (anItemWasReordered) {\r\n      const itemToInsert = removeElement(this.model, this.draggedElementIndex);\r\n      insertIntoIndex(this.model, itemToInsert, this.draggedElementNewIndex);\r\n\r\n      // Update last selected index\r\n      this.#adjustLastSelectedIndexValueAfterReorder();\r\n    }\r\n\r\n    // Restore visibility of the dragged element\r\n    this.draggedElementIndex = -1;\r\n    this.draggedElementNewIndex = -1;\r\n\r\n    // Free the memory\r\n    this.#itemSizes = undefined;\r\n\r\n    // Reset state\r\n    this.hasCrossedBoundaries = false;\r\n    this.el.style.removeProperty(TRANSITION_DURATION);\r\n  };\r\n\r\n  #adjustLastSelectedIndexValueAfterReorder = () => {\r\n    // If the dragged element is the selected element, use the new index\r\n    if (this.#selectedIndex === this.draggedElementIndex) {\r\n      this.#selectedIndex = this.draggedElementNewIndex;\r\n    }\r\n    // Dragged element:\r\n    //   - Started: Before the selected index\r\n    //   - Ended: After the selected index or in the same position\r\n    else if (\r\n      this.draggedElementIndex < this.#selectedIndex &&\r\n      this.#selectedIndex <= this.draggedElementNewIndex\r\n    ) {\r\n      this.#selectedIndex--;\r\n    }\r\n    // Dragged element:\r\n    //   - Started: After the selected index\r\n    //   - Ended: Before the selected index or in the same position\r\n    else if (\r\n      this.#selectedIndex < this.draggedElementIndex &&\r\n      this.draggedElementNewIndex <= this.#selectedIndex\r\n    ) {\r\n      this.#selectedIndex++;\r\n    }\r\n  };\r\n\r\n  #handleItemDrag = (event: MouseEvent) => {\r\n    this.#lastDragEvent = event;\r\n\r\n    if (!this.#needForRAF) {\r\n      return;\r\n    }\r\n    this.#needForRAF = false; // No need to call RAF up until next frame\r\n\r\n    this.#cancelId = requestAnimationFrame(() => {\r\n      this.#needForRAF = true; // RAF now consumes the movement instruction so a new one can come\r\n\r\n      const mousePositionX = this.#lastDragEvent.clientX;\r\n      const mousePositionY = this.#lastDragEvent.clientY;\r\n\r\n      setMousePosition(this.el, mousePositionX, mousePositionY);\r\n\r\n      // There is no need to update the preview of the reorder\r\n      if (this.hasCrossedBoundaries) {\r\n        return;\r\n      }\r\n\r\n      const mouseLimits = this.#mouseBoundingLimits;\r\n\r\n      // Check mouse limits if drag outside is enabled\r\n      if (this.dragOutside) {\r\n        const draggedButtonIsInsideTheTabList =\r\n          inBetween(mouseLimits.xStart, mousePositionX, mouseLimits.xEnd) &&\r\n          inBetween(mouseLimits.yStart, mousePositionY, mouseLimits.yEnd);\r\n\r\n        // Emit the itemDragStart event the first time the button is out of the\r\n        // mouse bounds (`mouseBoundingLimits`)\r\n        if (!draggedButtonIsInsideTheTabList) {\r\n          this.hasCrossedBoundaries = true;\r\n\r\n          // Remove transition before the render to avoid flickering in the animation\r\n          this.el.style.setProperty(TRANSITION_DURATION, \"0s\");\r\n\r\n          this.itemDragStart.emit(this.draggedElementIndex);\r\n          return;\r\n        }\r\n      }\r\n\r\n      // There is no need to re-order the items in the preview\r\n      if (this.model.length === 1) {\r\n        return;\r\n      }\r\n\r\n      // In this point, the preview is inside the tab list, we should check\r\n      // in which place is the preview to give feedback for the item's reorder\r\n      const mousePosition = isBlockDirection(this.tabListPosition)\r\n        ? mousePositionX\r\n        : mousePositionY;\r\n\r\n      const hasMovedToTheEnd = this.#initialMousePosition < mousePosition;\r\n\r\n      // Distance traveled from the initial mouse position\r\n      let distanceTraveled = Math.abs(\r\n        this.#initialMousePosition - mousePosition\r\n      );\r\n\r\n      let newIndex = this.draggedElementIndex;\r\n\r\n      if (hasMovedToTheEnd) {\r\n        // While it is not the last item and the distance traveled is greater\r\n        // than half the size of the next item\r\n        while (\r\n          newIndex < this.model.length - 1 &&\r\n          distanceTraveled - this.#itemSizes[newIndex + 1] / 2 > 0\r\n        ) {\r\n          distanceTraveled -= this.#itemSizes[newIndex + 1];\r\n          newIndex++;\r\n        }\r\n      } else {\r\n        // While it is not the first item and the distance traveled is greater\r\n        // than half the size of the previous item\r\n        while (\r\n          newIndex > 0 &&\r\n          distanceTraveled - this.#itemSizes[newIndex - 1] / 2 > 0\r\n        ) {\r\n          distanceTraveled -= this.#itemSizes[newIndex - 1];\r\n          newIndex--;\r\n        }\r\n      }\r\n\r\n      // Check if should update the dragged element index in the preview\r\n      if (this.draggedElementNewIndex !== newIndex) {\r\n        this.draggedElementNewIndex = newIndex;\r\n      }\r\n    });\r\n  };\r\n\r\n  #preventMouseDownOnScroll = (event: MouseEvent) => {\r\n    // We have to prevent the mousedown event to make work the close with the\r\n    // mouse wheel, because when the page has scroll, the auxClick is not fired\r\n    if (event.buttons !== MouseEventButtons.WHEEL) {\r\n      return;\r\n    }\r\n    const buttonRef = event.composedPath()[0] as HTMLButtonElement;\r\n\r\n    if (buttonRef.tagName.toLowerCase() !== \"button\") {\r\n      return;\r\n    }\r\n    event.preventDefault();\r\n  };\r\n\r\n  #handleSelectedItemChange = (event: PointerEvent) => {\r\n    event.stopPropagation();\r\n    const buttonRef = event.composedPath()[0] as HTMLButtonElement;\r\n\r\n    // Check the click event is performed on a button element\r\n    if (buttonRef.tagName.toLowerCase() !== \"button\") {\r\n      return;\r\n    }\r\n\r\n    // Click was performed on the close button --> itemClose event\r\n    if (this.#buttonIsCloseButton(buttonRef)) {\r\n      // The parent is the tab button with the itemId\r\n      this.#emitCloseEvent(buttonRef.parentElement.id, event);\r\n    }\r\n    // Otherwise --> selectedItemChange event\r\n    else {\r\n      const itemId = buttonRef.id;\r\n\r\n      // Don't fire the selectedItemChange event if the item is already selected\r\n      if (this.selectedId === itemId) {\r\n        return;\r\n      }\r\n      const itemIndex = this.#itemIdToIndex.get(itemId)!;\r\n\r\n      const eventInfo = this.selectedItemChange.emit({\r\n        lastSelectedIndex: this.#selectedIndex,\r\n        newSelectedId: itemId,\r\n        newSelectedIndex: itemIndex\r\n      });\r\n\r\n      if (!eventInfo.defaultPrevented) {\r\n        this.#selectedIndex = itemIndex;\r\n        this.selectedId = itemId;\r\n      }\r\n    }\r\n  };\r\n\r\n  #handleClose = (event: PointerEvent) => {\r\n    // Check if the action was performed on the close button or the action\r\n    // was a click on the wheel\r\n    if (event.button !== MouseEventButton.WHEEL) {\r\n      return;\r\n    }\r\n    const buttonRef = event.composedPath()[0] as HTMLButtonElement;\r\n\r\n    if (buttonRef.tagName.toLowerCase() === \"button\") {\r\n      const itemId = this.#buttonIsCloseButton(buttonRef)\r\n        ? buttonRef.parentElement.id\r\n        : buttonRef.id;\r\n      this.#emitCloseEvent(itemId, event);\r\n    }\r\n  };\r\n\r\n  #emitCloseEvent = (itemId: string, event: PointerEvent) => {\r\n    // Assume that the itemId always maps to an item\r\n    const itemUIModel = this.model.find(({ id }) => id === itemId)!;\r\n    const hasCloseButton = itemUIModel.closeButton ?? this.closeButton;\r\n\r\n    if (!hasCloseButton) {\r\n      return;\r\n    }\r\n\r\n    event.preventDefault();\r\n    event.stopPropagation();\r\n\r\n    const itemIndex = this.#itemIdToIndex.get(itemId)!;\r\n\r\n    this.itemClose.emit({\r\n      itemIndex: itemIndex,\r\n      itemId: itemId\r\n    });\r\n  };\r\n\r\n  #handleTabFocus = (event: KeyboardEvent) => {\r\n    const keyEventHandler = this.#keyEvents[event.code];\r\n    if (!keyEventHandler) {\r\n      return;\r\n    }\r\n\r\n    const currentFocusedCaption = focusComposedPath()[0].closest(\r\n      \".\" + TAB_BUTTON_CLASS\r\n    ) as HTMLButtonElement;\r\n\r\n    keyEventHandler(\r\n      isBlockDirection(this.tabListPosition),\r\n      event,\r\n      currentFocusedCaption\r\n    );\r\n  };\r\n\r\n  #getEnabledItems = (): number => {\r\n    let itemsEnabled = 0;\r\n    let itemIndex = 0;\r\n\r\n    while (itemsEnabled < 2 && itemIndex < this.model.length) {\r\n      const itemUIModel = this.model[itemIndex];\r\n\r\n      if (\r\n        itemUIModel.disabled === false ||\r\n        (!this.disabled && itemUIModel.disabled !== true)\r\n      ) {\r\n        itemsEnabled++;\r\n      }\r\n\r\n      itemIndex++;\r\n    }\r\n\r\n    return itemsEnabled;\r\n  };\r\n\r\n  #imgRender = (item: TabItemModel) =>\r\n    item.startImgType === \"img\" &&\r\n    item.startImgSrc && (\r\n      <img\r\n        aria-hidden=\"true\"\r\n        class=\"caption-image img\"\r\n        part={TAB_PARTS_DICTIONARY.IMAGE}\r\n        alt=\"\"\r\n        src={item.startImgSrc}\r\n        loading=\"lazy\"\r\n      />\r\n    );\r\n\r\n  #renderTabListPosition = (\r\n    position: \"start\" | \"end\",\r\n    blockDirection: boolean,\r\n    startDirection: boolean\r\n  ) => {\r\n    const tabListPosition = `tab-list-${position}` as const;\r\n\r\n    return (\r\n      <div\r\n        key={tabListPosition}\r\n        class={tabListPosition}\r\n        part={tokenMap({\r\n          [TAB_PARTS_DICTIONARY.LIST_START]: position === \"start\",\r\n          [TAB_PARTS_DICTIONARY.LIST_END]: position === \"end\",\r\n          [this.tabListPosition]: true,\r\n          [TAB_PARTS_DICTIONARY.BLOCK]: blockDirection,\r\n          [TAB_PARTS_DICTIONARY.INLINE]: !blockDirection,\r\n          [TAB_PARTS_DICTIONARY.START]: startDirection,\r\n          [TAB_PARTS_DICTIONARY.END]: !startDirection\r\n        })}\r\n      >\r\n        <slot name={tabListPosition} />\r\n      </div>\r\n    );\r\n  };\r\n\r\n  #renderTabList = (thereAreShiftedElements: boolean) => {\r\n    const blockDirection = isBlockDirection(this.tabListPosition);\r\n    const startDirection = isStartDirection(this.tabListPosition);\r\n    const enabledItems = this.#getEnabledItems();\r\n    const atLeastOneItemsIsEnabled = enabledItems >= 1;\r\n\r\n    return (\r\n      <div\r\n        role=\"tablist\"\r\n        aria-label={this.accessibleName}\r\n        class={{\r\n          \"tab-list\": true,\r\n          \"tab-list--block\": blockDirection,\r\n          \"tab-list--inline\": !blockDirection\r\n        }}\r\n        // TODO: Add \"DRAGGING\" parts\r\n        part={tokenMap({\r\n          [TAB_PARTS_DICTIONARY.LIST]: true,\r\n          [this.tabListPosition]: true,\r\n          [TAB_PARTS_DICTIONARY.BLOCK]: blockDirection,\r\n          [TAB_PARTS_DICTIONARY.INLINE]: !blockDirection,\r\n          [TAB_PARTS_DICTIONARY.START]: startDirection,\r\n          [TAB_PARTS_DICTIONARY.END]: !startDirection\r\n        })}\r\n        // TODO: Don't add this handler if there is no items with closeButton\r\n        onAuxClick={atLeastOneItemsIsEnabled ? this.#handleClose : undefined}\r\n        onClick={\r\n          atLeastOneItemsIsEnabled ? this.#handleSelectedItemChange : undefined\r\n        }\r\n        // TODO: Add support to drag the item when it is disabled.\r\n        // TODO: Add support to position the item in different areas\r\n        onDragStart={\r\n          this.sortable && atLeastOneItemsIsEnabled\r\n            ? this.#handleDragStart\r\n            : undefined\r\n        }\r\n        onKeyDown={\r\n          this.model.length >= 2 && enabledItems >= 2\r\n            ? this.#handleTabFocus\r\n            : undefined\r\n        }\r\n        // TODO: Don't add this handler if there is no items with closeButton\r\n        onMouseDown={\r\n          atLeastOneItemsIsEnabled ? this.#preventMouseDownOnScroll : undefined\r\n        }\r\n        ref={el => (this.#tabListRef = el)}\r\n      >\r\n        {this.model.map((item, index) =>\r\n          this.#renderTabButton(\r\n            item,\r\n            index,\r\n            thereAreShiftedElements,\r\n            blockDirection,\r\n            startDirection\r\n          )\r\n        )}\r\n      </div>\r\n    );\r\n  };\r\n\r\n  #renderTabButton = (\r\n    item: TabItemModel,\r\n    index: number,\r\n    thereAreShiftedElements: boolean,\r\n    blockDirection: boolean,\r\n    startDirection: boolean\r\n  ) => {\r\n    const closeButton = item.closeButton ?? this.closeButton;\r\n    const isDisabled = item.disabled ?? this.disabled;\r\n    const selected = item.id === this.selectedId;\r\n    this.#itemIdToIndex.set(item.id, index);\r\n\r\n    const startImage = this.#images.get(item.id);\r\n    const startImageClasses = startImage?.classes;\r\n    const isDecorativeImage =\r\n      isPseudoElementImg(item.startImgSrc, item.startImgType) && !!startImage;\r\n\r\n    return (\r\n      <button\r\n        key={item.id}\r\n        id={item.id}\r\n        role=\"tab\"\r\n        aria-controls={PANEL_ID(item.id)}\r\n        aria-label={\r\n          item.accessibleName ?? (!this.showCaptions ? item.name : null)\r\n        }\r\n        aria-selected={selected.toString()}\r\n        class={{\r\n          [TAB_BUTTON_CLASS]: true,\r\n          \"no-captions\": !this.showCaptions,\r\n\r\n          sortable: this.sortable,\r\n          selected: selected,\r\n\r\n          [`start-img-type--${\r\n            item.startImgType ?? \"background\"\r\n          } pseudo-img--start`]: isDecorativeImage,\r\n          [startImageClasses]: isDecorativeImage && !!startImageClasses,\r\n\r\n          \"dragged-element\": this.draggedElementIndex === index,\r\n          \"dragged-element--outside\":\r\n            this.draggedElementIndex === index &&\r\n            this.hasCrossedBoundaries &&\r\n            this.model.length > 1,\r\n          \"shifted-element\": this.draggedElementIndex !== -1,\r\n\r\n          \"shifted-element--start\":\r\n            thereAreShiftedElements &&\r\n            this.draggedElementIndex < index &&\r\n            index <= this.draggedElementNewIndex,\r\n\r\n          \"shifted-element--end\":\r\n            thereAreShiftedElements &&\r\n            this.draggedElementNewIndex <= index &&\r\n            index < this.draggedElementIndex\r\n        }}\r\n        part={tokenMap({\r\n          [item.id]: true,\r\n          [TAB_PARTS_DICTIONARY.TAB]: true,\r\n          [this.tabListPosition]: true,\r\n          [TAB_PARTS_DICTIONARY.BLOCK]: blockDirection,\r\n          [TAB_PARTS_DICTIONARY.INLINE]: !blockDirection,\r\n          [TAB_PARTS_DICTIONARY.START]: startDirection,\r\n          [TAB_PARTS_DICTIONARY.END]: !startDirection,\r\n          [TAB_PARTS_DICTIONARY.CLOSABLE]: closeButton,\r\n          [TAB_PARTS_DICTIONARY.NOT_CLOSABLE]: !closeButton,\r\n          [TAB_PARTS_DICTIONARY.SELECTED]: selected,\r\n          [TAB_PARTS_DICTIONARY.NOT_SELECTED]: !selected,\r\n          [TAB_PARTS_DICTIONARY.DISABLED]: isDisabled\r\n        })}\r\n        disabled={isDisabled}\r\n        style={isDecorativeImage ? startImage.styles : undefined}\r\n        // onDblClick={\r\n        //   this.direction === \"main\" ? this.#handleItemDblClick : null\r\n        // }\r\n      >\r\n        {this.#imgRender(item)}\r\n\r\n        {this.showCaptions && item.name}\r\n\r\n        {closeButton && (\r\n          <button\r\n            aria-label={this.closeButtonAccessibleName}\r\n            class={CLOSE_BUTTON_CLASS}\r\n            part={tokenMap({\r\n              [TAB_PARTS_DICTIONARY.CLOSE_BUTTON]: true,\r\n              [this.tabListPosition]: true,\r\n              [TAB_PARTS_DICTIONARY.BLOCK]: blockDirection,\r\n              [TAB_PARTS_DICTIONARY.INLINE]: !blockDirection,\r\n              [TAB_PARTS_DICTIONARY.START]: startDirection,\r\n              [TAB_PARTS_DICTIONARY.END]: !startDirection,\r\n              [TAB_PARTS_DICTIONARY.SELECTED]: selected,\r\n              [TAB_PARTS_DICTIONARY.NOT_SELECTED]: !selected,\r\n              [TAB_PARTS_DICTIONARY.DISABLED]: isDisabled\r\n            })}\r\n            disabled={isDisabled}\r\n            type=\"button\"\r\n          ></button>\r\n        )}\r\n      </button>\r\n    );\r\n  };\r\n\r\n  #renderTabPages = (blockDirection: boolean, startDirection: boolean) => (\r\n    <div\r\n      class={{\r\n        \"panel-container\": true,\r\n        \"panel-container--collapsed\": !this.expanded\r\n      }}\r\n      part={tokenMap({\r\n        [TAB_PARTS_DICTIONARY.PANEL_CONTAINER]: true,\r\n        [this.tabListPosition]: true,\r\n        [TAB_PARTS_DICTIONARY.BLOCK]: blockDirection,\r\n        [TAB_PARTS_DICTIONARY.INLINE]: !blockDirection,\r\n        [TAB_PARTS_DICTIONARY.START]: startDirection,\r\n        [TAB_PARTS_DICTIONARY.END]: !startDirection\r\n      })}\r\n      ref={el => (this.#tabPageRef = el)}\r\n    >\r\n      {[...this.#renderedPages.values()].map(this.#renderTabPanel)}\r\n    </div>\r\n  );\r\n\r\n  #renderTabPanel = (item: TabItemModel) => {\r\n    // TODO: Avoid this check as much as possible\r\n    const blockDirection = isBlockDirection(this.tabListPosition);\r\n    const startDirection = isStartDirection(this.tabListPosition);\r\n\r\n    const contain = item.contain ?? this.contain;\r\n    const isDisabled = item.disabled ?? this.disabled;\r\n    const overflow = item.overflow ?? this.overflow;\r\n    const selected = item.id === this.selectedId;\r\n\r\n    const hasContain = contain !== \"none\";\r\n    const hasOverflow =\r\n      overflow !== \"visible\" && overflow !== \"visible visible\";\r\n\r\n    return (\r\n      <div\r\n        key={PANEL_ID(item.id)}\r\n        id={PANEL_ID(item.id)}\r\n        role={!this.tabButtonHidden ? \"tabpanel\" : undefined}\r\n        aria-labelledby={!this.tabButtonHidden ? item.id : undefined}\r\n        class={{\r\n          panel: true,\r\n          \"panel--selected\": item.id === this.selectedId,\r\n          \"panel--hidden\": !(item.id === this.selectedId),\r\n          [SCROLLABLE_CLASS]:\r\n            hasOverflow &&\r\n            (overflow.includes(\"auto\" satisfies CssOverflowProperty) ||\r\n              overflow.includes(\"scroll\" satisfies CssOverflowProperty))\r\n        }}\r\n        style={\r\n          hasContain || hasOverflow\r\n            ? {\r\n                contain: hasContain ? contain : undefined,\r\n                overflow: hasOverflow ? overflow : undefined\r\n              }\r\n            : undefined\r\n        }\r\n        part={tokenMap({\r\n          [item.id]: true,\r\n          [TAB_PARTS_DICTIONARY.PANEL]: true,\r\n          [this.tabListPosition]: true,\r\n          [TAB_PARTS_DICTIONARY.BLOCK]: blockDirection,\r\n          [TAB_PARTS_DICTIONARY.INLINE]: !blockDirection,\r\n          [TAB_PARTS_DICTIONARY.START]: startDirection,\r\n          [TAB_PARTS_DICTIONARY.END]: !startDirection,\r\n          [TAB_PARTS_DICTIONARY.SELECTED]: selected,\r\n          [TAB_PARTS_DICTIONARY.NOT_SELECTED]: !selected,\r\n          [TAB_PARTS_DICTIONARY.DISABLED]: isDisabled\r\n        })}\r\n      >\r\n        <slot name={item.id} />\r\n      </div>\r\n    );\r\n  };\r\n\r\n  #renderDragPreview = (draggedElement: TabItemModel) => {\r\n    const blockDirection = isBlockDirection(this.tabListPosition);\r\n    const startDirection = isStartDirection(this.tabListPosition);\r\n    const selected = draggedElement.id === this.selectedId;\r\n\r\n    const startImage = this.#images.get(draggedElement.id);\r\n    const startImageClasses = startImage?.classes;\r\n    const isDecorativeImage =\r\n      isPseudoElementImg(\r\n        draggedElement.startImgSrc,\r\n        draggedElement.startImgType\r\n      ) && !!startImage;\r\n\r\n    const closeButton = draggedElement.closeButton ?? this.closeButton;\r\n\r\n    return (\r\n      <button\r\n        // TODO: Check if this is necessary\r\n        // aria-hidden=\"true\"\r\n        class={{\r\n          [TAB_BUTTON_CLASS]: true,\r\n          [DRAG_PREVIEW]: true,\r\n          \"no-captions\": !this.showCaptions,\r\n\r\n          selected: selected,\r\n\r\n          [`start-img-type--${\r\n            draggedElement.startImgType ?? \"background\"\r\n          } pseudo-img--start`]: isDecorativeImage,\r\n          [startImageClasses]: isDecorativeImage && !!startImageClasses,\r\n\r\n          [DRAG_PREVIEW_OUTSIDE]: this.hasCrossedBoundaries,\r\n          [DRAG_PREVIEW_INSIDE_INLINE]:\r\n            !this.hasCrossedBoundaries && !blockDirection,\r\n          [DRAG_PREVIEW_INSIDE_BLOCK]:\r\n            !this.hasCrossedBoundaries && blockDirection\r\n        }}\r\n        part={tokenMap({\r\n          [draggedElement.id]: true,\r\n          [TAB_PARTS_DICTIONARY.TAB]: true,\r\n          [TAB_PARTS_DICTIONARY.DRAGGING]: true,\r\n          [this.tabListPosition]: true,\r\n          [TAB_PARTS_DICTIONARY.BLOCK]: blockDirection,\r\n          [TAB_PARTS_DICTIONARY.INLINE]: !blockDirection,\r\n          [TAB_PARTS_DICTIONARY.START]: startDirection,\r\n          [TAB_PARTS_DICTIONARY.END]: !startDirection,\r\n          [TAB_PARTS_DICTIONARY.DRAGGING_OUT_OF_TAB_LIST]:\r\n            this.hasCrossedBoundaries,\r\n          [TAB_PARTS_DICTIONARY.DRAGGING_OVER_TAB_LIST]:\r\n            !this.hasCrossedBoundaries,\r\n          [TAB_PARTS_DICTIONARY.CLOSABLE]: closeButton,\r\n          [TAB_PARTS_DICTIONARY.NOT_CLOSABLE]: !closeButton,\r\n          [TAB_PARTS_DICTIONARY.SELECTED]: selected,\r\n          [TAB_PARTS_DICTIONARY.NOT_SELECTED]: !selected\r\n        })}\r\n        style={isDecorativeImage ? startImage.styles : undefined}\r\n        ref={el => (this.#dragPreviewRef = el)}\r\n      >\r\n        {this.#imgRender(draggedElement)}\r\n\r\n        {this.showCaptions && draggedElement.name}\r\n      </button>\r\n    );\r\n  };\r\n\r\n  #initializeState = () => {\r\n    this.#updateRenderedPages(this.model);\r\n  };\r\n\r\n  connectedCallback() {\r\n    adoptCommonThemes(this.el.shadowRoot.adoptedStyleSheets);\r\n\r\n    // Initialize default getImagePathCallback\r\n    GET_IMAGE_PATH_CALLBACK_REGISTRY ??=\r\n      getControlRegisterProperty(\"getImagePathCallback\", \"ch-tab-render\") ??\r\n      DEFAULT_GET_IMAGE_PATH_CALLBACK;\r\n\r\n    this.#computeImages();\r\n  }\r\n\r\n  // TODO: Use connectedCallback\r\n  componentWillLoad() {\r\n    this.#initializeState();\r\n  }\r\n\r\n  render() {\r\n    if (this.model == null || this.model.length === 0) {\r\n      return \"\";\r\n    }\r\n\r\n    const blockDirection = isBlockDirection(this.tabListPosition);\r\n    const startDirection = isStartDirection(this.tabListPosition);\r\n    const draggedIndex = this.draggedElementIndex;\r\n    const draggedElement = this.model[draggedIndex];\r\n    const thereAreShiftedElementsInPreview =\r\n      !this.hasCrossedBoundaries &&\r\n      this.draggedElementNewIndex !== -1 &&\r\n      this.draggedElementIndex !== this.draggedElementNewIndex;\r\n\r\n    return (\r\n      <Host\r\n        class={\r\n          !this.tabButtonHidden ? `ch-tab--${this.tabListPosition}` : undefined\r\n        }\r\n      >\r\n        {!this.tabButtonHidden && [\r\n          this.showTabListStart &&\r\n            this.#renderTabListPosition(\r\n              \"start\",\r\n              blockDirection,\r\n              startDirection\r\n            ),\r\n          this.#renderTabList(thereAreShiftedElementsInPreview),\r\n          this.showTabListEnd &&\r\n            this.#renderTabListPosition(\"end\", blockDirection, startDirection)\r\n        ]}\r\n\r\n        {this.#renderTabPages(blockDirection, startDirection)}\r\n\r\n        {draggedIndex !== -1 && this.#renderDragPreview(draggedElement)}\r\n      </Host>\r\n    );\r\n  }\r\n}\r\n"],"mappings":"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"}