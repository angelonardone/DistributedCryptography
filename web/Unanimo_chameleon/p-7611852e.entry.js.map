{"version":3,"names":["getScrollableParentToAttachInfiniteScroll","node","nodeToCheck","window","document","documentElement","overflowY","getComputedStyle","tagName","parentElement","infiniteScrollCss","ChInfiniteScrollStyle0","PRECISION_OFFSET","ChInfiniteScroll","lastClientHeight","lastScrollHeight","lastScrollTop","ioWatcher","resizeWatcher","abortController","smartGridRef","scrollableParent","typeOfParentElementAttached","dataProviderChanged","hasDataProvider","requestAnimationFrame","this","setInfiniteScroll","disconnectInfiniteScroll","disabledChanged","isDisabled","loadingStateChanged","newValue","checkIfCanFetchMoreData","thresholdChanged","complete","canFetch","loadingState","emitInfiniteEvent","infiniteThresholdReachedCallback","dataProvider","disabled","options","root","rootMargin","threshold","IntersectionObserver","entries","isIntersecting","observe","el","attachScroll","AbortController","addEventListener","trackLastScrollTop","capture","passive","signal","scrollTop","scrollHeight","setInverseLoading","position","overflowingContent","querySelector","ResizeObserver","adjustInverseScrollPositionWhenContentSizeChanges","currentClientHeight","clientHeight","currentScrollHeight","firstTimeThatContentOverflows","newScrollTop","scrollWasAtTheBottom","scrollOffset","clientHeightOffset","disconnectInverseLoading","disconnect","undefined","abort","componentDidLoad","getRootNode","host","result","disconnectedCallback","render","h","Host","key","class","smartGridCss","ChSmartGridStyle0","HIDE_CONTENT_AFTER_LOADING_CLASS","ChSmartGrid","contentIsHidden","infiniteThresholdReached","handleVirtualItemsChanged","event","startIndex","endIndex","totalItems","detail","infiniteScrollEnabled","inverseLoading","emit","avoidCLSOnInitialLoad","classList","add","removeAvoidCLS","removeEventListener","remove","connectedCallback","adoptCommonThemes","shadowRoot","adoptedStyleSheets","autoGrow","componentDidRender","initialLoad","hasRecords","itemsCount","accessibleName","SCROLLABLE_CLASS","name","smartGridCellCss","ChSmartGridCellStyle0","ChSmartGridCell","smartCellDidLoad","setAttribute","cellId"],"sources":["src/components/smart-grid/internal/infinite-scroll/utils.ts","src/components/smart-grid/internal/infinite-scroll/infinite-scroll.scss?tag=ch-infinite-scroll&encapsulation=shadow","src/components/smart-grid/internal/infinite-scroll/infinite-scroll.tsx","src/components/smart-grid/smart-grid.scss?tag=ch-smart-grid&encapsulation=shadow","src/components/smart-grid/smart-grid.tsx","src/components/smart-grid/internal/smart-grid-cell/smart-grid-cell.scss?tag=ch-smart-grid-cell","src/components/smart-grid/internal/smart-grid-cell/smart-grid-cell.tsx"],"sourcesContent":["/**\r\n * @todo TODO: Test this function when the element has an iframe as its parent element.\r\n *\r\n * Recursively look for a parent element in the `node`'s tree to calculate the\r\n * infinite scroll visibility and attach the scroll event listener.\r\n *\r\n * Considerations:\r\n *  - This algorithm starts with `node` === `this.el`.\r\n *  - If the parent grid has auto-grow = False, the return value should be\r\n *    the virtual scroller that is used in the parent grid.\r\n * @param node An element that will serve to recursively look up the parent element of `this.el` to attach the scroll event listener.\r\n * @returns A parent element of `node` in which the scroll event listener must be attached.\r\n */\r\nexport const getScrollableParentToAttachInfiniteScroll = (\r\n  node: Element | HTMLElement\r\n): [\"ch-smart-grid\" | \"other\" | \"window\", Element | HTMLElement] => {\r\n  let nodeToCheck = node;\r\n\r\n  // TODO: Add support for using getRootNode() to ensure node === null does\r\n  // not mean we hit a shadow boundary\r\n  while (\r\n    nodeToCheck !== null &&\r\n    nodeToCheck !== window.document.documentElement\r\n  ) {\r\n    // We try to search for first scrollable parent element.\r\n    const overflowY = window.getComputedStyle(node).overflowY;\r\n\r\n    // The last condition must be used, as the parent container could clip\r\n    // (overflow: hidden) its overflow. In that scenario, the scroll is \"hidden\"\r\n    // or \"locked\" but set\r\n    if (overflowY === \"auto\" || overflowY === \"scroll\") {\r\n      return [\r\n        nodeToCheck.tagName === \"ch-smart-grid\" ? \"ch-smart-grid\" : \"other\",\r\n        nodeToCheck\r\n      ];\r\n    }\r\n\r\n    nodeToCheck = nodeToCheck.parentElement as Element;\r\n  }\r\n\r\n  return [\"window\", window.document.documentElement];\r\n};\r\n",":host {\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  text-align: center;\r\n  block-size: 0; // Not loading by default\r\n  inline-size: 100%;\r\n  pointer-events: none;\r\n}\r\n\r\n// \"Hide\" the infinite scroll, but with the possibility to check its position\r\n// in the parent's scroll\r\n:host(.loading) {\r\n  block-size: auto;\r\n}\r\n","import {\r\n  Component,\r\n  ComponentInterface,\r\n  Element,\r\n  Host,\r\n  Method,\r\n  Prop,\r\n  Watch,\r\n  h\r\n} from \"@stencil/core\";\r\nimport { SmartGridDataState } from \"./types\";\r\nimport { getScrollableParentToAttachInfiniteScroll } from \"./utils\";\r\n\r\n/**\r\n * Due to floating point precision errors, we have to ensure a safe threshold\r\n * to update the scroll position to the bottom.\r\n */\r\nconst PRECISION_OFFSET = 2;\r\n\r\n@Component({\r\n  shadow: true,\r\n  styleUrl: \"infinite-scroll.scss\",\r\n  tag: \"ch-infinite-scroll\"\r\n})\r\nexport class ChInfiniteScroll implements ComponentInterface {\r\n  // Stored values\r\n  #lastClientHeight = 0;\r\n  #lastScrollHeight = 0;\r\n  #lastScrollTop = 0;\r\n\r\n  // Observers\r\n  #ioWatcher: IntersectionObserver | undefined;\r\n  #resizeWatcher: ResizeObserver | undefined;\r\n  #abortController: AbortController | undefined; // Allocated at runtime to save resources\r\n\r\n  // Refs\r\n  #smartGridRef!: HTMLChSmartGridElement;\r\n  #scrollableParent!: Element | HTMLElement;\r\n\r\n  #typeOfParentElementAttached: \"ch-smart-grid\" | \"window\" | \"other\" = \"other\";\r\n\r\n  @Element() el!: HTMLChInfiniteScrollElement;\r\n\r\n  /**\r\n   * `true` if the infinite scroll is used in a grid that has data provider.\r\n   * This attribute determine the utility of the infinite scroll, because in\r\n   * certain configurations the infinite scroll can be used only to implement\r\n   * the inverse loading utility.\r\n   */\r\n  @Prop() readonly dataProvider: boolean = false;\r\n  @Watch(\"dataProvider\")\r\n  dataProviderChanged(hasDataProvider: boolean) {\r\n    if (hasDataProvider) {\r\n      // Wait until the main thread has rendered the UI\r\n      requestAnimationFrame(this.#setInfiniteScroll);\r\n    } else {\r\n      this.#disconnectInfiniteScroll();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Specifies if the infinite scroll is disabled. When disabled, the infinite\r\n   * scroll won't fire any event when reaching the threshold.\r\n   * The `dataProvider` property can be `true` and this property can be `false`\r\n   * at the same time, meaning that the infinite scroll is disabled, but if the\r\n   * control has `inverseLoading`, the `dataProvider` property will re-position\r\n   * the scrollbar when new content is added to the grid.\r\n   */\r\n  @Prop() readonly disabled: boolean = false;\r\n  @Watch(\"disabled\")\r\n  disabledChanged(isDisabled: boolean) {\r\n    if (isDisabled) {\r\n      this.#disconnectInfiniteScroll();\r\n    } else {\r\n      // Wait until the main thread has rendered the UI\r\n      requestAnimationFrame(this.#setInfiniteScroll);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This Handler will be called every time grid threshold is reached. Needed\r\n   * for infinite scrolling grids.\r\n   */\r\n  @Prop() readonly infiniteThresholdReachedCallback!: () => void;\r\n\r\n  /**\r\n   * If `true`, the infinite scroll will be hidden and scroll event listeners\r\n   * will be removed.\r\n   *\r\n   * Set this to `false` to disable the infinite scroll from actively trying to\r\n   * receive new data while reaching the threshold. This is useful when it is\r\n   * known that there is no more data that can be added, and the infinite\r\n   * scroll is no longer needed.\r\n   */\r\n  @Prop({ mutable: true }) loadingState!: SmartGridDataState;\r\n  @Watch(\"loadingState\")\r\n  loadingStateChanged(newValue: SmartGridDataState) {\r\n    this.#checkIfCanFetchMoreData();\r\n\r\n    if (newValue === \"initial\") {\r\n      this.#lastClientHeight = 0;\r\n      this.#lastScrollHeight = 0;\r\n      this.#lastScrollTop = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The position of the infinite scroll element.\r\n   * The value can be either `top` or `bottom`. When `position === \"top\"`, the\r\n   * control also implements inverse loading.\r\n   */\r\n  @Prop() readonly position: \"top\" | \"bottom\" = \"bottom\";\r\n\r\n  /**\r\n   * The threshold distance from the bottom of the content to call the\r\n   * `infinite` output event when scrolled.\r\n   * The threshold value can be either a percent, or in pixels. For example,\r\n   * use the value of `10%` for the `infinite` output event to get called when\r\n   * the user has scrolled 10% from the bottom of the page. Use the value\r\n   * `100px` when the scroll is within 100 pixels from the bottom of the page.\r\n   */\r\n  @Prop() readonly threshold: string = \"150px\";\r\n  @Watch(\"threshold\")\r\n  thresholdChanged() {\r\n    this.#checkIfCanFetchMoreData();\r\n  }\r\n\r\n  /**\r\n   * Call `complete()` within the `gxInfinite` output event handler when\r\n   * your async operation has completed. For example, the `loading`\r\n   * state is while the app is performing an asynchronous operation,\r\n   * such as receiving more data from an AJAX request to add more items\r\n   * to a data list. Once the data has been received and UI updated, you\r\n   * then call this method to signify that the loading has completed.\r\n   * This method will change the infinite scroll's state from `loading`\r\n   * to `enabled`.\r\n   */\r\n  @Method()\r\n  async complete() {\r\n    // this.waitingForData = false;\r\n  }\r\n\r\n  #canFetch = () => this.loadingState === \"more-data-to-fetch\";\r\n\r\n  /**\r\n   * This function unobserves and re-observes the infinite scroll element when\r\n   * new items are added in the grid. Without this configuration, if the grid\r\n   * has no scroll even after new items are added, the intersection observer\r\n   * won't fire a new interruption because it is still visible in the viewport.\r\n   */\r\n  // eslint-disable-next-line @stencil-community/own-props-must-be-private\r\n  #checkIfCanFetchMoreData = () => {\r\n    this.#disconnectInfiniteScroll();\r\n\r\n    // Wait until the main thread has rendered the UI\r\n    requestAnimationFrame(this.#setInfiniteScroll);\r\n  };\r\n\r\n  #emitInfiniteEvent = () => {\r\n    if (this.loadingState !== \"loading\") {\r\n      // Ensure the infinite scroll is not triggered twice\r\n      this.loadingState = \"loading\";\r\n      this.infiniteThresholdReachedCallback();\r\n    }\r\n  };\r\n\r\n  #setInfiniteScroll = () => {\r\n    // The observer was already set\r\n    if (!this.dataProvider || this.disabled) {\r\n      return;\r\n    }\r\n\r\n    // Track the threshold changes after the DOM is updated\r\n    requestAnimationFrame(() => {\r\n      // The ioWatcher must be checked inside the RAF, to avoid memory issues,\r\n      // due to dispatching multiple #setInfiniteScroll, without the watcher defined\r\n      if (!this.#canFetch() || this.#ioWatcher) {\r\n        return;\r\n      }\r\n\r\n      const options: IntersectionObserverInit = {\r\n        root: this.#scrollableParent,\r\n        rootMargin: this.threshold\r\n      };\r\n\r\n      this.#ioWatcher = new IntersectionObserver(entries => {\r\n        if (entries[0].isIntersecting) {\r\n          this.#emitInfiniteEvent();\r\n        }\r\n      }, options);\r\n\r\n      this.#ioWatcher.observe(this.el);\r\n    });\r\n  };\r\n\r\n  #attachScroll = () => {\r\n    this.#abortController ??= new AbortController();\r\n\r\n    this.#scrollableParent.addEventListener(\r\n      \"scroll\",\r\n      this.#trackLastScrollTop,\r\n      { capture: true, passive: true, signal: this.#abortController.signal }\r\n    );\r\n  };\r\n\r\n  #trackLastScrollTop = () => {\r\n    this.#lastScrollTop = this.#scrollableParent.scrollTop;\r\n    this.#lastScrollHeight = this.#scrollableParent.scrollHeight;\r\n  };\r\n\r\n  #setInverseLoading = () => {\r\n    // Inverse loading is not supported when the scroll is attached to the window.\r\n    // The current implementation \"supports\" this scenario, but since this use\r\n    // case changes the position of the scroll every time the grid retrieves\r\n    // data, unexpected behaviors will occur.\r\n    // Also, Android does not support Inverse Loading in this scenario either.\r\n    if (\r\n      this.#typeOfParentElementAttached === \"window\" ||\r\n      this.position !== \"top\"\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    // Attach scroll after the DOM is rendered\r\n    requestAnimationFrame(this.#attachScroll);\r\n\r\n    /**\r\n     * This element represents the cell container (`[slot=\"grid-content\"]`).\r\n     * ```tsx\r\n     *   <ch-smart-grid>\r\n     *     #shadow-root (open)\r\n     *     |  <ch-infinite-scroll></ch-infinite-scroll>\r\n     *     |  <slot name=\"grid-content\"></slot>\r\n     *     <div slot=\"grid-content\">\r\n     *       <ch-smart-grid-cell>...</ch-smart-grid-cell>\r\n     *       <ch-smart-grid-cell>...</ch-smart-grid-cell>\r\n     *       ...\r\n     *     </div>\r\n     *   </ch-smart-grid>\r\n     * ```\r\n     */\r\n    const overflowingContent = this.#smartGridRef.querySelector(\r\n      \"[slot='grid-content']\"\r\n    ) as HTMLElement;\r\n\r\n    overflowingContent.scrollTop =\r\n      overflowingContent.scrollHeight + PRECISION_OFFSET;\r\n\r\n    this.#resizeWatcher = new ResizeObserver(\r\n      this.#adjustInverseScrollPositionWhenContentSizeChanges\r\n    );\r\n\r\n    this.#resizeWatcher.observe(overflowingContent);\r\n    this.#resizeWatcher.observe(this.#scrollableParent);\r\n  };\r\n\r\n  #adjustInverseScrollPositionWhenContentSizeChanges = () => {\r\n    // console.log(\"adjustInverseScrollPositionWhenContentSizeChanges...\");\r\n\r\n    // Current values\r\n    const currentClientHeight = this.#scrollableParent.clientHeight;\r\n    const currentScrollHeight = this.#scrollableParent.scrollHeight;\r\n\r\n    const firstTimeThatContentOverflows =\r\n      this.#lastClientHeight === this.#lastScrollHeight &&\r\n      currentClientHeight < currentScrollHeight;\r\n\r\n    // Must set the scroll at the bottom position\r\n    if (firstTimeThatContentOverflows) {\r\n      const newScrollTop =\r\n        currentScrollHeight - currentClientHeight + PRECISION_OFFSET;\r\n\r\n      this.#lastClientHeight = currentClientHeight;\r\n      this.#lastScrollHeight = currentScrollHeight;\r\n\r\n      // Scroll to bottom\r\n      this.#scrollableParent.scrollTop = newScrollTop;\r\n      this.#lastScrollTop = newScrollTop;\r\n      return;\r\n    }\r\n\r\n    const scrollWasAtTheBottom =\r\n      this.#lastScrollHeight <=\r\n      this.#lastClientHeight + this.#lastScrollTop + PRECISION_OFFSET;\r\n\r\n    // The scroll is only adjusted if the grid has a data provider or the\r\n    // scroll was at the bottom position. When the grid has a data provider\r\n    // items can be loaded via infinite scroll, so the scroll position needs\r\n    // adjusted when new items are added\r\n    if (this.dataProvider || scrollWasAtTheBottom) {\r\n      const scrollOffset = currentScrollHeight - this.#lastScrollHeight;\r\n      const clientHeightOffset =\r\n        currentClientHeight < this.#lastClientHeight\r\n          ? this.#lastClientHeight - currentClientHeight\r\n          : 0;\r\n\r\n      const newScrollTop =\r\n        this.#lastScrollTop +\r\n        scrollOffset +\r\n        clientHeightOffset +\r\n        (scrollWasAtTheBottom ? PRECISION_OFFSET : 0); // Scroll to bottom\r\n\r\n      this.#scrollableParent.scrollTop = newScrollTop;\r\n      this.#lastScrollTop = newScrollTop;\r\n    }\r\n\r\n    this.#lastClientHeight = currentClientHeight;\r\n    this.#lastScrollHeight = currentScrollHeight;\r\n  };\r\n\r\n  #disconnectInverseLoading = () => {\r\n    this.#resizeWatcher?.disconnect();\r\n    this.#resizeWatcher = undefined;\r\n\r\n    // Remove scroll events in the smart grid\r\n    this.#abortController.abort();\r\n  };\r\n\r\n  #disconnectInfiniteScroll = () => {\r\n    this.#ioWatcher?.disconnect();\r\n    this.#ioWatcher = undefined;\r\n  };\r\n\r\n  componentDidLoad() {\r\n    this.#smartGridRef = (this.el.getRootNode() as ShadowRoot)\r\n      .host as HTMLChSmartGridElement;\r\n\r\n    const result = getScrollableParentToAttachInfiniteScroll(\r\n      this.#smartGridRef\r\n    );\r\n    this.#typeOfParentElementAttached = result[0];\r\n    this.#scrollableParent = result[1];\r\n\r\n    this.#setInverseLoading();\r\n\r\n    // Wait until the main thread has rendered the UI\r\n    requestAnimationFrame(this.#setInfiniteScroll);\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    this.#disconnectInfiniteScroll();\r\n    this.#disconnectInverseLoading();\r\n  }\r\n\r\n  // TODO: Ensure the ch-infinite-scroll doesn't crash when is only used by\r\n  // itself (without a ch-smart-grid as a parent)\r\n  render() {\r\n    return (\r\n      <Host\r\n        class={this.loadingState === \"loading\" ? \"loading\" : undefined}\r\n        aria-hidden=\"true\"\r\n      >\r\n        {this.loadingState === \"loading\" && <slot />}\r\n      </Host>\r\n    );\r\n  }\r\n}\r\n",":host {\r\n  display: grid;\r\n  grid-template-rows: 1fr;\r\n  grid-template-columns: 1fr;\r\n}\r\n\r\n:host(.ch-smart-grid--loaded-render-delay) {\r\n  opacity: 0;\r\n\r\n  // Disable scroll actions on intial load\r\n  pointer-events: none;\r\n}\r\n\r\n:host(.ch-smart-grid--inverse-loading) {\r\n  grid-template-rows: max-content 1fr;\r\n}\r\n\r\n:host(.ch-smart-grid--data-provider) {\r\n  grid-template-rows: 1fr max-content;\r\n}\r\n\r\n// This class is set when the smart-grid defines its own scroll\r\n:host(.ch-scrollable) {\r\n  contain: strict;\r\n  overflow: auto;\r\n  overflow-anchor: none;\r\n}\r\n\r\n::slotted([slot=\"grid-content\"]) {\r\n  display: grid;\r\n  grid-auto-rows: max-content;\r\n}\r\n","import {\r\n  Component,\r\n  ComponentInterface,\r\n  Element,\r\n  Event,\r\n  EventEmitter,\r\n  Host,\r\n  Listen,\r\n  Prop,\r\n  State,\r\n  // Watch,\r\n  h\r\n} from \"@stencil/core\";\r\nimport { AccessibleNameComponent } from \"../../common/interfaces\";\r\nimport { SmartGridDataState } from \"./internal/infinite-scroll/types\";\r\nimport { VirtualScrollVirtualItems } from \"../../virtual-scroller/types\";\r\nimport { ChVirtualScrollerCustomEvent } from \"../../components\";\r\nimport { SCROLLABLE_CLASS } from \"../../common/reserved-names\";\r\nimport { adoptCommonThemes } from \"../../common/theme\";\r\n\r\nconst HIDE_CONTENT_AFTER_LOADING_CLASS = \"ch-smart-grid--loaded-render-delay\";\r\n\r\n@Component({\r\n  shadow: true,\r\n  styleUrl: \"smart-grid.scss\",\r\n  tag: \"ch-smart-grid\"\r\n})\r\nexport class ChSmartGrid\r\n  implements AccessibleNameComponent, ComponentInterface\r\n{\r\n  /**\r\n   * Used in virtual scroll scenarios. Enables infinite scrolling if the\r\n   * virtual items are closer to the real threshold.\r\n   */\r\n  @State() infiniteScrollEnabled = true;\r\n\r\n  /**\r\n   * This variable is used to avoid layout shifts (CLS) at the initial load,\r\n   * due to the async render of the content.\r\n   */\r\n  // eslint-disable-next-line @stencil-community/own-props-must-be-private\r\n  #contentIsHidden = false;\r\n\r\n  @Element() el: HTMLChSmartGridElement;\r\n\r\n  /**\r\n   * Specifies a short string, typically 1 to 3 words, that authors associate\r\n   * with an element to provide users of assistive technologies with a label\r\n   * for the element.\r\n   */\r\n  @Prop() readonly accessibleName: string;\r\n\r\n  /**\r\n   * This attribute defines if the control size will grow automatically,\r\n   * to adjust to its content size.\r\n   * If set to `false`, it won't grow automatically and it will show scrollbars\r\n   * if the content overflows.\r\n   */\r\n  @Prop() readonly autoGrow: boolean = false;\r\n\r\n  /**\r\n   * `true` if the control has a data provider and therefore must implement a\r\n   * infinite scroll to load data.\r\n   */\r\n  @Prop() readonly dataProvider: boolean = false;\r\n\r\n  /**\r\n   * When set to `true`, the grid items will be loaded in inverse order, with\r\n   * the first element at the bottom and the \"Loading\" message (infinite-scroll)\r\n   * at the top.\r\n   */\r\n  @Prop() readonly inverseLoading: boolean = false;\r\n\r\n  /**\r\n   * Grid current row count. This property is used in order to be able to\r\n   * re-render the Grid every time the Grid data changes.\r\n   * If not specified, then grid empty and loading placeholders may not work\r\n   * correctly.\r\n   */\r\n  @Prop() readonly itemsCount!: number;\r\n\r\n  /**\r\n   * Specifies the loading state of the grid.\r\n   */\r\n  @Prop({ mutable: true }) loadingState: SmartGridDataState = \"initial\";\r\n  // @Watch(\"loadingState\")\r\n  // loadingStateChange(_, oldLoadingState: SmartGridDataState) {\r\n  //   if (oldLoadingState === \"initial\") {\r\n  //     this.#avoidCLSOnInitialLoad();\r\n  //   }\r\n  // }\r\n\r\n  /**\r\n   * The threshold distance from the bottom of the content to call the\r\n   * `infinite` output event when scrolled. The threshold value can be either a\r\n   * percent, or in pixels. For example, use the value of `10%` for the\r\n   * `infinite` output event to get called when the user has scrolled 10% from\r\n   * the bottom of the page. Use the value `100px` when the scroll is within\r\n   * 100 pixels from the bottom of the page.\r\n   */\r\n  @Prop() readonly threshold: string = \"10px\";\r\n\r\n  /**\r\n   * This Handler will be called every time grid threshold is reached. Needed\r\n   * for infinite scrolling grids.\r\n   */\r\n  @Event({ bubbles: false }) infiniteThresholdReached: EventEmitter<void>;\r\n\r\n  @Listen(\"virtualItemsChanged\")\r\n  handleVirtualItemsChanged(\r\n    event: ChVirtualScrollerCustomEvent<VirtualScrollVirtualItems>\r\n  ) {\r\n    const { startIndex, endIndex, totalItems } = event.detail;\r\n\r\n    this.infiniteScrollEnabled =\r\n      (this.inverseLoading && startIndex === 0) ||\r\n      (!this.inverseLoading && endIndex === totalItems - 1);\r\n  }\r\n\r\n  #infiniteThresholdReachedCallback = () => {\r\n    this.loadingState = \"loading\";\r\n    this.infiniteThresholdReached.emit();\r\n  };\r\n\r\n  #avoidCLSOnInitialLoad = () => {\r\n    if (this.inverseLoading) {\r\n      this.#contentIsHidden = true;\r\n      this.el.classList.add(HIDE_CONTENT_AFTER_LOADING_CLASS);\r\n    }\r\n  };\r\n\r\n  #removeAvoidCLS = () => {\r\n    this.#contentIsHidden = false;\r\n    this.el.removeEventListener(\"virtualScrollerDidLoad\", this.#removeAvoidCLS);\r\n\r\n    requestAnimationFrame(() => {\r\n      this.el.classList.remove(HIDE_CONTENT_AFTER_LOADING_CLASS);\r\n    });\r\n  };\r\n\r\n  connectedCallback(): void {\r\n    // TODO: Investigate this. If we don't add this function call, but we add\r\n    // the class in the Host, the scrollbar is styled, but it shouldn't\r\n    adoptCommonThemes(this.el.shadowRoot.adoptedStyleSheets);\r\n    this.#avoidCLSOnInitialLoad();\r\n\r\n    if (this.inverseLoading && !this.autoGrow) {\r\n      this.el.addEventListener(\"virtualScrollerDidLoad\", this.#removeAvoidCLS);\r\n    }\r\n  }\r\n\r\n  componentDidRender(): void {\r\n    if (!this.#contentIsHidden) {\r\n      return;\r\n    }\r\n\r\n    if (this.inverseLoading && this.autoGrow) {\r\n      this.#removeAvoidCLS();\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const initialLoad = this.loadingState === \"initial\";\r\n    const hasRecords = this.itemsCount > 0;\r\n\r\n    return (\r\n      <Host\r\n        aria-label={this.accessibleName || undefined}\r\n        // Improve accessibility by announcing live changes\r\n        aria-live=\"polite\"\r\n        // Wait until all changes are made to prevents assistive\r\n        // technologies from announcing changes before updates are done\r\n        aria-busy={\r\n          initialLoad || this.loadingState === \"loading\" ? \"true\" : \"false\"\r\n        }\r\n        class={{\r\n          \"ch-smart-grid--inverse-loading\": hasRecords && this.inverseLoading,\r\n          \"ch-smart-grid--data-provider\":\r\n            hasRecords && this.dataProvider && !this.inverseLoading,\r\n          [SCROLLABLE_CLASS]: !this.autoGrow\r\n        }}\r\n      >\r\n        {initialLoad ? (\r\n          <slot name=\"grid-initial-loading-placeholder\" />\r\n        ) : (\r\n          [\r\n            // TODO: Don't attach the ch-infinite-scroll component if the\r\n            // smart-grid doesn't have an slot \"grid-content\" in its Light DOM\r\n            // Otherwise, the ch-infinite-scroll will break in runtime\r\n            hasRecords && this.inverseLoading && (\r\n              <ch-infinite-scroll\r\n                dataProvider={this.dataProvider}\r\n                disabled={!this.infiniteScrollEnabled}\r\n                infiniteThresholdReachedCallback={\r\n                  this.#infiniteThresholdReachedCallback\r\n                }\r\n                loadingState={this.loadingState}\r\n                position=\"top\"\r\n                threshold={this.threshold}\r\n              ></ch-infinite-scroll>\r\n            ),\r\n\r\n            <slot name={hasRecords ? \"grid-content\" : \"grid-content-empty\"} />,\r\n\r\n            hasRecords && this.dataProvider && !this.inverseLoading && (\r\n              <ch-infinite-scroll\r\n                dataProvider\r\n                disabled={!this.infiniteScrollEnabled}\r\n                infiniteThresholdReachedCallback={\r\n                  this.#infiniteThresholdReachedCallback\r\n                }\r\n                loadingState={this.loadingState}\r\n                threshold={this.threshold}\r\n              ></ch-infinite-scroll>\r\n            )\r\n          ]\r\n        )}\r\n      </Host>\r\n    );\r\n  }\r\n}\r\n","smart-grid-cell {\r\n  display: flex;\r\n}\r\n","import {\r\n  Component,\r\n  ComponentInterface,\r\n  Element,\r\n  Event,\r\n  EventEmitter,\r\n  Prop\r\n} from \"@stencil/core\";\r\n\r\n@Component({\r\n  styleUrl: \"smart-grid-cell.scss\",\r\n  tag: \"ch-smart-grid-cell\"\r\n})\r\nexport class ChSmartGridCell implements ComponentInterface {\r\n  @Element() el: HTMLChSmartGridCellElement;\r\n\r\n  /**\r\n   * Specifies the ID of the cell.\r\n   */\r\n  @Prop() readonly cellId!: string;\r\n\r\n  /**\r\n   * Fired when the component and all its child did render for the first time.\r\n   */\r\n  @Event() smartCellDidLoad: EventEmitter<string>;\r\n\r\n  connectedCallback() {\r\n    this.el.setAttribute(\"role\", \"gridcell\");\r\n  }\r\n\r\n  componentDidLoad() {\r\n    this.smartCellDidLoad.emit(this.cellId);\r\n\r\n    // DOM write operation\r\n    this.el.setAttribute(\"data-did-load\", \"true\");\r\n  }\r\n}\r\n"],"mappings":"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"}