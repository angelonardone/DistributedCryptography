{"version":3,"names":["cellIsRendered","cell","hasAttribute","style","display","isRenderedSmartCellVisible","element","smartGridBoundingRect","elementRect","getBoundingClientRect","smartGridRectLeftX","x","smartGridRectRightX","width","smartGridRectTopY","y","smartGridRectBottomY","height","rectLeftX","rectRightX","rectTopY","rectBottomY","inBetween","isVirtualSizeCellVisible","virtualSize","smartGridScrollTop","offsetTop","emptyItems","items","undefined","length","getSmartCells","scroller","querySelectorAll","updateVirtualScrollSize","virtualPosition","virtualSizes","removedCells","renderedItemKeys","Set","index","startIndex","endIndex","smartGridItem","add","id","renderedCells","forEach","renderedCell","has","cellId","offsetLeft","cellBoundingRect","push","set","cellsInViewportAreLoadedAndVisible","smartGrid","inverseLoading","cells","smartGridBoundingBox","lastIndex","increment","currentCell","WAITING_FOR_CELLS_TO_BE_RENDERED","type","findFirstVirtualSizeThatIsNotVisible","bufferSize","closerVirtualSizeId","closerVirtualSizeBottomY","virtualSizeId","virtualSizeBottomY","virtualSizeIsHidden","closerVirtualItemIndex","findIndex","el","Math","max","renderedCellsCount","cellsThatAreNotVisible","get","isVirtualSizeVisible","isRenderedCellVisible","min","LOWER_BUFFER_RANGE","firstIndex","UPPER_BUFFER_RANGE","getAmountOfCellsThatAreVisibleInTheBuffer","lastRenderedCellIndex","indexLimit","checkIndexRange","currentIndex","shift","getNewStartAndEndIndexes","virtualStartSize","virtualEndSize","allCellsAreRendered","every","scrollTop","secondRenderedCell","scrollIsAtVirtualStartSize","secondLastCell","at","scrollIsAtVirtualEndSize","startShift","endShift","virtualScrollerCss","ChVirtualScrollerStyle0","VIRTUAL_SCROLL_CUSTOM_VAR_PREFIX","VIRTUAL_SCROLL_START_SIZE_CUSTOM_VAR","VIRTUAL_SCROLL_START_DISPLAY_CUSTOM_VAR","VIRTUAL_SCROLL_END_SIZE_CUSTOM_VAR","VIRTUAL_SCROLL_END_DISPLAY_CUSTOM_VAR","ChVirtualScroller","canUpdateRenderedCells","waitingForCellsToBeRendered","abortController","syncWithRAF","SyncWithRAF","resizeObserver","waitingForContentChanged","this","setVirtualScroller","itemsChanged","newItems","resetVirtualScrollerState","setViewportItemsOnInitialRender","virtualItemsChanged","virtualScrollerDidLoad","addItems","position","unshift","newItemsCount","handleSmartGridContentScroll","lastIndexForVirtualStartSize","firstIndexForVirtualEndSize","lastCellForVirtualStartSize","firstCellForVirtualEndSize","additionalHeightsStartIndex","virtualIndex","cellIdToAddVirtualSize","maxSmartGridVirtualHeight","removedCell","setProperty","perform","updateRenderedCells","cellsToRender","bufferAmount","shiftIndex","emitVirtualItemsChange","virtualItems","slice","emit","totalItems","mode","Map","indexToShift","initialRenderViewportItems","startIncomingShift","endIncomingShift","newEndIndex","newStartIndex","AbortController","requestAnimationFrame","addEventListener","passive","signal","ResizeObserver","observe","handleRenderedCell","event","waitingForContent","checkInitialRenderVisibility","checkCellsRenderedAtRuntime","detail","delete","connectedCallback","componentDidLoad","closest","disconnectedCallback","disconnect","cancel","abort","render","h","Host","key","class","onSlotchange"],"sources":["src/virtual-scroller/utils.ts","src/virtual-scroller/update-virtual-scroll.ts","src/virtual-scroller/cells-in-viewport-are-rendered-and-visible.ts","src/virtual-scroller/get-new-start-and-end-indexes.ts","src/virtual-scroller/virtual-scroller.scss?tag=ch-virtual-scroller&encapsulation=shadow","src/virtual-scroller/virtual-scroller.tsx"],"sourcesContent":["import { inBetween } from \"../common/utils\";\r\nimport { SmartGridModel } from \"../components/smart-grid/types\";\r\nimport { SmartGridCellVirtualSize } from \"./types\";\r\n\r\nexport const cellIsRendered = (cell: HTMLElement) =>\r\n  cell.hasAttribute(\"data-did-load\") && cell.style.display !== \"none\";\r\n\r\nexport const isRenderedSmartCellVisible = (\r\n  element: HTMLElement,\r\n  smartGridBoundingRect: DOMRect\r\n) => {\r\n  const elementRect = element.getBoundingClientRect();\r\n\r\n  const smartGridRectLeftX = smartGridBoundingRect.x;\r\n  const smartGridRectRightX =\r\n    smartGridBoundingRect.x + smartGridBoundingRect.width;\r\n\r\n  const smartGridRectTopY = smartGridBoundingRect.y;\r\n  const smartGridRectBottomY =\r\n    smartGridBoundingRect.y + smartGridBoundingRect.height;\r\n\r\n  const rectLeftX = elementRect.x;\r\n  const rectRightX = elementRect.x + elementRect.width;\r\n\r\n  const rectTopY = elementRect.y;\r\n  const rectBottomY = elementRect.y + elementRect.height;\r\n\r\n  return (\r\n    // At least, the left or right edge is visible in the X axis\r\n    (inBetween(smartGridRectLeftX, rectLeftX, smartGridRectRightX) ||\r\n      inBetween(smartGridRectLeftX, rectRightX, smartGridRectRightX)) &&\r\n    // At least, the top or bottom edge is visible in the Y axis\r\n    (inBetween(smartGridRectTopY, rectTopY, smartGridRectBottomY) ||\r\n      inBetween(smartGridRectTopY, rectBottomY, smartGridRectBottomY))\r\n  );\r\n};\r\n\r\nexport const isVirtualSizeCellVisible = (\r\n  virtualSize: SmartGridCellVirtualSize,\r\n  smartGridScrollTop: number,\r\n  smartGridBoundingRect: DOMRect\r\n): boolean => {\r\n  const smartGridRectTopY = smartGridScrollTop;\r\n  const smartGridRectBottomY =\r\n    smartGridScrollTop + smartGridBoundingRect.height;\r\n  const rectTopY = virtualSize.offsetTop;\r\n  const rectBottomY = virtualSize.offsetTop + virtualSize.height;\r\n\r\n  // At least, the top or bottom edge is visible in the Y axis\r\n  return (\r\n    inBetween(smartGridRectTopY, rectTopY, smartGridRectBottomY) ||\r\n    inBetween(smartGridRectTopY, rectBottomY, smartGridRectBottomY)\r\n  );\r\n};\r\n\r\nexport const emptyItems = (items: SmartGridModel) =>\r\n  items === undefined || items.length === 0;\r\n\r\nexport const getSmartCells = (scroller: HTMLChVirtualScrollerElement) =>\r\n  [\r\n    ...scroller.querySelectorAll(\":scope>ch-smart-grid-cell\")\r\n  ] as HTMLChSmartGridCellElement[];\r\n","import { SmartGridModel } from \"../components/smart-grid/types\";\r\nimport {\r\n  SmartGridCellVirtualSize,\r\n  SmartGridVirtualPositionIndex\r\n} from \"./types\";\r\nimport { cellIsRendered } from \"./utils\";\r\n\r\n/**\r\n * Update the virtual sizes and returns the removed cells.\r\n */\r\nexport const updateVirtualScrollSize = (\r\n  virtualPosition: SmartGridVirtualPositionIndex,\r\n  virtualSizes: Map<string, SmartGridCellVirtualSize>,\r\n  items: SmartGridModel\r\n): HTMLChSmartGridCellElement[] => {\r\n  const removedCells: HTMLChSmartGridCellElement[] = [];\r\n\r\n  const renderedItemKeys: Set<string> = new Set();\r\n\r\n  // Store the keys of the items that must be rendered\r\n  for (\r\n    let index = virtualPosition.startIndex;\r\n    index <= virtualPosition.endIndex;\r\n    index++\r\n  ) {\r\n    const smartGridItem = items[index];\r\n    renderedItemKeys.add(smartGridItem.id);\r\n  }\r\n\r\n  // Remove rendered cells that are will be no longer displayed\r\n  virtualPosition.renderedCells.forEach(renderedCell => {\r\n    if (\r\n      !renderedItemKeys.has(renderedCell.cellId) &&\r\n      cellIsRendered(renderedCell) &&\r\n      renderedCell.style.display !== \"none\"\r\n    ) {\r\n      const { offsetTop, offsetLeft } = renderedCell;\r\n      const cellBoundingRect = renderedCell.getBoundingClientRect();\r\n\r\n      removedCells.push(renderedCell);\r\n\r\n      virtualSizes.set(renderedCell.cellId, {\r\n        width: cellBoundingRect.width,\r\n        height: cellBoundingRect.height,\r\n        offsetTop: offsetTop,\r\n        offsetLeft: offsetLeft\r\n      });\r\n    }\r\n  });\r\n\r\n  return removedCells;\r\n};\r\n","import { inBetween } from \"../common/utils\";\r\nimport {\r\n  cellIsRendered,\r\n  getSmartCells,\r\n  isRenderedSmartCellVisible\r\n} from \"./utils\";\r\n\r\n// TODO: Use padding in the ch-smart-grid and see if this works well\r\nexport const cellsInViewportAreLoadedAndVisible = (\r\n  scroller: HTMLChVirtualScrollerElement,\r\n  smartGrid: HTMLChSmartGridElement,\r\n  inverseLoading: boolean\r\n): boolean => {\r\n  const cells = getSmartCells(scroller);\r\n  const smartGridBoundingBox = smartGrid.getBoundingClientRect();\r\n\r\n  const lastIndex = cells.length - 1;\r\n  let startIndex = inverseLoading ? lastIndex : 0;\r\n  const increment = inverseLoading ? -1 : 1;\r\n\r\n  while (inBetween(0, startIndex, lastIndex)) {\r\n    const currentCell = cells[startIndex];\r\n\r\n    if (cellIsRendered(currentCell)) {\r\n      // The previous cells were visible, but we found a cell that is rendered\r\n      // and its not in the viewport. Assume that the cell won't be displayed\r\n      // in the viewport even when it's fully rendered\r\n      if (!isRenderedSmartCellVisible(currentCell, smartGridBoundingBox)) {\r\n        return true;\r\n      }\r\n    }\r\n    // There is a cell that isn't rendered, we can check its visibility, but\r\n    // we can't ensure if when the cell is rendered, the next cells will be\r\n    // visible or not\r\n    else {\r\n      return false;\r\n    }\r\n\r\n    startIndex += increment;\r\n  }\r\n\r\n  return true;\r\n};\r\n","import { inBetween } from \"../common/utils\";\r\nimport { SmartGridModel } from \"../components/smart-grid/types\";\r\nimport { SmartGridVirtualPosition, SmartGridCellVirtualSize } from \"./types\";\r\nimport {\r\n  cellIsRendered,\r\n  getSmartCells,\r\n  isRenderedSmartCellVisible,\r\n  isVirtualSizeCellVisible\r\n} from \"./utils\";\r\n\r\nconst WAITING_FOR_CELLS_TO_BE_RENDERED = {\r\n  type: \"waiting-for-cells-to-render\"\r\n} as const satisfies SmartGridVirtualPosition;\r\n\r\nconst findFirstVirtualSizeThatIsNotVisible = (\r\n  renderedCells: HTMLChSmartGridCellElement[],\r\n  items: SmartGridModel,\r\n  virtualSizes: Map<string, SmartGridCellVirtualSize>,\r\n  bufferSize: number,\r\n  smartGridScrollTop: number,\r\n  smartGridBoundingRect: DOMRect,\r\n  inverseLoading: boolean\r\n): SmartGridVirtualPosition => {\r\n  let closerVirtualSizeId = \"\";\r\n  let closerVirtualSizeBottomY = 0;\r\n\r\n  // Find the key of the closer virtual size to the viewport that isn't visible\r\n  virtualSizes.forEach((virtualSize, virtualSizeId) => {\r\n    const virtualSizeBottomY = virtualSize.offsetTop + virtualSize.height;\r\n    const virtualSizeIsHidden = virtualSizeBottomY <= smartGridScrollTop;\r\n\r\n    if (virtualSizeIsHidden && closerVirtualSizeBottomY <= virtualSizeBottomY) {\r\n      closerVirtualSizeBottomY = virtualSizeBottomY;\r\n      closerVirtualSizeId = virtualSizeId;\r\n    }\r\n  });\r\n\r\n  // TODO: Use memory to retrieve the index given the cellId\r\n  const closerVirtualItemIndex = items.findIndex(\r\n    el => el.id === closerVirtualSizeId\r\n  );\r\n\r\n  // Since we found the closer hidden virtual size, the shift is one cell smaller\r\n  const startIndex = Math.max(0, closerVirtualItemIndex + 1 - bufferSize);\r\n  const lastIndex = items.length - 1;\r\n  let endIndex = closerVirtualItemIndex + 1; // Start in the first visible cell\r\n  let renderedCellsCount = 0;\r\n  let cellsThatAreNotVisible = 0;\r\n\r\n  // When the virtual scroll has inverse loading enabled, all items on the end\r\n  // of the viewport are always rendered, to avoid flickering issues with the\r\n  // scroll. In other words, the endIndex is always the last index\r\n  if (inverseLoading) {\r\n    return {\r\n      startIndex,\r\n      endIndex: lastIndex,\r\n      renderedCells,\r\n      type: \"index\"\r\n    };\r\n  }\r\n\r\n  // Find the endIndex to render the cells. This index takes into account the\r\n  // cells that must be not visible in the buffer\r\n  while (\r\n    inBetween(0, endIndex, lastIndex) &&\r\n    cellsThatAreNotVisible < bufferSize\r\n  ) {\r\n    const cellId = items[endIndex].id;\r\n    const virtualSize = virtualSizes.get(cellId);\r\n\r\n    if (virtualSize) {\r\n      const isVirtualSizeVisible = isVirtualSizeCellVisible(\r\n        virtualSize,\r\n        smartGridScrollTop,\r\n        smartGridBoundingRect\r\n      );\r\n\r\n      if (!isVirtualSizeVisible) {\r\n        cellsThatAreNotVisible++;\r\n      }\r\n    }\r\n    // We assume that the rendered cells are sorted\r\n    else {\r\n      const renderedCell = renderedCells[renderedCellsCount];\r\n\r\n      const isRenderedCellVisible = isRenderedSmartCellVisible(\r\n        renderedCell,\r\n        smartGridBoundingRect\r\n      );\r\n\r\n      if (!isRenderedCellVisible) {\r\n        cellsThatAreNotVisible++;\r\n      }\r\n\r\n      renderedCellsCount++;\r\n    }\r\n\r\n    endIndex++;\r\n  }\r\n\r\n  endIndex = Math.min(lastIndex, endIndex + bufferSize - 1);\r\n\r\n  return {\r\n    startIndex,\r\n    endIndex,\r\n    renderedCells,\r\n    type: \"index\"\r\n  };\r\n};\r\n\r\nconst LOWER_BUFFER_RANGE = (index: number, firstIndex) => firstIndex <= index;\r\nconst UPPER_BUFFER_RANGE = (index: number, lastIndex) => index <= lastIndex;\r\n\r\nconst getAmountOfCellsThatAreVisibleInTheBuffer = (\r\n  increment: -1 | 1,\r\n  bufferSize: number,\r\n  renderedCells: HTMLChSmartGridCellElement[],\r\n  smartGridBoundingRect: DOMRect\r\n): number => {\r\n  const lastRenderedCellIndex = renderedCells.length - 1;\r\n\r\n  const indexLimit =\r\n    increment === 1 ? lastRenderedCellIndex - bufferSize : bufferSize;\r\n  const checkIndexRange =\r\n    increment === 1 ? UPPER_BUFFER_RANGE : LOWER_BUFFER_RANGE;\r\n\r\n  // Depending on the direction, start from the first or last index of the\r\n  // current rendered cells\r\n  let currentIndex = increment === 1 ? 0 : lastRenderedCellIndex;\r\n  let shift = bufferSize;\r\n\r\n  // Check how many cells are visible in the buffer\r\n  while (checkIndexRange(currentIndex, indexLimit)) {\r\n    const currentCell = renderedCells[currentIndex];\r\n\r\n    if (isRenderedSmartCellVisible(currentCell, smartGridBoundingRect)) {\r\n      break;\r\n    }\r\n\r\n    shift--;\r\n    currentIndex += increment;\r\n  }\r\n\r\n  return shift;\r\n};\r\n\r\n/**\r\n * Depending on the scroll position and the bufferSize, it returns the start\r\n * and end index of the virtual array to rendered the cells\r\n */\r\nexport const getNewStartAndEndIndexes = (\r\n  scroller: HTMLChVirtualScrollerElement,\r\n  smartGrid: HTMLChSmartGridElement,\r\n  items: SmartGridModel,\r\n  virtualSizes: Map<string, SmartGridCellVirtualSize>,\r\n  virtualStartSize: number,\r\n  virtualEndSize: number,\r\n  bufferSize: number,\r\n  inverseLoading: boolean\r\n): SmartGridVirtualPosition => {\r\n  const renderedCells = getSmartCells(scroller);\r\n  const allCellsAreRendered = renderedCells.every(cellIsRendered);\r\n\r\n  // All cells must be rendered before trying to update the DOM\r\n  if (!allCellsAreRendered) {\r\n    return WAITING_FOR_CELLS_TO_BE_RENDERED;\r\n  }\r\n\r\n  // DOM read operations\r\n  const smartGridBoundingRect = smartGrid.getBoundingClientRect();\r\n  const smartGridScrollTop = smartGrid.scrollTop;\r\n\r\n  // TODO: Force the buffer to be at least 2\r\n  const secondRenderedCell = renderedCells[1];\r\n\r\n  const scrollIsAtVirtualStartSize =\r\n    virtualStartSize > 0 &&\r\n    secondRenderedCell.style.display !== \"none\" &&\r\n    smartGridScrollTop < secondRenderedCell.offsetTop;\r\n\r\n  if (scrollIsAtVirtualStartSize) {\r\n    return findFirstVirtualSizeThatIsNotVisible(\r\n      renderedCells,\r\n      items,\r\n      virtualSizes,\r\n      bufferSize,\r\n      smartGridScrollTop,\r\n      smartGridBoundingRect,\r\n      inverseLoading\r\n    );\r\n  }\r\n\r\n  const secondLastCell = renderedCells.at(-2);\r\n\r\n  const scrollIsAtVirtualEndSize =\r\n    virtualEndSize > 0 &&\r\n    secondLastCell.style.display !== \"none\" &&\r\n    secondLastCell.offsetTop + secondLastCell.getBoundingClientRect().height <\r\n      smartGridScrollTop;\r\n\r\n  if (scrollIsAtVirtualEndSize) {\r\n    return findFirstVirtualSizeThatIsNotVisible(\r\n      renderedCells,\r\n      items,\r\n      virtualSizes,\r\n      bufferSize,\r\n      smartGridScrollTop,\r\n      smartGridBoundingRect,\r\n      inverseLoading\r\n    );\r\n  }\r\n\r\n  const startShift = getAmountOfCellsThatAreVisibleInTheBuffer(\r\n    1,\r\n    bufferSize,\r\n    renderedCells,\r\n    smartGridBoundingRect\r\n  );\r\n  const endShift = inverseLoading\r\n    ? // We could use zero instead of this value, but this value ensure that\r\n      // dynamically added items at the end will always be rendered in the next\r\n      // frame\r\n      items.length - 1\r\n    : getAmountOfCellsThatAreVisibleInTheBuffer(\r\n        -1,\r\n        bufferSize,\r\n        renderedCells,\r\n        smartGridBoundingRect\r\n      );\r\n\r\n  return { startShift, endShift, renderedCells, type: \"shift\" };\r\n};\r\n",":host {\r\n  --ch-virtual-scroll__scroll-start-size: 0px;\r\n  --ch-virtual-scroll__scroll-end-size: 0px;\r\n\r\n  --ch-virtual-scroll__scroll-start-display: none;\r\n  --ch-virtual-scroll__scroll-end-display: none;\r\n\r\n  display: grid;\r\n  grid-auto-rows: max-content;\r\n}\r\n\r\n:host(.ch-virtual-scroller--content-not-loaded) {\r\n  opacity: 0;\r\n  // Necessary to ensure the scroll is positioned correctly when using inverseLoading\r\n  pointer-events: none;\r\n}\r\n\r\n// This is an optimization to avoid flickering when swapping cell.\r\n// With this CSS, cells being rendered do not take up space until they are\r\n// fully rendered. When they are fully rendered, we make the cells take up\r\n// space and in the same DOM write operation we update the virtual scroll size\r\n:host(.ch-virtual-scroller--content-loaded)\r\n  ::slotted(ch-smart-grid-cell:not([data-did-load])) {\r\n  position: absolute;\r\n  pointer-events: none;\r\n  visibility: hidden;\r\n}\r\n\r\n:host(.ch-virtual-scroller--virtual-scroll) {\r\n  &::before {\r\n    content: \"\";\r\n    display: var(--ch-virtual-scroll__scroll-start-display);\r\n    block-size: calc(var(--ch-virtual-scroll__scroll-start-size));\r\n    inline-size: 0px;\r\n    pointer-events: none;\r\n  }\r\n\r\n  &::after {\r\n    content: \"\";\r\n    display: var(--ch-virtual-scroll__scroll-end-display);\r\n    block-size: calc(var(--ch-virtual-scroll__scroll-end-size));\r\n    inline-size: 0px;\r\n    pointer-events: none;\r\n  }\r\n}\r\n","import {\r\n  Component,\r\n  ComponentInterface,\r\n  Element,\r\n  Event,\r\n  EventEmitter,\r\n  h,\r\n  Host,\r\n  Method,\r\n  Prop,\r\n  State,\r\n  Watch\r\n} from \"@stencil/core\";\r\nimport { emptyItems } from \"./utils\";\r\nimport { SyncWithRAF } from \"../common/sync-with-frames\";\r\nimport { SmartGridModel } from \"../components/smart-grid/types\";\r\nimport { SmartGridCellVirtualSize, VirtualScrollVirtualItems } from \"./types\";\r\nimport { updateVirtualScrollSize } from \"./update-virtual-scroll\";\r\nimport { ChSmartGridCellCustomEvent } from \"../components\";\r\nimport { cellsInViewportAreLoadedAndVisible } from \"./cells-in-viewport-are-rendered-and-visible\";\r\nimport { getNewStartAndEndIndexes } from \"./get-new-start-and-end-indexes\";\r\n\r\nconst VIRTUAL_SCROLL_CUSTOM_VAR_PREFIX = \"--ch-virtual-scroll__scroll-\";\r\n\r\nconst VIRTUAL_SCROLL_START_SIZE_CUSTOM_VAR = `${VIRTUAL_SCROLL_CUSTOM_VAR_PREFIX}start-size`;\r\nconst VIRTUAL_SCROLL_START_DISPLAY_CUSTOM_VAR = `${VIRTUAL_SCROLL_CUSTOM_VAR_PREFIX}start-display`;\r\n\r\nconst VIRTUAL_SCROLL_END_SIZE_CUSTOM_VAR = `${VIRTUAL_SCROLL_CUSTOM_VAR_PREFIX}end-size`;\r\nconst VIRTUAL_SCROLL_END_DISPLAY_CUSTOM_VAR = `${VIRTUAL_SCROLL_CUSTOM_VAR_PREFIX}end-display`;\r\n\r\n@Component({\r\n  shadow: true,\r\n  styleUrl: \"virtual-scroller.scss\",\r\n  tag: \"ch-virtual-scroller\"\r\n})\r\nexport class ChVirtualScroller implements ComponentInterface {\r\n  #startIndex = 0;\r\n  #endIndex = 0;\r\n\r\n  #virtualStartSize = 0;\r\n  #virtualEndSize = 0;\r\n\r\n  #canUpdateRenderedCells = true;\r\n  #waitingForCellsToBeRendered = false;\r\n\r\n  #abortController: AbortController | undefined; // Allocated at runtime to save resources\r\n  #syncWithRAF = new SyncWithRAF();\r\n\r\n  #virtualSizes: Map<string, SmartGridCellVirtualSize> | undefined; // Allocated at runtime to save resources\r\n\r\n  #resizeObserver: ResizeObserver | undefined;\r\n\r\n  /**\r\n   * This element represents the ch-smart-grid element.\r\n   * ```tsx\r\n   *   <ch-smart-grid>\r\n   *     #shadow-root (open)\r\n   *     |  <ch-infinite-scroll></ch-infinite-scroll>\r\n   *     |  <slot name=\"grid-content\"></slot>\r\n   *     <ch-smart-grid-virtual-scroller slot=\"grid-content\">\r\n   *       <ch-smart-grid-cell>...</ch-smart-grid-cell>\r\n   *       <ch-smart-grid-cell>...</ch-smart-grid-cell>\r\n   *       ...\r\n   *     </ch-smart-grid-virtual-scroller>\r\n   *   </ch-smart-grid>\r\n   * ```\r\n   */\r\n  // eslint-disable-next-line @stencil-community/own-props-must-be-private\r\n  #smartGrid!: HTMLChSmartGridElement | undefined;\r\n\r\n  @Element() el!: HTMLChVirtualScrollerElement;\r\n\r\n  /**\r\n   * `true` if the virtual scroller is waiting for all the content to be\r\n   * rendered.\r\n   */\r\n  @State() waitingForContent = true;\r\n  @Watch(\"waitingForContent\")\r\n  waitingForContentChanged() {\r\n    this.#setVirtualScroller();\r\n  }\r\n\r\n  /**\r\n   * The number of elements to be rendered above and below the current\r\n   * container's viewport.\r\n   */\r\n  @Prop() readonly bufferAmount: number = 5;\r\n\r\n  /**\r\n   * Specifies an estimation for the items that will enter in the viewport of\r\n   * the initial render.\r\n   */\r\n  // TODO: Ensure a min value\r\n  @Prop() readonly initialRenderViewportItems: number = 10;\r\n\r\n  /**\r\n   * When set to `true`, the grid items will be loaded in inverse order, with\r\n   * the scroll positioned at the bottom on the initial load.\r\n   *\r\n   * If `mode=\"virtual-scroll\"`, only the items at the start of the viewport\r\n   * that are not visible will be removed from the DOM. The items at the end of\r\n   * the viewport that are not visible will remain rendered to avoid flickering\r\n   * issues.\r\n   */\r\n  @Prop() readonly inverseLoading: boolean = false;\r\n\r\n  /**\r\n   * The array of items to be rendered in the ch-smart-grid.\r\n   */\r\n  @Prop() readonly items!: SmartGridModel | undefined;\r\n  @Watch(\"items\")\r\n  itemsChanged(newItems: SmartGridModel) {\r\n    this.#resetVirtualScrollerState();\r\n    this.#setViewportItemsOnInitialRender(newItems);\r\n  }\r\n\r\n  /**\r\n   * The number of elements in the items array.\r\n   * Use if the array changes, without recreating the array.\r\n   */\r\n  @Prop() readonly itemsCount: number;\r\n\r\n  /**\r\n   * Specifies how the control will behave.\r\n   */\r\n  @Prop() readonly mode: \"virtual-scroll\" | \"lazy-render\" = \"virtual-scroll\";\r\n\r\n  /**\r\n   * Emitted when the array of visible items in the ch-smart-grid changes.\r\n   */\r\n  @Event()\r\n  virtualItemsChanged: EventEmitter<VirtualScrollVirtualItems>;\r\n\r\n  /**\r\n   * Fired when the visible content of the virtual scroller did render for the\r\n   * first time.\r\n   */\r\n  @Event() virtualScrollerDidLoad: EventEmitter;\r\n\r\n  /**\r\n   * Add items to the beginning or end of the items property. This method is\r\n   * useful for adding new items to the collection, without impacting in the\r\n   * internal indexes used to display the virtual items. Without this method,\r\n   * the virtual scroll would behave unexpectedly when new items are added.\r\n   */\r\n  @Method()\r\n  async addItems(position: \"start\" | \"end\", ...items: SmartGridModel) {\r\n    if (position === \"start\") {\r\n      this.items.unshift(...items);\r\n\r\n      const newItemsCount = items.length;\r\n      this.#startIndex += newItemsCount;\r\n      this.#endIndex += newItemsCount;\r\n    } else {\r\n      this.items.push(...items);\r\n    }\r\n\r\n    this.#handleSmartGridContentScroll();\r\n  }\r\n\r\n  // TODO: Check what happens when the cells has margin\r\n  #updateVirtualScrollSize = (removedCells?: HTMLChSmartGridCellElement[]) => {\r\n    this.#virtualStartSize = 0;\r\n    this.#virtualEndSize = 0;\r\n\r\n    const items = this.items;\r\n    const virtualSizes = this.#virtualSizes;\r\n    const lastIndex = items.length - 1;\r\n\r\n    // - - - - - - - - - - - - - DOM read operations - - - - - - - - - - - - -\r\n    const lastIndexForVirtualStartSize = Math.max(0, this.#startIndex - 1);\r\n    const firstIndexForVirtualEndSize = Math.min(lastIndex, this.#endIndex + 1);\r\n\r\n    const lastCellForVirtualStartSize = virtualSizes.get(\r\n      items[lastIndexForVirtualStartSize].id\r\n    );\r\n    const firstCellForVirtualEndSize = virtualSizes.get(\r\n      items[firstIndexForVirtualEndSize].id\r\n    );\r\n\r\n    // The virtual start size is at least the last unrendered cell\r\n    if (lastCellForVirtualStartSize) {\r\n      this.#virtualStartSize =\r\n        lastCellForVirtualStartSize.offsetTop +\r\n        lastCellForVirtualStartSize.height;\r\n    }\r\n\r\n    const additionalHeightsStartIndex = Math.max(1, this.#startIndex);\r\n\r\n    // TODO: Add support for gap in this virtual sizes\r\n    // Between two different animation frames, rendered cells can be destroyed\r\n    // and replaced by other new ones. When cells are destroyed the scroll size\r\n    // must be maintained. To do this, the virtual start size is increased by\r\n    // the size of the cells that have not yet been rendered\r\n    for (\r\n      let virtualIndex = additionalHeightsStartIndex;\r\n      virtualIndex < this.#endIndex;\r\n      virtualIndex++\r\n    ) {\r\n      const cellIdToAddVirtualSize = items[virtualIndex].id;\r\n      const virtualSize = virtualSizes.get(cellIdToAddVirtualSize);\r\n\r\n      if (virtualSize) {\r\n        this.#virtualStartSize += virtualSize.height;\r\n      }\r\n    }\r\n\r\n    // Additional size for the virtual start scroll\r\n    if (this.#endIndex === lastIndex) {\r\n      const cellIdToAddVirtualSize = items[this.#endIndex].id;\r\n      const virtualSize = virtualSizes.get(cellIdToAddVirtualSize);\r\n\r\n      if (virtualSize) {\r\n        this.#virtualStartSize += virtualSize.height;\r\n      }\r\n    }\r\n    // Virtual end scroll\r\n    else if (firstCellForVirtualEndSize) {\r\n      let maxSmartGridVirtualHeight = 0;\r\n\r\n      virtualSizes.forEach(virtualSize => {\r\n        maxSmartGridVirtualHeight = Math.max(\r\n          maxSmartGridVirtualHeight,\r\n          virtualSize.offsetTop + virtualSize.height\r\n        );\r\n      });\r\n\r\n      this.#virtualEndSize =\r\n        maxSmartGridVirtualHeight - firstCellForVirtualEndSize.offsetTop;\r\n    }\r\n\r\n    // - - - - - - - - - - - - - DOM write operations - - - - - - - - - - - - -\r\n    // Faster removal of the cells, due to the virtual height will be updated\r\n    // in the next DOM write operation\r\n    removedCells?.forEach(removedCell => {\r\n      removedCell.style.display = \"none\";\r\n    });\r\n\r\n    this.el.style.setProperty(\r\n      VIRTUAL_SCROLL_START_SIZE_CUSTOM_VAR,\r\n      `${this.#virtualStartSize}px`\r\n    );\r\n    this.el.style.setProperty(\r\n      VIRTUAL_SCROLL_START_DISPLAY_CUSTOM_VAR,\r\n      // The virtual size must be \"destroyed\" to avoid displaying and\r\n      // unnecessary gap at the start of the scroll\r\n      this.#virtualStartSize === 0 ? \"none\" : \"block\"\r\n    );\r\n\r\n    this.el.style.setProperty(\r\n      VIRTUAL_SCROLL_END_SIZE_CUSTOM_VAR,\r\n      `${this.#virtualEndSize}px`\r\n    );\r\n    this.el.style.setProperty(\r\n      VIRTUAL_SCROLL_END_DISPLAY_CUSTOM_VAR,\r\n      // The virtual size must be \"destroyed\" to avoid displaying and\r\n      // unnecessary gap at the end of the scroll\r\n      this.#virtualEndSize === 0 ? \"none\" : \"block\"\r\n    );\r\n  };\r\n\r\n  #handleSmartGridContentScroll = () => {\r\n    if (this.#canUpdateRenderedCells) {\r\n      this.#syncWithRAF.perform(this.#updateRenderedCells);\r\n    }\r\n  };\r\n\r\n  #updateRenderedCells = () => {\r\n    // this.#canUpdateRenderedCells = false;\r\n\r\n    // requestAnimationFrame(() => {\r\n    //   this.#canUpdateRenderedCells = true;\r\n    // });\r\n\r\n    const cellsToRender = getNewStartAndEndIndexes(\r\n      this.el,\r\n      this.#smartGrid,\r\n      this.items,\r\n      this.#virtualSizes,\r\n      this.#virtualStartSize,\r\n      this.#virtualEndSize,\r\n      this.bufferAmount,\r\n      this.inverseLoading\r\n    );\r\n\r\n    if (cellsToRender.type === \"waiting-for-cells-to-render\") {\r\n      this.#waitingForCellsToBeRendered = true;\r\n      return;\r\n    }\r\n    this.#waitingForCellsToBeRendered = false;\r\n\r\n    if (cellsToRender.type === \"shift\") {\r\n      if (cellsToRender.startShift === 0 && cellsToRender.endShift === 0) {\r\n        return;\r\n      }\r\n\r\n      this.#shiftIndex(\r\n        cellsToRender.startShift,\r\n        cellsToRender.endShift,\r\n        cellsToRender.renderedCells\r\n      );\r\n    }\r\n    //\r\n    else {\r\n      const { startIndex, endIndex } = cellsToRender;\r\n\r\n      // Nothing to update\r\n      if (this.#startIndex === startIndex && this.#endIndex === endIndex) {\r\n        return;\r\n      }\r\n\r\n      const removedCells = updateVirtualScrollSize(\r\n        cellsToRender,\r\n        this.#virtualSizes,\r\n        this.items\r\n      );\r\n\r\n      this.#startIndex = startIndex;\r\n      this.#endIndex = endIndex;\r\n\r\n      this.#emitVirtualItemsChange(removedCells);\r\n    }\r\n  };\r\n\r\n  #emitVirtualItemsChange = (removedCells?: HTMLChSmartGridCellElement[]) => {\r\n    this.#updateVirtualScrollSize(removedCells);\r\n    const virtualItems = this.items.slice(this.#startIndex, this.#endIndex + 1);\r\n\r\n    this.virtualItemsChanged.emit({\r\n      startIndex: this.#startIndex,\r\n      endIndex: this.#endIndex,\r\n      totalItems: this.items.length,\r\n      virtualItems\r\n    });\r\n  };\r\n\r\n  #resetVirtualScrollerState = () => {\r\n    this.#virtualStartSize = 0;\r\n    this.#virtualEndSize = 0;\r\n\r\n    // Render the last items when the scroll is inverted\r\n    if (this.inverseLoading) {\r\n      const lastIndex = this.items.length - 1;\r\n\r\n      this.#startIndex = lastIndex;\r\n      this.#endIndex = lastIndex;\r\n    } else {\r\n      this.#startIndex = 0;\r\n      this.#endIndex = 0;\r\n    }\r\n\r\n    if (this.mode === \"virtual-scroll\") {\r\n      this.#virtualSizes = new Map();\r\n    }\r\n  };\r\n\r\n  #setViewportItemsOnInitialRender = (items: SmartGridModel) => {\r\n    if (emptyItems(items)) {\r\n      this.#emitVirtualItemsChange();\r\n      return;\r\n    }\r\n\r\n    const indexToShift = this.initialRenderViewportItems + this.bufferAmount;\r\n\r\n    if (this.inverseLoading) {\r\n      this.#shiftIndex(indexToShift, 0);\r\n    } else {\r\n      this.#shiftIndex(0, indexToShift);\r\n    }\r\n  };\r\n\r\n  #shiftIndex = (\r\n    startIncomingShift: number,\r\n    endIncomingShift: number,\r\n    renderedCells?: HTMLChSmartGridCellElement[]\r\n  ) => {\r\n    const startShift =\r\n      this.mode === \"lazy-render\"\r\n        ? Math.max(0, startIncomingShift)\r\n        : startIncomingShift;\r\n    const endShift =\r\n      this.mode === \"lazy-render\"\r\n        ? Math.max(0, endIncomingShift)\r\n        : endIncomingShift;\r\n\r\n    // Nothing to update\r\n    if (startShift === 0 && endShift === 0) {\r\n      return;\r\n    }\r\n\r\n    const newEndIndex = Math.min(\r\n      this.#endIndex + endShift,\r\n      this.items.length - 1\r\n    );\r\n\r\n    // const lastEndIndex = this.items.length - 1 === endShift;\r\n    // const adjustmentToAvoidFlickering = lastEndIndex ? 1 : 0;\r\n\r\n    const newStartIndex = Math.max(0, this.#startIndex - startShift);\r\n\r\n    // Nothing to update\r\n    if (\r\n      this.#startIndex === newStartIndex &&\r\n      this.#endIndex === newEndIndex &&\r\n      // TODO: Add a unit test for this use case\r\n      this.items.length > 1\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    this.#startIndex = newStartIndex;\r\n    this.#endIndex = newEndIndex;\r\n\r\n    const removedCells =\r\n      this.mode === \"virtual-scroll\" &&\r\n      renderedCells !== undefined &&\r\n      renderedCells.length > 0\r\n        ? updateVirtualScrollSize(\r\n            {\r\n              endIndex: this.#endIndex,\r\n              startIndex: this.#startIndex,\r\n              renderedCells,\r\n              type: \"index\"\r\n            },\r\n            this.#virtualSizes,\r\n            this.items\r\n          )\r\n        : [];\r\n\r\n    this.#emitVirtualItemsChange(removedCells);\r\n  };\r\n\r\n  #setVirtualScroller = () => {\r\n    this.#abortController = new AbortController();\r\n\r\n    // RAF is used to avoid unnecessary check on the initial load when using\r\n    // inverseLoading, since on the initial load the scroll will be repositioned\r\n    requestAnimationFrame(() => {\r\n      this.#smartGrid.addEventListener(\r\n        \"scroll\",\r\n        this.#handleSmartGridContentScroll,\r\n        {\r\n          passive: true,\r\n          signal: this.#abortController.signal\r\n        }\r\n      );\r\n\r\n      this.#resizeObserver = new ResizeObserver(\r\n        this.#handleSmartGridContentScroll\r\n      );\r\n      this.#resizeObserver.observe(this.#smartGrid);\r\n    });\r\n  };\r\n\r\n  #handleRenderedCell = (event: ChSmartGridCellCustomEvent<string>) => {\r\n    if (this.waitingForContent) {\r\n      this.#checkInitialRenderVisibility();\r\n    } else {\r\n      this.#checkCellsRenderedAtRuntime(event.detail);\r\n    }\r\n  };\r\n\r\n  #checkInitialRenderVisibility = () =>\r\n    this.#syncWithRAF.perform(() => {\r\n      const waitingForContent = !cellsInViewportAreLoadedAndVisible(\r\n        this.el,\r\n        this.#smartGrid,\r\n        this.inverseLoading\r\n      );\r\n\r\n      if (!waitingForContent) {\r\n        requestAnimationFrame(() => {\r\n          this.virtualScrollerDidLoad.emit();\r\n          this.waitingForContent = waitingForContent;\r\n        });\r\n      }\r\n    });\r\n\r\n  #checkCellsRenderedAtRuntime = (cellId: string) => {\r\n    // Delete virtual size, since the cell is now rendered\r\n    this.#virtualSizes.delete(cellId);\r\n\r\n    this.#updateVirtualScrollSize();\r\n\r\n    if (this.#waitingForCellsToBeRendered) {\r\n      this.#handleSmartGridContentScroll();\r\n    }\r\n  };\r\n\r\n  connectedCallback(): void {\r\n    // Listen for the render of the smart cells\r\n    this.el.addEventListener(\"smartCellDidLoad\", this.#handleRenderedCell);\r\n\r\n    this.#resetVirtualScrollerState();\r\n  }\r\n\r\n  componentDidLoad(): void {\r\n    this.#smartGrid = this.el.closest(\"ch-smart-grid\");\r\n    this.#setViewportItemsOnInitialRender(this.items);\r\n  }\r\n\r\n  disconnectedCallback(): void {\r\n    this.#resizeObserver?.disconnect();\r\n    this.#resizeObserver = undefined;\r\n\r\n    this.#syncWithRAF.cancel();\r\n    this.#syncWithRAF = undefined;\r\n\r\n    // Remove scroll events in the smart grid\r\n    this.#abortController.abort();\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <Host\r\n        class={{\r\n          \"ch-virtual-scroller--content-not-loaded\": this.waitingForContent,\r\n          \"ch-virtual-scroller--content-loaded\": !this.waitingForContent,\r\n          \"ch-virtual-scroller--virtual-scroll\":\r\n            !this.waitingForContent && this.mode === \"virtual-scroll\"\r\n        }}\r\n      >\r\n        <slot\r\n          onSlotchange={\r\n            this.waitingForContent\r\n              ? this.#checkInitialRenderVisibility\r\n              : undefined\r\n          }\r\n        ></slot>\r\n      </Host>\r\n    );\r\n  }\r\n}\r\n"],"mappings":"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"}